<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>groatesque - crespo.world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 2em;
    }
    nav {
      margin-bottom: 1em;
    }
    nav a {
      color: #0f0;
      text-decoration: none;
      margin: 0 1em;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    h1 { font-size: 2em; margin-bottom: 0.5em; }
    #board {
      display: inline-grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 3px solid #0f0;
      margin: 1em auto;
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      cursor: pointer;
      user-select: none;
    }
    .square.light { background: #333; }
    .square.dark { background: #111; }
    .square.selected { background: #050; }
    .square.highlight { background: #550; }
    .square:hover { opacity: 0.8; }
    #message {
      margin-top: 1em;
      min-height: 3em;
      color: #0f0;
      font-size: 1.2em;
    }
    #promotion {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #000;
      border: 3px solid #0f0;
      padding: 20px;
      z-index: 1000;
    }
    #promotion.show { display: block; }
    .promo-piece {
      display: inline-block;
      font-size: 60px;
      margin: 10px;
      cursor: pointer;
      padding: 10px;
      border: 2px solid transparent;
    }
    .promo-piece:hover {
      border-color: #0f0;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">home</a>
    <a href="officecam.html">officecam</a>
    <a href="crespomize.html">crespomize</a>
    <a href="recipeasy.html">recipeasy</a>
    <a href="groatesque.html">groatesque</a>
  </nav>

  <h1>chess for nolan</h1>
  <div id="board"></div>
  <div id="message">your move, nolan.</div>
  
  <div id="promotion">
    <div>choose promotion:</div>
    <div id="promo-pieces"></div>
  </div>
  
  <script>
    // chess.js-like minimal implementation
    const EMPTY = 0;
    const PAWN = 1, KNIGHT = 2, BISHOP = 3, ROOK = 4, QUEEN = 5, KING = 6;
    const WHITE = 8, BLACK = 16;
    
    const pieceChars = {
      [BLACK|ROOK]: '♜', [BLACK|KNIGHT]: '♞', [BLACK|BISHOP]: '♝', 
      [BLACK|QUEEN]: '♛', [BLACK|KING]: '♚', [BLACK|PAWN]: '♟',
      [WHITE|ROOK]: '♖', [WHITE|KNIGHT]: '♘', [WHITE|BISHOP]: '♗', 
      [WHITE|QUEEN]: '♕', [WHITE|KING]: '♔', [WHITE|PAWN]: '♙'
    };
    
    const pieceNames = {
      [PAWN]: 'pawn', [KNIGHT]: 'knight', [BISHOP]: 'bishop',
      [ROOK]: 'rook', [QUEEN]: 'queen', [KING]: 'king'
    };
    
    const pieceValues = {
      [PAWN]: 100, [KNIGHT]: 320, [BISHOP]: 330, 
      [ROOK]: 500, [QUEEN]: 900, [KING]: 20000
    };
    
    const names = ['nolan', 'groat'];
    const goodWords = ['solid', 'decent', 'respectable', 'not bad', 'acceptable', 'competent', 'reasonable'];
    const pestCompanies = [
      'truly nolen', 'orkin', 'terminix', 'ehrlich', 'guardian pest services',
      'best home & property services', 'real deal pest control', 'trutech wildlife'
    ];
    const nolanFacts = [
      "remember when you did science olympiad? bridge building champ right here",
      "belfast lions represent",
      "how's the swimming going these days?",
      "maine's finest right here",
      "you still doing those scrambler challenges?",
      "basketball season treating you well?"
    ];
    
    let board = new Uint8Array(64);
    let turn = WHITE;
    let selected = null;
    let validMoves = [];
    let gameOver = false;
    let enPassantTarget = -1;
    let pendingPromotion = null;
    let whiteKingMoved = false;
    let blackKingMoved = false;
    let whiteRooksMoved = {0: false, 7: false}; // queenside, kingside
    let blackRooksMoved = {56: false, 63: false};
    
    function initBoard() {
      const setup = [
        BLACK|ROOK, BLACK|KNIGHT, BLACK|BISHOP, BLACK|QUEEN, BLACK|KING, BLACK|BISHOP, BLACK|KNIGHT, BLACK|ROOK,
        BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN,
        0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
        WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN,
        WHITE|ROOK, WHITE|KNIGHT, WHITE|BISHOP, WHITE|QUEEN, WHITE|KING, WHITE|BISHOP, WHITE|KNIGHT, WHITE|ROOK
      ];
      board.set(setup);
    }
    
    function idx(r, c) { return r * 8 + c; }
    function row(i) { return Math.floor(i / 8); }
    function col(i) { return i % 8; }
    function piece(i) { return board[i] & 7; }
    function color(i) { return board[i] & 24; }
    function rand(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function randName() { return rand(names); }
    
    function getPseudoMoves(pos, includeEnPassant = true, includeCastling = true) {
      const moves = [];
      const p = piece(pos);
      const c = color(pos);
      const r = row(pos);
      const col_ = col(pos);
      
      if (p === PAWN) {
        const dir = c === WHITE ? -1 : 1;
        const startRow = c === WHITE ? 6 : 1;
        const nextRow = r + dir;
        
        if (nextRow >= 0 && nextRow < 8) {
          const front = idx(nextRow, col_);
          if (board[front] === EMPTY) {
            moves.push({from: pos, to: front});
            if (r === startRow) {
              const front2 = idx(r + dir * 2, col_);
              if (board[front2] === EMPTY) {
                moves.push({from: pos, to: front2, doublePush: true});
              }
            }
          }
          
          for (let dc of [-1, 1]) {
            const nc = col_ + dc;
            if (nc >= 0 && nc < 8) {
              const diag = idx(nextRow, nc);
              if (board[diag] !== EMPTY && color(diag) !== c) {
                moves.push({from: pos, to: diag});
              }
              // en passant
              if (includeEnPassant && diag === enPassantTarget) {
                moves.push({from: pos, to: diag, enPassant: true});
              }
            }
          }
        }
      } else if (p === KNIGHT) {
        const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for (let [dr, dc] of offsets) {
          const nr = r + dr, nc = col_ + dc;
          if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            const to = idx(nr, nc);
            if (color(to) !== c) moves.push({from: pos, to});
          }
        }
      } else if (p === BISHOP || p === ROOK || p === QUEEN) {
        const dirs = p === ROOK ? [[0,1],[0,-1],[1,0],[-1,0]] :
                     p === BISHOP ? [[1,1],[1,-1],[-1,1],[-1,-1]] :
                     [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
        for (let [dr, dc] of dirs) {
          let nr = r + dr, nc = col_ + dc;
          while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            const to = idx(nr, nc);
            if (board[to] === EMPTY) {
              moves.push({from: pos, to});
            } else {
              if (color(to) !== c) moves.push({from: pos, to});
              break;
            }
            nr += dr; nc += dc;
          }
        }
      } else if (p === KING) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = r + dr, nc = col_ + dc;
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
              const to = idx(nr, nc);
              if (color(to) !== c) moves.push({from: pos, to});
            }
          }
        }
        
        // castling
        if (includeCastling && !isInCheck(c)) {
          if (c === WHITE && !whiteKingMoved && pos === 60) {
            // kingside
            if (!whiteRooksMoved[63] && board[61] === EMPTY && board[62] === EMPTY) {
              if (!isSquareAttacked(61, c) && !isSquareAttacked(62, c)) {
                moves.push({from: pos, to: 62, castle: 'K'});
              }
            }
            // queenside
            if (!whiteRooksMoved[56] && board[59] === EMPTY && board[58] === EMPTY && board[57] === EMPTY) {
              if (!isSquareAttacked(59, c) && !isSquareAttacked(58, c)) {
                moves.push({from: pos, to: 58, castle: 'Q'});
              }
            }
          } else if (c === BLACK && !blackKingMoved && pos === 4) {
            // kingside
            if (!blackRooksMoved[7] && board[5] === EMPTY && board[6] === EMPTY) {
              if (!isSquareAttacked(5, c) && !isSquareAttacked(6, c)) {
                moves.push({from: pos, to: 6, castle: 'k'});
              }
            }
            // queenside
            if (!blackRooksMoved[0] && board[3] === EMPTY && board[2] === EMPTY && board[1] === EMPTY) {
              if (!isSquareAttacked(3, c) && !isSquareAttacked(2, c)) {
                moves.push({from: pos, to: 2, castle: 'q'});
              }
            }
          }
        }
      }
      
      return moves;
    }
    
    function isSquareAttacked(pos, byColor) {
      const enemyColor = byColor === WHITE ? BLACK : WHITE;
      for (let i = 0; i < 64; i++) {
        if (color(i) === enemyColor) {
          const moves = getPseudoMoves(i, false, false);
          if (moves.some(m => m.to === pos)) return true;
        }
      }
      return false;
    }
    
    function isInCheck(c) {
      let kingPos = -1;
      for (let i = 0; i < 64; i++) {
        if (board[i] === (c | KING)) {
          kingPos = i;
          break;
        }
      }
      if (kingPos === -1) return false;
      return isSquareAttacked(kingPos, c);
    }
    
    function getAllMoves(c) {
      const moves = [];
      for (let i = 0; i < 64; i++) {
        if (color(i) === c) {
          moves.push(...getPseudoMoves(i));
        }
      }
      
      return moves.filter(m => {
        const oldTo = board[m.to];
        const oldEp = enPassantTarget;
        
        // handle en passant capture
        let capturedPawn = -1;
        if (m.enPassant) {
          const dir = c === WHITE ? 1 : -1;
          capturedPawn = idx(row(m.to) + dir, col(m.to));
          board[capturedPawn] = EMPTY;
        }
        
        // handle castling
        let rookMove = null;
        if (m.castle) {
          if (m.castle === 'K') {
            board[61] = board[63];
            board[63] = EMPTY;
            rookMove = {from: 63, to: 61};
          } else if (m.castle === 'Q') {
            board[59] = board[56];
            board[56] = EMPTY;
            rookMove = {from: 56, to: 59};
          } else if (m.castle === 'k') {
            board[5] = board[7];
            board[7] = EMPTY;
            rookMove = {from: 7, to: 5};
          } else if (m.castle === 'q') {
            board[3] = board[0];
            board[0] = EMPTY;
            rookMove = {from: 0, to: 3};
          }
        }
        
        board[m.to] = board[m.from];
        board[m.from] = EMPTY;
        
        const inCheck = isInCheck(c);
        
        board[m.from] = board[m.to];
        board[m.to] = oldTo;
        enPassantTarget = oldEp;
        
        if (m.enPassant) {
          board[capturedPawn] = (c === WHITE ? BLACK : WHITE) | PAWN;
        }
        
        if (rookMove) {
          board[rookMove.from] = board[rookMove.to];
          board[rookMove.to] = EMPTY;
        }
        
        return !inCheck;
      });
    }
    
    function makeMove(move, promotion = QUEEN) {
      const oldEp = enPassantTarget;
      enPassantTarget = -1;
      
      // track king and rook movement
      if (piece(move.from) === KING) {
        if (color(move.from) === WHITE) whiteKingMoved = true;
        else blackKingMoved = true;
      }
      if (piece(move.from) === ROOK) {
        if (move.from === 56) whiteRooksMoved[56] = true;
        if (move.from === 63) whiteRooksMoved[63] = true;
        if (move.from === 0) blackRooksMoved[0] = true;
        if (move.from === 7) blackRooksMoved[7] = true;
      }
      
      // en passant capture
      if (move.enPassant) {
        const dir = color(move.from) === WHITE ? 1 : -1;
        const capturedPawn = idx(row(move.to) + dir, col(move.to));
        board[capturedPawn] = EMPTY;
      }
      
      // castling
      if (move.castle) {
        if (move.castle === 'K') {
          board[61] = board[63];
          board[63] = EMPTY;
        } else if (move.castle === 'Q') {
          board[59] = board[56];
          board[56] = EMPTY;
        } else if (move.castle === 'k') {
          board[5] = board[7];
          board[7] = EMPTY;
        } else if (move.castle === 'q') {
          board[3] = board[0];
          board[0] = EMPTY;
        }
      }
      
      // double pawn push - set en passant target
      if (move.doublePush) {
        const dir = color(move.from) === WHITE ? -1 : 1;
        enPassantTarget = idx(row(move.from) + dir, col(move.from));
      }
      
      board[move.to] = board[move.from];
      board[move.from] = EMPTY;
      
      // pawn promotion
      if (piece(move.to) === PAWN && (row(move.to) === 0 || row(move.to) === 7)) {
        board[move.to] = color(move.to) | promotion;
      }
      
      return oldEp;
    }
    
    function unmakeMove(move, captured, oldEp, wasPromotion = false) {
      enPassantTarget = oldEp;
      
      board[move.from] = board[move.to];
      board[move.to] = captured;
      
      // restore pawn if it was promoted
      if (wasPromotion) {
        board[move.from] = color(move.from) | PAWN;
      }
      
      // restore en passant captured pawn
      if (move.enPassant) {
        const dir = color(move.from) === WHITE ? 1 : -1;
        const capturedPawn = idx(row(move.to) + dir, col(move.to));
        board[capturedPawn] = (color(move.from) === WHITE ? BLACK : WHITE) | PAWN;
        board[move.to] = EMPTY;
      }
      
      // undo castling
      if (move.castle) {
        if (move.castle === 'K') {
          board[63] = board[61];
          board[61] = EMPTY;
        } else if (move.castle === 'Q') {
          board[56] = board[59];
          board[59] = EMPTY;
        } else if (move.castle === 'k') {
          board[7] = board[5];
          board[5] = EMPTY;
        } else if (move.castle === 'q') {
          board[0] = board[3];
          board[3] = EMPTY;
        }
      }
    }
    
    function evaluate() {
      let score = 0;
      for (let i = 0; i < 64; i++) {
        if (board[i] === EMPTY) continue;
        const val = pieceValues[piece(i)];
        score += color(i) === WHITE ? -val : val;
      }
      return score;
    }
    
    function minimax(depth, alpha, beta, maximizing) {
      if (depth === 0) return evaluate();
      
      const c = maximizing ? BLACK : WHITE;
      const moves = getAllMoves(c);
      
      if (moves.length === 0) {
        if (isInCheck(c)) return maximizing ? -50000 : 50000;
        return 0;
      }
      
      if (maximizing) {
        let maxEval = -Infinity;
        for (let m of moves) {
          const cap = board[m.to];
          const wasPromo = piece(m.from) === PAWN && (row(m.to) === 0 || row(m.to) === 7);
          const oldEp = makeMove(m, QUEEN);
          const eval_ = minimax(depth - 1, alpha, beta, false);
          unmakeMove(m, cap, oldEp, wasPromo);
          maxEval = Math.max(maxEval, eval_);
          alpha = Math.max(alpha, eval_);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (let m of moves) {
          const cap = board[m.to];
          const wasPromo = piece(m.from) === PAWN && (row(m.to) === 0 || row(m.to) === 7);
          const oldEp = makeMove(m, QUEEN);
          const eval_ = minimax(depth - 1, alpha, beta, true);
          unmakeMove(m, cap, oldEp, wasPromo);
          minEval = Math.min(minEval, eval_);
          beta = Math.min(beta, eval_);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }
    
    function findBestMove() {
      const moves = getAllMoves(BLACK);
      if (moves.length === 0) return null;
      
      let bestMove = moves[0];
      let bestEval = -Infinity;
      
      for (let m of moves) {
        const cap = board[m.to];
        const wasPromo = piece(m.from) === PAWN && (row(m.to) === 0 || row(m.to) === 7);
        const oldEp = makeMove(m, QUEEN);
        const eval_ = minimax(2, -Infinity, Infinity, false);
        unmakeMove(m, cap, oldEp, wasPromo);
        
        if (eval_ > bestEval) {
          bestEval = eval_;
          bestMove = m;
        }
      }
      
      return bestMove;
    }
    
    function isPieceHanging(pos, c) {
      for (let i = 0; i < 64; i++) {
        if (color(i) !== EMPTY && color(i) !== c) {
          const moves = getPseudoMoves(i, false, false);
          if (moves.some(m => m.to === pos)) return true;
        }
      }
      return false;
    }
    
    function generateMessage(moveGood = true) {
      const name = randName();
      const messages = [];
      
      // 1 in 5 chance for nolan fact
      if (Math.random() < 0.2) {
        return rand(nolanFacts);
      }
      
      // random pest control mention
      if (Math.random() < 0.15) {
        return `man, i love ${rand(pestCompanies)} pest control`;
      }
      
      // random predictable comment
      if (Math.random() < 0.1) {
        return `you are so predictable bro bro`;
      }
      
      // if move was good, compliment it
      if (moveGood && Math.random() < 0.5) {
        const templates = [
          `${rand(goodWords)} move, ${name}`,
          `${name}, i like the ${rand(goodWords)} move`,
          `${rand(goodWords)}, ${name}`
        ];
        return rand(templates);
      }
      
      // default
      return `your move, ${name}.`;
    }
    
    function render() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const sq = document.createElement('div');
          const i = idx(r, c);
          sq.className = 'square ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
          sq.textContent = pieceChars[board[i]] || '';
          
          if (selected === i) sq.classList.add('selected');
          if (validMoves.some(m => m.to === i)) sq.classList.add('highlight');
          
          sq.addEventListener('click', () => handleClick(i));
          boardEl.appendChild(sq);
        }
      }
    }
    
    function showPromotion(c, callback) {
      const promoEl = document.getElementById('promotion');
      const piecesEl = document.getElementById('promo-pieces');
      piecesEl.innerHTML = '';
      
      const pieces = [QUEEN, ROOK, BISHOP, KNIGHT];
      pieces.forEach(p => {
        const div = document.createElement('div');
        div.className = 'promo-piece';
        div.textContent = pieceChars[c | p];
        div.addEventListener('click', () => {
          promoEl.classList.remove('show');
          callback(p);
        });
        piecesEl.appendChild(div);
      });
      
      promoEl.classList.add('show');
    }
    
    function handleClick(i) {
      if (gameOver || turn !== WHITE || pendingPromotion) return;
      
      if (selected !== null) {
        const move = validMoves.find(m => m.to === i);
        if (move) {
          const isPromotion = piece(move.from) === PAWN && row(move.to) === 0;
          const captured = board[move.to];
          
          if (isPromotion) {
            pendingPromotion = {move, captured};
            showPromotion(WHITE, (promo) => {
              makeMove(pendingPromotion.move, promo);
              pendingPromotion = null;
              finishPlayerMove();
            });
          } else {
            makeMove(move);
            finishPlayerMove();
          }
          
          selected = null;
          validMoves = [];
        } else if (color(i) === WHITE) {
          selected = i;
          validMoves = getAllMoves(WHITE).filter(m => m.from === i);
        } else {
          selected = null;
          validMoves = [];
        }
      } else if (color(i) === WHITE) {
        selected = i;
        validMoves = getAllMoves(WHITE).filter(m => m.from === i);
      }
      
      render();
    }
    
    function finishPlayerMove() {
      if (getAllMoves(BLACK).length === 0) {
        msg(isInCheck(BLACK) ? `checkmate! you win, ${randName()}!` : "stalemate!");
        gameOver = true;
      } else {
        turn = BLACK;
        msg("thinking...");
        render();
        setTimeout(botMove, 500);
      }
    }
    
    function botMove() {
      const move = findBestMove();
      if (!move) {
        msg(isInCheck(BLACK) ? `checkmate! you win, ${randName()}!` : "stalemate!");
        gameOver = true;
        render();
        return;
      }
      
      const captured = board[move.to];
      makeMove(move, QUEEN);
      turn = WHITE;
      
      if (getAllMoves(WHITE).length === 0) {
        msg(isInCheck(WHITE) ? "checkmate! i win!" : "stalemate!");
        gameOver = true;
      } else {
        const isBadMove = isPieceHanging(move.to, BLACK);
        const isGoodMove = !isBadMove && (captured !== EMPTY || move.castle);
        
        // if bad move, just say "your move"
        if (isBadMove) {
          msg(`your move, ${randName()}.`);
        } else {
          msg(generateMessage(isGoodMove));
        }
      }
      
      render();
    }
    
    function msg(text) {
      document.getElementById('message').textContent = text;
    }
    
    initBoard();
    render();
  </script>
</body>
</html>
