<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>groatesque - crespo.world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 2em;
    }
    nav {
      margin-bottom: 1em;
    }
    nav a {
      color: #0f0;
      text-decoration: none;
      margin: 0 1em;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    h1 { font-size: 2em; margin-bottom: 0.5em; }
    #board {
      display: inline-grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 3px solid #0f0;
      margin: 1em auto;
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      cursor: pointer;
      user-select: none;
    }
    .square.light { background: #333; }
    .square.dark { background: #111; }
    .square.selected { background: #050; }
    .square.highlight { background: #550; }
    .square:hover { opacity: 0.8; }
    #message {
      margin-top: 1em;
      min-height: 3em;
      color: #0f0;
      font-size: 1.2em;
    }
    #promotion {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #000;
      border: 3px solid #0f0;
      padding: 20px;
      z-index: 1000;
    }
    #promotion.show { display: block; }
    .promo-piece {
      display: inline-block;
      font-size: 60px;
      margin: 10px;
      cursor: pointer;
      padding: 10px;
      border: 2px solid transparent;
    }
    .promo-piece:hover {
      border-color: #0f0;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">home</a>
    <a href="chemocam.html">chemocam</a>
    <a href="crespomize.html">crespomize</a>
    <a href="jakeysnakey.html">jakeysnakey</a>
    <a href="groatesque.html">groatesque</a>
  </nav>

  <h1>chess for nolan</h1>
  <div id="board"></div>
  <div id="message">your move, nolan.</div>
  
  <div id="promotion">
    <div>choose promotion:</div>
    <div id="promo-pieces"></div>
  </div>
  
  <script>
    // chess.js-like minimal implementation
    const EMPTY = 0;
    const PAWN = 1, KNIGHT = 2, BISHOP = 3, ROOK = 4, QUEEN = 5, KING = 6;
    const WHITE = 8, BLACK = 16;
    
    const pieceChars = {
      [BLACK|ROOK]: '♜', [BLACK|KNIGHT]: '♞', [BLACK|BISHOP]: '♝', 
      [BLACK|QUEEN]: '♛', [BLACK|KING]: '♚', [BLACK|PAWN]: '♟',
      [WHITE|ROOK]: '♖', [WHITE|KNIGHT]: '♘', [WHITE|BISHOP]: '♗', 
      [WHITE|QUEEN]: '♕', [WHITE|KING]: '♔', [WHITE|PAWN]: '♙'
    };
    
    const pieceValues = {
      [PAWN]: 100, [KNIGHT]: 320, [BISHOP]: 330, 
      [ROOK]: 500, [QUEEN]: 900, [KING]: 20000
    };
    
    let board = new Uint8Array(64);
    let turn = WHITE;
    let selected = null;
    let validMoves = [];
    let gameOver = false;
    let enPassantTarget = -1;
    let pendingPromotion = null;
    
    function initBoard() {
      const setup = [
        BLACK|ROOK, BLACK|KNIGHT, BLACK|BISHOP, BLACK|QUEEN, BLACK|KING, BLACK|BISHOP, BLACK|KNIGHT, BLACK|ROOK,
        BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN, BLACK|PAWN,
        0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
        WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN, WHITE|PAWN,
        WHITE|ROOK, WHITE|KNIGHT, WHITE|BISHOP, WHITE|QUEEN, WHITE|KING, WHITE|BISHOP, WHITE|KNIGHT, WHITE|ROOK
      ];
      board.set(setup);
    }
    
    function idx(r, c) { return r * 8 + c; }
    function row(i) { return Math.floor(i / 8); }
    function col(i) { return i % 8; }
    function piece(i) { return board[i] & 7; }
    function color(i) { return board[i] & 24; }
    
    function getPseudoMoves(pos, includeEnPassant = true) {
      const moves = [];
      const p = piece(pos);
      const c = color(pos);
      const r = row(pos);
      const col_ = col(pos);
      
      if (p === PAWN) {
        const dir = c === WHITE ? -1 : 1;
        const startRow = c === WHITE ? 6 : 1;
        const nextRow = r + dir;
        
        if (nextRow >= 0 && nextRow < 8) {
          const front = idx(nextRow, col_);
          if (board[front] === EMPTY) {
            moves.push({from: pos, to: front});
            if (r === startRow) {
              const front2 = idx(r + dir * 2, col_);
              if (board[front2] === EMPTY) {
                moves.push({from: pos, to: front2, doublePush: true});
              }
            }
          }
          
          for (let dc of [-1, 1]) {
            const nc = col_ + dc;
            if (nc >= 0 && nc < 8) {
              const diag = idx(nextRow, nc);
              if (board[diag] !== EMPTY && color(diag) !== c) {
                moves.push({from: pos, to: diag});
              }
              // en passant
              if (includeEnPassant && diag === enPassantTarget) {
                moves.push({from: pos, to: diag, enPassant: true});
              }
            }
          }
        }
      } else if (p === KNIGHT) {
        const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for (let [dr, dc] of offsets) {
          const nr = r + dr, nc = col_ + dc;
          if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            const to = idx(nr, nc);
            if (color(to) !== c) moves.push({from: pos, to});
          }
        }
      } else if (p === BISHOP || p === ROOK || p === QUEEN) {
        const dirs = p === ROOK ? [[0,1],[0,-1],[1,0],[-1,0]] :
                     p === BISHOP ? [[1,1],[1,-1],[-1,1],[-1,-1]] :
                     [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
        for (let [dr, dc] of dirs) {
          let nr = r + dr, nc = col_ + dc;
          while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            const to = idx(nr, nc);
            if (board[to] === EMPTY) {
              moves.push({from: pos, to});
            } else {
              if (color(to) !== c) moves.push({from: pos, to});
              break;
            }
            nr += dr; nc += dc;
          }
        }
      } else if (p === KING) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = r + dr, nc = col_ + dc;
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
              const to = idx(nr, nc);
              if (color(to) !== c) moves.push({from: pos, to});
            }
          }
        }
      }
      
      return moves;
    }
    
    function isInCheck(c) {
      let kingPos = -1;
      for (let i = 0; i < 64; i++) {
        if (board[i] === (c | KING)) {
          kingPos = i;
          break;
        }
      }
      if (kingPos === -1) return false;
      
      for (let i = 0; i < 64; i++) {
        if (color(i) !== EMPTY && color(i) !== c) {
          const moves = getPseudoMoves(i, false);
          if (moves.some(m => m.to === kingPos)) return true;
        }
      }
      return false;
    }
    
    function getAllMoves(c) {
      const moves = [];
      for (let i = 0; i < 64; i++) {
        if (color(i) === c) {
          moves.push(...getPseudoMoves(i));
        }
      }
      
      return moves.filter(m => {
        const oldTo = board[m.to];
        const oldEp = enPassantTarget;
        
        // handle en passant capture
        let capturedPawn = -1;
        if (m.enPassant) {
          const dir = c === WHITE ? 1 : -1;
          capturedPawn = idx(row(m.to) + dir, col(m.to));
          board[capturedPawn] = EMPTY;
        }
        
        board[m.to] = board[m.from];
        board[m.from] = EMPTY;
        
        const inCheck = isInCheck(c);
        
        board[m.from] = board[m.to];
        board[m.to] = oldTo;
        enPassantTarget = oldEp;
        
        if (m.enPassant) {
          board[capturedPawn] = (c === WHITE ? BLACK : WHITE) | PAWN;
        }
        
        return !inCheck;
      });
    }
    
    function makeMove(move, promotion = QUEEN) {
      const oldEp = enPassantTarget;
      enPassantTarget = -1;
      
      // en passant capture
      if (move.enPassant) {
        const dir = color(move.from) === WHITE ? 1 : -1;
        const capturedPawn = idx(row(move.to) + dir, col(move.to));
        board[capturedPawn] = EMPTY;
      }
      
      // double pawn push - set en passant target
      if (move.doublePush) {
        const dir = color(move.from) === WHITE ? -1 : 1;
        enPassantTarget = idx(row(move.from) + dir, col(move.from));
      }
      
      board[move.to] = board[move.from];
      board[move.from] = EMPTY;
      
      // pawn promotion
      if (piece(move.to) === PAWN && (row(move.to) === 0 || row(move.to) === 7)) {
        board[move.to] = color(move.to) | promotion;
      }
      
      return oldEp;
    }
    
    function unmakeMove(move, captured, oldEp, wasPromotion = false) {
      enPassantTarget = oldEp;
      
      board[move.from] = board[move.to];
      board[move.to] = captured;
      
      // restore pawn if it was promoted
      if (wasPromotion) {
        board[move.from] = color(move.from) | PAWN;
      }
      
      // restore en passant captured pawn
      if (move.enPassant) {
        const dir = color(move.from) === WHITE ? 1 : -1;
        const capturedPawn = idx(row(move.to) + dir, col(move.to));
        board[capturedPawn] = (color(move.from) === WHITE ? BLACK : WHITE) | PAWN;
        board[move.to] = EMPTY;
      }
    }
    
    function evaluate() {
      let score = 0;
      for (let i = 0; i < 64; i++) {
        if (board[i] === EMPTY) continue;
        const val = pieceValues[piece(i)];
        score += color(i) === WHITE ? -val : val;
      }
      return score;
    }
    
    function minimax(depth, alpha, beta, maximizing) {
      if (depth === 0) return evaluate();
      
      const c = maximizing ? BLACK : WHITE;
      const moves = getAllMoves(c);
      
      if (moves.length === 0) {
        if (isInCheck(c)) return maximizing ? -50000 : 50000;
        return 0;
      }
      
      if (maximizing) {
        let maxEval = -Infinity;
        for (let m of moves) {
          const cap = board[m.to];
          const wasPromo = piece(m.from) === PAWN && (row(m.to) === 0 || row(m.to) === 7);
          const oldEp = makeMove(m, QUEEN);
          const eval_ = minimax(depth - 1, alpha, beta, false);
          unmakeMove(m, cap, oldEp, wasPromo);
          maxEval = Math.max(maxEval, eval_);
          alpha = Math.max(alpha, eval_);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (let m of moves) {
          const cap = board[m.to];
          const wasPromo = piece(m.from) === PAWN && (row(m.to) === 0 || row(m.to) === 7);
          const oldEp = makeMove(m, QUEEN);
          const eval_ = minimax(depth - 1, alpha, beta, true);
          unmakeMove(m, cap, oldEp, wasPromo);
          minEval = Math.min(minEval, eval_);
          beta = Math.min(beta, eval_);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }
    
    function findBestMove() {
      const moves = getAllMoves(BLACK);
      if (moves.length === 0) return null;
      
      let bestMove = moves[0];
      let bestEval = -Infinity;
      
      for (let m of moves) {
        const cap = board[m.to];
        const wasPromo = piece(m.from) === PAWN && (row(m.to) === 0 || row(m.to) === 7);
        const oldEp = makeMove(m, QUEEN);
        const eval_ = minimax(2, -Infinity, Infinity, false);
        unmakeMove(m, cap, oldEp, wasPromo);
        
        if (eval_ > bestEval) {
          bestEval = eval_;
          bestMove = m;
        }
      }
      
      return bestMove;
    }
    
    function render() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const sq = document.createElement('div');
          const i = idx(r, c);
          sq.className = 'square ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
          sq.textContent = pieceChars[board[i]] || '';
          
          if (selected === i) sq.classList.add('selected');
          if (validMoves.some(m => m.to === i)) sq.classList.add('highlight');
          
          sq.addEventListener('click', () => handleClick(i));
          boardEl.appendChild(sq);
        }
      }
    }
    
    function showPromotion(c, callback) {
      const promoEl = document.getElementById('promotion');
      const piecesEl = document.getElementById('promo-pieces');
      piecesEl.innerHTML = '';
      
      const pieces = [QUEEN, ROOK, BISHOP, KNIGHT];
      pieces.forEach(p => {
        const div = document.createElement('div');
        div.className = 'promo-piece';
        div.textContent = pieceChars[c | p];
        div.addEventListener('click', () => {
          promoEl.classList.remove('show');
          callback(p);
        });
        piecesEl.appendChild(div);
      });
      
      promoEl.classList.add('show');
    }
    
    function handleClick(i) {
      if (gameOver || turn !== WHITE || pendingPromotion) return;
      
      if (selected !== null) {
        const move = validMoves.find(m => m.to === i);
        if (move) {
          const isPromotion = piece(move.from) === PAWN && row(move.to) === 0;
          
          if (isPromotion) {
            pendingPromotion = move;
            showPromotion(WHITE, (promo) => {
              makeMove(pendingPromotion, promo);
              pendingPromotion = null;
              finishPlayerMove();
            });
          } else {
            makeMove(move);
            finishPlayerMove();
          }
          
          selected = null;
          validMoves = [];
        } else if (color(i) === WHITE) {
          selected = i;
          validMoves = getAllMoves(WHITE).filter(m => m.from === i);
        } else {
          selected = null;
          validMoves = [];
        }
      } else if (color(i) === WHITE) {
        selected = i;
        validMoves = getAllMoves(WHITE).filter(m => m.from === i);
      }
      
      render();
    }
    
    function finishPlayerMove() {
      if (getAllMoves(BLACK).length === 0) {
        msg(isInCheck(BLACK) ? "checkmate! you win, nolan!" : "stalemate!");
        gameOver = true;
      } else {
        turn = BLACK;
        msg("thinking...");
        render();
        setTimeout(botMove, 500);
      }
    }
    
    function botMove() {
      const move = findBestMove();
      if (!move) {
        msg(isInCheck(BLACK) ? "checkmate! you win, nolan!" : "stalemate!");
        gameOver = true;
        render();
        return;
      }
      
      makeMove(move, QUEEN);
      turn = WHITE;
      
      if (getAllMoves(WHITE).length === 0) {
        msg(isInCheck(WHITE) ? "checkmate! i win!" : "stalemate!");
        gameOver = true;
      } else {
        msg("your move, nolan.");
      }
      
      render();
    }
    
    function msg(text) {
      document.getElementById('message').textContent = text;
    }
    
    initBoard();
    render();
  </script>
</body>
</html>
