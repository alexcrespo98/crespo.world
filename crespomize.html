<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>crespomize - crespo.world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 2em;
    }
    nav {
      margin-bottom: 2em;
    }
    nav a {
      color: #0f0;
      text-decoration: none;
      margin: 0 1em;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    h1 { 
      font-size: 2.5em; 
      margin-bottom: 0.5em; 
      text-shadow: 0 0 10px #0f0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2em;
      border: 2px solid #0f0;
      background: #111;
      border-radius: 10px;
      text-align: left;
    }
    .question {
      margin: 2em 0;
      font-size: 1.2em;
    }
    button {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em 1.5em;
      margin: 0.5em;
      cursor: pointer;
      font-family: monospace;
      font-size: 1em;
      transition: all 0.3s;
    }
    button:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 15px #0f0;
    }
    select {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em;
      font-family: monospace;
      font-size: 1em;
      width: 100%;
      margin: 1em 0;
      cursor: pointer;
    }
    select option {
      background: #000;
      color: #0f0;
    }
    select option:disabled {
      color: #666;
    }
    .hidden {
      display: none;
    }
    #charts {
      margin-top: 2em;
    }
    .chart-container {
      margin: 2em 0;
      padding: 1.5em;
      border: 2px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
      position: relative;
    }
    .chart-container h3 {
      color: #0f0;
      margin-bottom: 1em;
      font-size: 1.3em;
      display: inline-block;
    }
    canvas {
      max-width: 100%;
    }
    .loading {
      font-size: 1.5em;
      margin: 2em;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1em;
      margin: 2em 0;
    }
    .stat-card {
      background: #0a0a0a;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 1.5em;
    }
    .stat-card h4 {
      margin: 0 0 0.5em 0;
      color: #0f0;
      font-size: 0.9em;
    }
    .stat-card .value {
      font-size: 1.8em;
      font-weight: bold;
      color: #0f0;
    }
    .moonmedia-option {
      font-weight: bold;
    }
    .time-range-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1em;
      margin: 1em 0;
    }
    .scale-badge {
      display: inline-block;
      background: #0f0;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .scale-badge:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .scale-badge.inactive {
      background: #333;
      color: #666;
    }
    .trendline-badge {
      display: inline-block;
      background: #ffff00;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .trendline-badge:hover {
      background: #ffdd00;
      box-shadow: 0 0 10px #ffff00;
    }
    .trendline-badge.inactive {
      background: #333;
      color: #666;
    }
    .smoothness-controls {
      display: inline-block;
      margin-left: 0.3em;
      vertical-align: middle;
    }
    .smoothness-btn {
      background: #ffff00;
      color: #000;
      border: 2px solid #ffff00;
      padding: 0.2em 0.5em;
      margin: 0 0.1em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.8em;
      font-weight: bold;
      transition: all 0.3s;
      user-select: none;
      display: inline-block;
      min-width: 30px;
    }
    .smoothness-btn:hover {
      background: #ffdd00;
      box-shadow: 0 0 5px #ffff00;
    }
    .smoothness-btn:active {
      transform: scale(0.95);
    }
    .export-btn {
      position: absolute;
      top: 1.5em;
      right: 1.5em;
      background: #0f0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.4em 0.8em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.85em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 3px;
    }
    .export-btn:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .no-data-message {
      text-align: center;
      padding: 3em;
      color: #ff0;
      font-size: 1.2em;
      border: 2px dashed #ff0;
      border-radius: 10px;
      margin: 2em 0;
      background: rgba(255, 255, 0, 0.05);
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">home</a>
    <a href="chemocam.html">chemocam</a>
    <a href="crespomize.html">crespomize</a>
  </nav>

  <h1>ðŸ“Š crespomize analytics</h1>
  
  <div class="container">
    <!-- Step 0: Platform selection -->
    <div id="step0" class="step">
      <div class="question">which platform?</div>
      <select id="platformSelect">
        <option value="" disabled selected>-- select platform --</option>
        <option value="instagram">Instagram Reels</option>
        <option value="tiktok">TikTok</option>
        <option value="youtube">YouTube Shorts</option>
      </select>
    </div>

    <!-- Step 1: Select account -->
    <div id="step1" class="step hidden">
      <div class="question">pick a company:</div>
      <select id="accountSelect">
        <option value="" disabled selected>-- select an account --</option>
      </select>
    </div>

    <!-- Step 2: Time range selection -->
    <div id="step2" class="step hidden">
      <div class="question">select time range for analysis:</div>
      <div class="time-range-buttons">
        <button onclick="app.selectTimeRange('all')">ðŸ“… All Time</button>
        <button onclick="app.selectTimeRange(365)">ðŸ“† 1 Year</button>
        <button onclick="app.selectTimeRange(180)">ðŸ“† 6 Months</button>
        <button onclick="app.selectTimeRange(30)">ðŸ“† 1 Month</button>
      </div>
    </div>

    <!-- Charts display -->
    <div id="charts" class="hidden">
      <div class="question">ðŸ“ˆ analytics for @<span id="accountName"></span> <span id="timeRangeLabel"></span></div>
      
      <!-- Summary stats -->
      <div class="stats-summary" id="statsSummary"></div>
      
      <!-- Charts -->
      <div id="chartsList"></div>
      <br>
      <button onclick="location.reload()">start over</button>
    </div>

    <div id="loading" class="loading hidden">loading data...</div>
  </div>

  <script>
    // Application state
    const app = {
      // Configuration
      SHEET_IDS: {
        tiktok: '1FUGfhPVsVi1WOOw88BKfUKueJh4eMPj1',
        instagram: '19PDIP7_YaluxsmvQsDJ89Bn5JkXnK2n2',
        youtube: 'YOUR_YOUTUBE_SHEET_ID_HERE' // Placeholder for YouTube Shorts
      },
      
      // State variables
      selectedPlatform: '',
      workbookData: null,
      selectedAccount: '',
      accountData: {},
      isMoonMediaTotal: false,
      selectedTimeRange: 'all',
      chartInstances: {},
      trendlineStates: {},
      trendlineDaysAverage: {},
      
      // Initialize the application
      init() {
        this.setupEventListeners();
      },
      
      // Setup all event listeners
      setupEventListeners() {
        document.getElementById('platformSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectPlatform(e.target.value);
          }
        });
        
        document.getElementById('accountSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectAccount(e.target.value);
          }
        });
      },
      
      // Platform selection
      selectPlatform(platform) {
        this.selectedPlatform = platform;
        document.getElementById('step0').classList.add('hidden');
        document.getElementById('step1').classList.remove('hidden');
        this.loadSheetData();
      },
      
      // Account selection
      selectAccount(account) {
        this.selectedAccount = account;
        this.isMoonMediaTotal = (account === 'MOONMEDIA_TOTAL');
        document.getElementById('step1').classList.add('hidden');
        document.getElementById('step2').classList.remove('hidden');
      },
      
      // Time range selection
      selectTimeRange(days) {
        this.selectedTimeRange = days;
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        
        setTimeout(() => {
          this.processData(days);
          document.getElementById('loading').classList.add('hidden');
          document.getElementById('charts').classList.remove('hidden');
          
          // Update UI labels
          document.getElementById('accountName').textContent = 
            this.isMoonMediaTotal ? 'All MoonMedia' : this.selectedAccount;
          
          let rangeText = '';
          if (days === 'all') rangeText = '(All Time)';
          else if (days === 365) rangeText = '(Last 1 Year)';
          else if (days === 180) rangeText = '(Last 6 Months)';
          else if (days === 30) rangeText = '(Last 1 Month)';
          document.getElementById('timeRangeLabel').textContent = rangeText;
          
          this.renderDashboard();
        }, 1000);
      },
      
      // Load sheet data
      async loadSheetData() {
        const accountSelect = document.getElementById('accountSelect');
        
        // Handle YouTube Shorts placeholder
        if (this.selectedPlatform === 'youtube') {
          accountSelect.innerHTML = 
            '<option value="" disabled selected>-- select an account --</option>' +
            '<option value="DEMO">Demo YouTube Account (Coming Soon)</option>';
          return;
        }
        
        try {
          accountSelect.innerHTML = '<option value="" disabled>loading accounts...</option>';
          
          const sheetId = this.SHEET_IDS[this.selectedPlatform];
          const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=xlsx`;
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          
          this.workbookData = XLSX.read(arrayBuffer, { type: 'array' });
          
          const accounts = this.workbookData.SheetNames;
          
          if (accounts.length === 0) {
            accountSelect.innerHTML = '<option>no accounts found</option>';
            return;
          }
          
          accountSelect.innerHTML = 
            '<option value="" disabled selected>-- select an account --</option>' +
            '<option value="MOONMEDIA_TOTAL" class="moonmedia-option">ðŸŒ™ All MoonMedia Analytics</option>' +
            accounts.map(acc => `<option value="${acc}">@${acc}</option>`).join('');
          
          console.log('âœ… Loaded accounts:', accounts);
          
        } catch (error) {
          console.error('Error loading data:', error);
          accountSelect.innerHTML = '<option>error loading - check file permissions</option>';
        }
      },
      
      // Process data based on platform and account
      processData(timeRangeDays) {
        // Handle YouTube demo
        if (this.selectedPlatform === 'youtube') {
          this.accountData = this.generateYouTubeDemoData(timeRangeDays);
          return;
        }
        
        if (this.isMoonMediaTotal) {
          this.accountData = this.parseMoonMediaTotal(timeRangeDays);
        } else {
          this.accountData = this.parseAccountData(this.selectedAccount, timeRangeDays);
        }
      },
      
      // Generate demo data for YouTube Shorts
      generateYouTubeDemoData(timeRangeDays) {
        const now = new Date();
        const daysToGenerate = timeRangeDays === 'all' ? 365 : timeRangeDays;
        const videos = [];
        const followersHistory = [];
        const totalLikesHistory = [];
        
        // Generate synthetic data
        let baseFollowers = 50000;
        let baseLikes = 100000;
        
        for (let i = daysToGenerate; i >= 0; i -= 7) {
          const date = new Date(now);
          date.setDate(date.getDate() - i);
          
          // Followers growth
          baseFollowers += Math.floor(Math.random() * 5000) + 1000;
          followersHistory.push({
            date: new Date(date),
            value: baseFollowers
          });
          
          // Likes growth
          baseLikes += Math.floor(Math.random() * 10000) + 2000;
          totalLikesHistory.push({
            date: new Date(date),
            value: baseLikes
          });
          
          // Generate 2-3 videos per week
          const videosThisWeek = Math.floor(Math.random() * 2) + 1;
          for (let v = 0; v < videosThisWeek; v++) {
            const videoDate = new Date(date);
            videoDate.setDate(videoDate.getDate() + Math.floor(Math.random() * 7));
            
            const views = Math.floor(Math.random() * 500000) + 10000;
            const likes = Math.floor(views * (Math.random() * 0.1 + 0.05));
            const comments = Math.floor(likes * (Math.random() * 0.05 + 0.01));
            
            videos.push({
              date: videoDate,
              views: views,
              likes: likes,
              comments: comments,
              shares: Math.floor(likes * 0.1),
              engagement: ((likes + comments) / views * 100)
            });
          }
        }
        
        videos.sort((a, b) => a.date - b.date);
        
        return {
          followers: baseFollowers,
          totalLikes: baseLikes,
          postsScraped: videos.length,
          videos: videos,
          followersHistory: followersHistory,
          totalLikesHistory: totalLikesHistory,
          platform: 'youtube'
        };
      },
      
      // Parse account data
      parseAccountData(sheetName, timeRangeDays = 'all') {
        if (this.selectedPlatform === 'instagram') {
          return this.parseInstagramData(sheetName, timeRangeDays);
        } else if (this.selectedPlatform === 'tiktok') {
          return this.parseTikTokData(sheetName, timeRangeDays);
        }
      },
      
      // Parse TikTok data
      parseTikTokData(sheetName, timeRangeDays) {
        const sheet = this.workbookData.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        let followers = null;
        let totalLikes = null;
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            followers = followersHistory.length > 0 ? 
              followersHistory[followersHistory.length - 1].value : 0;
              
          } else if (rowName === 'total_likes') {
            totalLikesHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            totalLikes = totalLikesHistory.length > 0 ? 
              totalLikesHistory[totalLikesHistory.length - 1].value : 0;
              
          } else if (rowName.startsWith('post_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            if (metric === 'Date') {
              allUniqueVideoIds.add(videoId);
            }
            
            for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
              const cellValue = row[colIdx];
              
              if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                if (!allVideosMap.has(videoId)) {
                  allVideosMap.set(videoId, { id: videoId });
                }
                
                const video = allVideosMap.get(videoId);
                if (video[metric] === undefined) {
                  video[metric] = cellValue;
                }
                break;
              }
            }
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          const dateObj = new Date(v.Date);
          
          if (!this.isValidDate(dateObj)) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: parseInt(v.Shares) || 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: parseInt(followers) || 0,
          totalLikes: parseInt(totalLikes) || 0,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => item.value > 0)
        };
      },
      
      // Parse Instagram data
      parseInstagramData(sheetName, timeRangeDays) {
        const sheet = this.workbookData.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        let followers = null;
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            followers = followersHistory.length > 0 ? 
              followersHistory[followersHistory.length - 1].value : 0;
              
          } else if (rowName.startsWith('reel_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            const metricMapping = {
              'date': 'Date',
              'views': 'Views',
              'likes': 'Likes',
              'comments': 'Comments',
              'engagement': 'EngagementRate'
            };
            
            const mappedMetric = metricMapping[metric];
            
            if (metric === 'date') {
              allUniqueVideoIds.add(videoId);
            }
            
            if (metric === 'date_display') continue;
            
            if (mappedMetric) {
              for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                const cellValue = row[colIdx];
                
                if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  
                  const video = allVideosMap.get(videoId);
                  if (video[mappedMetric] === undefined) {
                    video[mappedMetric] = cellValue;
                  }
                  break;
                }
              }
            }
          }
        }
        
        // Calculate total likes history
        for (let colIdx = 0; colIdx < headers.length; colIdx++) {
          let columnTotalLikes = 0;
          
          for (let i = 1; i < jsonData.length; i++) {
            const row = jsonData[i];
            const rowName = row[0];
            
            if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_likes')) {
              const value = parseInt(row[colIdx + 1]) || 0;
              columnTotalLikes += value;
            }
          }
          
          if (columnTotalLikes > 0) {
            totalLikesHistory.push({
              date: new Date(headers[colIdx]),
              value: columnTotalLikes
            });
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          const dateObj = new Date(v.Date);
          
          if (!this.isValidDate(dateObj)) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        return {
          followers: parseInt(followers) || 0,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => this.isValidDate(item.date) && item.value > 0)
        };
      },
      
      // Parse all MoonMedia accounts combined
      parseMoonMediaTotal(timeRangeDays) {
        const accounts = this.workbookData.SheetNames;
        let totalFollowers = 0;
        let totalLikes = 0;
        let totalPosts = 0;
        let allVideos = [];
        
        let followersByTimestamp = {};
        let likesByTimestamp = {};
        
        accounts.forEach(sheetName => {
          const data = this.parseAccountData(sheetName, timeRangeDays);
          totalFollowers += data.followers;
          totalLikes += data.totalLikes;
          totalPosts += data.postsScraped;
          allVideos = allVideos.concat(data.videos);
          
          data.followersHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!followersByTimestamp[dateKey]) {
              followersByTimestamp[dateKey] = { 
                date: item.date, 
                total: 0, 
                accountCount: 0 
              };
            }
            followersByTimestamp[dateKey].total += item.value;
            followersByTimestamp[dateKey].accountCount += 1;
          });
          
          data.totalLikesHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!likesByTimestamp[dateKey]) {
              likesByTimestamp[dateKey] = { 
                date: item.date, 
                total: 0, 
                accountCount: 0 
              };
            }
            likesByTimestamp[dateKey].total += item.value;
            likesByTimestamp[dateKey].accountCount += 1;
          });
        });
        
        const totalAccountCount = accounts.length;
        
        const followersHistory = Object.values(followersByTimestamp)
          .filter(item => item.accountCount === totalAccountCount)
          .map(item => ({ date: item.date, value: item.total }))
          .filter(item => this.isValidDate(item.date) && item.value > 0)
          .sort((a, b) => a.date - b.date);
        
        const totalLikesHistory = Object.values(likesByTimestamp)
          .filter(item => item.accountCount === totalAccountCount)
          .map(item => ({ date: item.date, value: item.total }))
          .filter(item => this.isValidDate(item.date) && item.value > 0)
          .sort((a, b) => a.date - b.date);
        
        allVideos.sort((a, b) => a.date - b.date);
        
        let totalViews = allVideos.reduce((sum, v) => sum + v.views, 0);
        let viewsPerSecond = 0;
        
        const last100Posts = allVideos.slice(-100);
        if (last100Posts.length >= 2) {
          const oldestPost = last100Posts[0];
          const newestPost = last100Posts[last100Posts.length - 1];
          const totalViewsInPeriod = last100Posts.reduce((sum, v) => sum + v.views, 0);
          const timeSpanSeconds = (newestPost.date - oldestPost.date) / 1000;
          
          if (timeSpanSeconds > 0) {
            viewsPerSecond = totalViewsInPeriod / timeSpanSeconds;
          }
        }
        
        return {
          followers: totalFollowers,
          totalLikes: totalLikes,
          postsScraped: totalPosts,
          videos: allVideos,
          followersHistory: followersHistory,
          totalLikesHistory: totalLikesHistory,
          totalViews: totalViews,
          viewsPerSecond: viewsPerSecond,
          accountCount: accounts.length
        };
      },
      
      // Utility functions
      isValidDate(date) {
        if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
          return false;
        }
        const year = date.getFullYear();
        const currentYear = new Date().getFullYear();
        return year >= 2020 && year <= currentYear + 1;
      },
      
      filterDataByTimeRange(videos, timeRangeDays) {
        if (timeRangeDays === 'all') return videos;
        
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - timeRangeDays);
        
        return videos.filter(v => v.date >= cutoffDate);
      },
      
      interpolateHistoricalData(historyArray) {
        if (historyArray.length === 0) return historyArray;
        
        const interpolated = historyArray.map((item, idx) => ({
          ...item,
          index: idx,
          needsInterp: item.value === 0 || item.value === null || item.value === undefined
        }));
        
        let i = 0;
        while (i < interpolated.length) {
          if (!interpolated[i].needsInterp) {
            i++;
            continue;
          }
          
          let groupStart = i;
          let groupEnd = i;
          while (groupEnd < interpolated.length && interpolated[groupEnd].needsInterp) {
            groupEnd++;
          }
          groupEnd--;
          
          let prevValue = null;
          for (let j = groupStart - 1; j >= 0; j--) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              prevValue = interpolated[j].value;
              break;
            }
          }
          
          let nextValue = null;
          for (let j = groupEnd + 1; j < interpolated.length; j++) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              nextValue = interpolated[j].value;
              break;
            }
          }
          
          if (prevValue !== null && nextValue !== null) {
            const groupSize = groupEnd - groupStart + 1;
            const totalSteps = groupSize + 1;
            
            for (let j = groupStart; j <= groupEnd; j++) {
              const stepNumber = j - groupStart + 1;
              const interpolatedValue = prevValue + ((nextValue - prevValue) * stepNumber / totalSteps);
              interpolated[j].value = Math.round(interpolatedValue);
            }
          } else if (prevValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = prevValue;
            }
          } else if (nextValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = nextValue;
            }
          }
          
          i = groupEnd + 1;
        }
        
        return interpolated.map(item => ({
          date: item.date,
          value: item.value
        }));
      },
      
      shouldUseLogScale(data) {
        if (data.length === 0) return false;
        
        const values = data.filter(v => v > 0);
        if (values.length === 0) return false;
        
        const max = Math.max(...values);
        const min = Math.min(...values);
        const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
        
        const ratio = max / min;
        const medianRatio = max / median;
        
        return ratio > 100 || medianRatio > 10;
      },
      
      formatNumber(num) {
        if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
        if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        return num.toLocaleString();
      },
      
      formatNumberAxisSmart(value, dataRange) {
        const range = dataRange.max - dataRange.min;
        
        if (value >= 1000000000) {
          const val = value / 1000000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'B';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'B';
          return val.toFixed(1) + 'B';
        }
        if (value >= 1000000) {
          const val = value / 1000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'M';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'M';
          return val.toFixed(1) + 'M';
        }
        if (value >= 1000) {
          const val = value / 1000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(2) + 'K';
          return val.toFixed(1) + 'K';
        }
        return value.toLocaleString();
      },
      
      calculateMovingAverageByDays(data, days = 7) {
        const result = [];
        const halfWindow = Math.floor(days / 2);
        
        for (let i = 0; i < data.length; i++) {
          const currentDate = new Date(data[i].x);
          const startDate = new Date(currentDate);
          const endDate = new Date(currentDate);
          
          startDate.setDate(startDate.getDate() - halfWindow);
          endDate.setDate(endDate.getDate() + (days - halfWindow));
          
          const windowPoints = [];
          for (let j = 0; j < data.length; j++) {
            const pointDate = new Date(data[j].x);
            if (pointDate >= startDate && pointDate <= endDate) {
              windowPoints.push(data[j].y);
            }
          }
          
          if (windowPoints.length > 0) {
            const sum = windowPoints.reduce((acc, val) => acc + val, 0);
            const avg = sum / windowPoints.length;
            result.push({ x: data[i].x, y: avg });
          } else {
            result.push({ x: data[i].x, y: data[i].y });
          }
        }
        
        return result;
      },
      
      // Chart manipulation functions
      toggleLogScale(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const currentType = chart.options.scales.y.type;
        const newType = currentType === 'logarithmic' ? 'linear' : 'logarithmic';
        
        chart.options.scales.y.type = newType;
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.type = newType;
        }
        
        if (chartId === 'correlation' && chart.options.scales.x) {
          chart.options.scales.x.type = newType;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-chart-id="${chartId}"]`);
        if (badge) {
          if (newType === 'logarithmic') {
            badge.classList.remove('inactive');
            badge.textContent = 'LOG SCALE';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'LINEAR';
          }
        }
      },
      
      toggleTrendline(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        this.trendlineStates[chartId] = !this.trendlineStates[chartId];
        const showTrendline = this.trendlineStates[chartId];
        
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset) {
          trendlineDataset.hidden = !showTrendline;
        }
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.display = showTrendline;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-trendline-id="${chartId}"]`);
        if (badge) {
          if (showTrendline) {
            badge.classList.remove('inactive');
            badge.textContent = 'ðŸ“ˆ TREND ON';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'ðŸ“ˆ TREND OFF';
          }
        }
        
        const controls = document.querySelector(`[data-smoothness-controls="${chartId}"]`);
        if (controls) {
          controls.style.display = showTrendline ? 'inline-block' : 'none';
        }
      },
      
      adjustTrendlineSmoothness(chartId, direction) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        if (this.trendlineDaysAverage[chartId] === undefined) {
          this.trendlineDaysAverage[chartId] = 7;
        }
        
        this.trendlineDaysAverage[chartId] += direction;
        this.trendlineDaysAverage[chartId] = Math.max(1, this.trendlineDaysAverage[chartId]);
        
        const dataDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
        if (!dataDataset) return;
        
        const trendlineData = this.calculateMovingAverageByDays(
          dataDataset.data, 
          this.trendlineDaysAverage[chartId]
        );
        
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset) {
          trendlineDataset.data = trendlineData;
        }
        
        chart.update();
        
        const display = document.querySelector(`[data-days-display="${chartId}"]`);
        if (display) {
          display.textContent = this.trendlineDaysAverage[chartId];
        }
      },
      
      exportChart(chartId, title) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const canvas = chart.canvas;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + 80;
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCtx.fillStyle = '#000000';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        tempCtx.fillStyle = '#ffffff';
        tempCtx.font = 'bold 24px monospace';
        tempCtx.textAlign = 'center';
        tempCtx.fillText(title, tempCanvas.width / 2, 35);
        
        tempCtx.font = '16px monospace';
        const accountText = this.isMoonMediaTotal ? 'All MoonMedia' : '@' + this.selectedAccount;
        let rangeText = '';
        if (this.selectedTimeRange === 'all') rangeText = '(All Time)';
        else if (this.selectedTimeRange === 365) rangeText = '(Last 1 Year)';
        else if (this.selectedTimeRange === 180) rangeText = '(Last 6 Months)';
        else if (this.selectedTimeRange === 30) rangeText = '(Last 1 Month)';
        
        tempCtx.fillText(`${accountText} ${rangeText}`, tempCanvas.width / 2, 60);
        
        tempCtx.drawImage(canvas, 0, 80);
        
        const link = document.createElement('a');
        link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${accountText.replace('@', '')}_${this.selectedPlatform}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      },
      
      // Chart creation functions
      createLineChart(container, title, historyData, datasets, useLog, chartId) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'ðŸ’¾ Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allValues = datasets.flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'day',
                  displayFormats: { day: 'MMM d, yyyy' }
                },
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLog ? 'logarithmic' : 'linear',
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRange);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      createTimeBasedChart(container, title, videos, datasets, useLog, chartId, includeTrendline = false) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        if (includeTrendline) {
          const trendlineBadge = document.createElement('span');
          trendlineBadge.className = 'trendline-badge inactive';
          trendlineBadge.textContent = 'ðŸ“ˆ TREND OFF';
          trendlineBadge.setAttribute('data-trendline-id', chartId);
          trendlineBadge.onclick = () => this.toggleTrendline(chartId);
          header.appendChild(trendlineBadge);
          
          this.trendlineStates[chartId] = false;
          this.trendlineDaysAverage[chartId] = 7;
          
          const smoothnessControls = document.createElement('span');
          smoothnessControls.className = 'smoothness-controls';
          smoothnessControls.setAttribute('data-smoothness-controls', chartId);
          smoothnessControls.style.display = 'none';
          
          const downBtn = document.createElement('button');
          downBtn.className = 'smoothness-btn';
          downBtn.textContent = 'â—„';
          downBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, -1);
          
          const daysDisplay = document.createElement('span');
          daysDisplay.className = 'smoothness-btn';
          daysDisplay.textContent = '7';
          daysDisplay.style.cursor = 'default';
          daysDisplay.setAttribute('data-days-display', chartId);
          
          const upBtn = document.createElement('button');
          upBtn.className = 'smoothness-btn';
          upBtn.textContent = 'â–º';
          upBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, 1);
          
          smoothnessControls.appendChild(downBtn);
          smoothnessControls.appendChild(daysDisplay);
          smoothnessControls.appendChild(upBtn);
          
          header.appendChild(smoothnessControls);
        }
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'ðŸ’¾ Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        // Ensure scatter plot is behind trendline
        datasets[0].order = 1;
        
        if (includeTrendline && datasets.length > 0) {
          const trendlineData = this.calculateMovingAverageByDays(datasets[0].data, 7);
          
          datasets.push({
            label: 'Trend',
            data: trendlineData,
            type: 'line',
            borderColor: '#ffff00',
            backgroundColor: 'transparent',
            borderWidth: 3,
            pointRadius: 0,
            tension: 0.4,
            yAxisID: 'y1',
            hidden: true,
            order: -1  // Trendline on top
          });
        }
        
        const allValues = datasets.filter(ds => ds.label !== 'Trend')
          .flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        const scales = {
          x: {
            type: 'time',
            time: {
              unit: 'day',
              displayFormats: { day: 'MMM d, yyyy' }
            },
            ticks: { color: '#0f0', font: { family: 'monospace' } },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          },
          y: {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'left',
            ticks: {
              color: '#0f0',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          }
        };
        
        if (includeTrendline) {
          scales.y1 = {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'right',
            display: false,
            ticks: {
              color: '#ffff00',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: {
              drawOnChartArea: false
            }
          };
        }
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: datasets[0].type || 'scatter',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 },
                  filter: (item) => {
                    if (item.text === 'Trend') {
                      return this.trendlineStates[chartId] === true;
                    }
                    return true;
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: scales
          }
        });
      },
      
      createCorrelationChart(container) {
        const correlationValues = this.accountData.videos.map(v => v.views);
        const useLogCorrelation = this.shouldUseLogScale(correlationValues);
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'correlation';
        
        const header = document.createElement('h3');
        header.textContent = 'Likes vs Views Correlation';
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLogCorrelation ? '' : ' inactive');
        scaleBadge.textContent = useLogCorrelation ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', 'correlation');
        scaleBadge.onclick = () => this.toggleLogScale('correlation');
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'ðŸ’¾ Export';
        exportBtn.onclick = () => this.exportChart('correlation', 'Likes vs Views Correlation');
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allViews = this.accountData.videos.map(v => v.views).filter(v => v > 0);
        const allLikes = this.accountData.videos.map(v => v.likes).filter(v => v > 0);
        const dataRangeX = {
          min: Math.min(...allViews),
          max: Math.max(...allViews)
        };
        const dataRangeY = {
          min: Math.min(...allLikes),
          max: Math.max(...allLikes)
        };
        
        this.chartInstances['correlation'] = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [{
              label: 'Posts',
              data: this.accountData.videos.map(v => ({ x: v.views, y: v.likes })),
              backgroundColor: 'rgba(0, 210, 211, 0.6)',
              borderColor: '#00d2d3',
              pointRadius: 6,
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return 'Views: ' + this.formatNumber(context.parsed.x) + 
                           ', Likes: ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Views',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeX);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Likes',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeY);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Main dashboard rendering
      renderDashboard() {
        // Reset chart instances
        this.chartInstances = {};
        this.trendlineStates = {};
        this.trendlineDaysAverage = {};
        
        const statsContainer = document.getElementById('statsSummary');
        const chartsContainer = document.getElementById('chartsList');
        chartsContainer.innerHTML = '';
        
        // Handle YouTube demo message
        if (this.accountData.platform === 'youtube') {
          chartsContainer.innerHTML = `
            <div class="no-data-message">
              âš ï¸ YouTube Shorts Analytics Coming Soon!<br><br>
              This is demo data to preview the analytics interface.<br>
              Real YouTube data integration will be available once you add your YouTube Shorts sheet ID.
            </div>
          `;
        }
        
        // Determine content type based on platform
        let contentType = 'POSTS';
        if (this.selectedPlatform === 'instagram') contentType = 'REELS';
        else if (this.selectedPlatform === 'youtube') contentType = 'SHORTS';
        
        // Render summary statistics
        let statsHTML = `
          <div class="stat-card">
            <h4>ðŸ‘¥ FOLLOWERS</h4>
            <div class="value">${this.formatNumber(this.accountData.followers)}</div>
          </div>
          <div class="stat-card">
            <h4>â¤ï¸ TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(this.accountData.totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>ðŸŽ¬ ${contentType} TRACKED</h4>
            <div class="value">${this.accountData.postsScraped}</div>
          </div>
          <div class="stat-card">
            <h4>ðŸ“ˆ 

AVG ENGAGEMENT</h4>
            <div class="value">${this.accountData.videos.length > 0 ? 
              (this.accountData.videos.reduce((sum, v) => sum + v.engagement, 0) / 
               this.accountData.videos.length).toFixed(2) : 0}%</div>
          </div>
        `;
        
        if (this.isMoonMediaTotal) {
          statsHTML += `
            <div class="stat-card">
              <h4>ðŸ‘ï¸ TOTAL VIEWS</h4>
              <div class="value">${this.formatNumber(this.accountData.totalViews)}</div>
            </div>
            <div class="stat-card">
              <h4>âš¡ VIEWS PER SECOND</h4>
              <div class="value">${this.accountData.viewsPerSecond.toFixed(2)}</div>
            </div>
            <div class="stat-card">
              <h4>ðŸ¢ TOTAL ACCOUNTS</h4>
              <div class="value">${this.accountData.accountCount}</div>
            </div>
          `;
        }
        
        statsContainer.innerHTML = statsHTML;
        
        // Create charts
        if (this.accountData.followersHistory && this.accountData.followersHistory.length > 0) {
          const followerValues = this.accountData.followersHistory.map(h => h.value);
          const useLogFollowers = this.shouldUseLogScale(followerValues);
          
          this.createLineChart(chartsContainer, 'ðŸ‘¥ Followers Growth', 
            this.accountData.followersHistory,
            [{
              label: 'Followers',
              data: this.accountData.followersHistory.map(h => ({ x: h.date, y: h.value })),
              borderColor: '#9b59b6',
              backgroundColor: 'rgba(155, 89, 182, 0.1)',
              borderWidth: 3,
              tension: 0.4,
              fill: true
            }],
            useLogFollowers,
            'followers-history'
          );
        }
        
        if (this.accountData.totalLikesHistory && this.accountData.totalLikesHistory.length > 0) {
          const likesHistoryValues = this.accountData.totalLikesHistory.map(h => h.value);
          const useLogLikesHistory = this.shouldUseLogScale(likesHistoryValues);
          
          this.createLineChart(chartsContainer, 'â¤ï¸ Total Likes Growth',
            this.accountData.totalLikesHistory,
            [{
              label: 'Total Likes',
              data: this.accountData.totalLikesHistory.map(h => ({ x: h.date, y: h.value })),
              borderColor: '#e91e63',
              backgroundColor: 'rgba(233, 30, 99, 0.1)',
              borderWidth: 3,
              tension: 0.4,
              fill: true
            }],
            useLogLikesHistory,
            'likes-history'
          );
        }
        
        if (this.accountData.videos.length > 0) {
          const viewsData = this.accountData.videos.map(v => v.views);
          const likesData = this.accountData.videos.map(v => v.likes);
          const useLogViews = this.shouldUseLogScale(viewsData);
          const useLogLikes = this.shouldUseLogScale(likesData);
          
          this.createTimeBasedChart(chartsContainer, 'Views Over Time',
            this.accountData.videos,
            [{
              label: 'Views',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.views })),
              borderColor: '#00d2d3',
              backgroundColor: 'rgba(0, 210, 211, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogViews,
            'views-time',
            true
          );
          
          this.createTimeBasedChart(chartsContainer, 'Likes Over Time',
            this.accountData.videos,
            [{
              label: 'Likes',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.likes })),
              borderColor: '#ff6b6b',
              backgroundColor: 'rgba(255, 107, 107, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogLikes,
            'likes-time',
            true
          );
          
          this.createTimeBasedChart(chartsContainer, 'Engagement Rate Over Time',
            this.accountData.videos,
            [{
              label: 'Engagement %',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.engagement })),
              borderColor: '#2ecc71',
              backgroundColor: 'rgba(46, 204, 113, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            false,
            'engagement-time',
            true
          );
          
          const commentsData = this.accountData.videos.map(v => v.comments);
          const useLogComments = this.shouldUseLogScale(commentsData);
          
          this.createTimeBasedChart(chartsContainer, 'Comments Over Time',
            this.accountData.videos,
            [{
              label: 'Comments',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.comments })),
              borderColor: '#1abc9c',
              backgroundColor: 'rgba(26, 188, 156, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogComments,
            'comments-time',
            true
          );
          
          if (this.selectedPlatform === 'tiktok') {
            const sharesData = this.accountData.videos.map(v => v.shares);
            const useLogShares = this.shouldUseLogScale(sharesData);
            
            this.createTimeBasedChart(chartsContainer, 'Shares Over Time',
              this.accountData.videos,
              [{
                label: 'Shares',
                data: this.accountData.videos.map(v => ({ x: v.date, y: v.shares })),
                borderColor: '#e74c3c',
                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                pointRadius: 4,
                pointHoverRadius: 6
              }],
              useLogShares,
              'shares-time',
              true
            );
          }
          
          // Create correlation chart
          this.createCorrelationChart(chartsContainer);
        }
      }
    };
    
    // Initialize the app when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
