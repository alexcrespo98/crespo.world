<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>crespomize - crespo.world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 2em;
    }
    nav {
      margin-bottom: 2em;
    }
    nav a {
      color: #0f0;
      text-decoration: none;
      margin: 0 1em;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    h1 { 
      font-size: 2.5em; 
      margin-bottom: 0.5em; 
      text-shadow: 0 0 10px #0f0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2em;
      border: 2px solid #0f0;
      background: #111;
      border-radius: 10px;
      text-align: left;
    }
    .question {
      margin: 2em 0;
      font-size: 1.2em;
    }
    button {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em 1.5em;
      margin: 0.5em;
      cursor: pointer;
      font-family: monospace;
      font-size: 1em;
      transition: all 0.3s;
    }
    button:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 15px #0f0;
    }
    select {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em;
      font-family: monospace;
      font-size: 1em;
      width: 100%;
      margin: 1em 0;
      cursor: pointer;
    }
    select option {
      background: #000;
      color: #0f0;
    }
    select option:disabled {
      color: #666;
    }
    .hidden {
      display: none;
    }
    #charts {
      margin-top: 2em;
    }
    .chart-container {
      margin: 2em 0;
      padding: 1.5em;
      border: 2px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
      position: relative;
    }
    .chart-container h3 {
      color: #0f0;
      margin-bottom: 1em;
      font-size: 1.3em;
      display: inline-block;
    }
    canvas {
      max-width: 100%;
    }
    .loading {
      font-size: 1.5em;
      margin: 2em;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1em;
      margin: 2em 0;
    }
    .stat-card {
      background: #0a0a0a;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 1.5em;
    }
    .stat-card h4 {
      margin: 0 0 0.5em 0;
      color: #0f0;
      font-size: 0.9em;
    }
    .stat-card .value {
      font-size: 1.8em;
      font-weight: bold;
      color: #0f0;
    }
    .moonmedia-option {
      font-weight: bold;
      color: #ffff00;
    }
    .time-range-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1em;
      margin: 1em 0;
    }
    .time-range-buttons button.active {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 15px #0f0;
    }
    .custom-date-slider-container {
      margin: 2em 0 1em 0;
      padding: 1.5em;
      border: 1px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
    }
    .custom-date-slider-label {
      margin-bottom: 1em;
      color: #0f0;
      font-size: 0.9em;
    }
    .dual-slider-wrapper {
      position: relative;
      height: 40px;
      margin: 1em 0;
    }
    .slider-track {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
    }
    .slider-range {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      height: 6px;
      background: #0f0;
      border-radius: 3px;
    }
    .range-input {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 6px;
      background: none;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
    }
    .range-input::-webkit-slider-thumb {
      pointer-events: all;
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #0f0;
      border: 3px solid #000;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #0f0;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .range-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px #0f0;
    }
    .range-input::-moz-range-thumb {
      pointer-events: all;
      width: 20px;
      height: 20px;
      background: #0f0;
      border: 3px solid #000;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #0f0;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .range-input::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px #0f0;
    }
    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5em;
      font-size: 0.85em;
      color: #0f0;
    }
    .slider-date-display {
      text-align: center;
      margin-top: 1em;
      font-size: 1em;
      color: #0f0;
      background: #000;
      padding: 0.5em 1em;
      border: 1px solid #0f0;
      border-radius: 3px;
      display: inline-block;
    }
    .slider-apply-btn {
      margin-top: 1em;
      background: #0f0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.6em 1.5em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.9em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 3px;
    }
    .slider-apply-btn:hover {
      background: #00ff7f;
      box-shadow: 0 0 15px #0f0;
    }
    .scale-badge {
      display: inline-block;
      background: #0f0;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .scale-badge:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .scale-badge.inactive {
      background: #333;
      color: #666;
    }
    .trendline-badge {
      display: inline-block;
      background: #ffff00;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .trendline-badge:hover {
      background: #ffdd00;
      box-shadow: 0 0 10px #ffff00;
    }
    .trendline-badge.inactive {
      background: #333;
      color: #666;
    }
    .mode-toggle-badge {
      display: inline-block;
      background: #00d2d3;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .mode-toggle-badge:hover {
      background: #00e5e6;
      box-shadow: 0 0 10px #00d2d3;
    }
    .mode-toggle-badge.cumulative {
      background: #ff6b6b;
    }
    .mode-toggle-badge.cumulative:hover {
      background: #ff8080;
      box-shadow: 0 0 10px #ff6b6b;
    }
    .smoothness-controls {
      display: inline-block;
      margin-left: 0.3em;
      vertical-align: middle;
    }
    .smoothness-btn {
      background: #ffff00;
      color: #000;
      border: 2px solid #ffff00;
      padding: 0.2em 0.5em;
      margin: 0 0.1em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.8em;
      font-weight: bold;
      transition: all 0.3s;
      user-select: none;
      display: inline-block;
      min-width: 30px;
    }
    .smoothness-btn:hover {
      background: #ffdd00;
      box-shadow: 0 0 5px #ffff00;
    }
    .smoothness-btn:active {
      transform: scale(0.95);
    }
    .export-btn {
      position: absolute;
      top: 1.5em;
      right: 1.5em;
      background: #0f0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.4em 0.8em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.85em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 3px;
    }
    .export-btn:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .looks-good-btn {
      background: #00ff00;
      color: #000;
      border: 3px solid #00ff00;
      padding: 1em 2em;
      cursor: pointer;
      font-family: monospace;
      font-size: 1.2em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 8px;
      text-transform: uppercase;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
    }
    .looks-good-btn:hover {
      background: #00d2d3;
      border-color: #00d2d3;
      box-shadow: 0 0 25px rgba(0, 210, 211, 0.5);
      transform: scale(1.05);
    }
    .export-section {
      margin-top: 2em;
      padding: 1.5em;
      border: 2px solid #0f0;
      border-radius: 10px;
      background: rgba(0, 255, 0, 0.05);
    }
    .no-data-message {
      text-align: center;
      padding: 3em;
      color: #ff0;
      font-size: 1.2em;
      border: 2px dashed #ff0;
      border-radius: 10px;
      margin: 2em 0;
      background: rgba(255, 255, 0, 0.05);
    }
    .platform-stats {
      background: #0a0a0a;
      border: 2px solid #ffff00;
      border-radius: 10px;
      padding: 1.5em;
      margin: 1.5em 0;
    }
    .platform-stats h3 {
      color: #ffff00;
      margin-bottom: 1em;
    }
    .monthly-tabs-container {
      margin: 2em 0 1em 0;
      border-bottom: 2px solid #0f0;
    }
    .monthly-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0;
      margin-bottom: -2px;
    }
    .monthly-tab {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      border-bottom: none;
      padding: 0.8em 1.5em;
      margin: 0;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.9em;
      transition: all 0.3s;
      border-radius: 5px 5px 0 0;
    }
    .monthly-tab:hover {
      background: #0a3a0a;
    }
    .monthly-tab.active {
      background: #0f0;
      color: #000;
      font-weight: bold;
    }
    #monthlyTabContent {
      padding-top: 1em;
    }
    
    /* Style Selector */
    .style-selector {
      position: absolute;
      top: 1em;
      right: 1em;
      z-index: 100;
      background: #0a0a0a;
      border: 1px solid #0f0;
      border-radius: 5px;
      padding: 0.5em;
    }
    .style-selector label {
      color: #0f0;
      font-size: 0.8em;
      margin-right: 0.5em;
    }
    .style-selector label.secondary {
      margin-left: 1em;
    }
    .style-selector select {
      background: #000;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 0.3em;
      font-family: monospace;
      font-size: 0.8em;
      width: auto;
      margin: 0;
      cursor: pointer;
    }
    
    /* Donut Chart Containers */
    .donut-charts-section {
      margin: 2em 0;
      padding: 1.5em;
      border: 2px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
    }
    .donut-charts-section h3 {
      color: #0f0;
      margin: 0 0 1em 0;
      text-align: center;
    }
    .donut-charts-grid {
      display: grid;
      gap: 2em;
      margin-bottom: 2em;
    }
    .donut-chart-container {
      background: #000;
      border: 1px solid #0f0;
      border-radius: 5px;
      padding: 1.5em;
      text-align: center;
    }
    .donut-chart-container h4 {
      color: #0f0;
      margin: 0 0 1em 0;
      font-size: 1em;
    }
    .donut-chart-wrapper {
      max-width: 400px;
      margin: 0 auto;
      position: relative;
    }
    
    /* Style variations */
    .monthly-reports-style-1 .donut-charts-grid {
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }
    .monthly-reports-style-2 .donut-charts-grid {
      grid-template-columns: 1fr;
      max-width: 600px;
      margin: 0 auto 2em auto;
    }
    .monthly-reports-style-3 .donut-charts-grid {
      grid-template-columns: repeat(2, 1fr);
    }
    .monthly-reports-style-4 .donut-charts-grid {
      grid-template-columns: repeat(3, 1fr);
    }
    .monthly-reports-style-2 .stat-card h4 {
      font-size: 1em;
    }
    .monthly-reports-style-2 .stat-card .value {
      font-size: 2em;
    }
    .monthly-reports-style-3 .stat-card h4 {
      font-size: 0.85em;
    }
    .monthly-reports-style-3 .stat-card .value {
      font-size: 1.6em;
    }
    .monthly-reports-style-4 .stats-summary {
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    
    /* Style 5: Dark Mode Enhanced - Similar to compact but with different color scheme */
    .monthly-reports-style-5 .donut-charts-grid {
      grid-template-columns: repeat(3, 1fr);
    }
    .monthly-reports-style-5 .stats-summary {
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    .monthly-reports-style-5 .stat-card {
      background: #0a0a0a;
      border-color: #00aa00;
    }
    .monthly-reports-style-5 .stat-card h4 {
      color: #00ff88;
    }
    .monthly-reports-style-5 .donut-chart-container h4 {
      color: #00ff88;
    }
    
    /* Style 6: Minimal - Extra spacing, cleaner look */
    .monthly-reports-style-6 .donut-charts-grid {
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 3em;
    }
    .monthly-reports-style-6 .stats-summary {
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 2em;
      margin-bottom: 3em;
    }
    .monthly-reports-style-6 .stat-card {
      padding: 2em;
    }
    .monthly-reports-style-6 .donut-chart-container {
      padding: 2em;
    }
    
    /* Style 7: Dense - Even more compact than compact */
    .monthly-reports-style-7 .donut-charts-grid {
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5em;
    }
    .monthly-reports-style-7 .stats-summary {
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.5em;
    }
    .monthly-reports-style-7 .stat-card {
      padding: 0.5em;
    }
    .monthly-reports-style-7 .stat-card h4 {
      font-size: 0.7em;
      margin-bottom: 0.3em;
    }
    .monthly-reports-style-7 .stat-card .value {
      font-size: 1.2em;
    }
    .monthly-reports-style-7 .donut-chart-container {
      padding: 0.5em;
    }
    .monthly-reports-style-7 .donut-chart-container h4 {
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">home</a>
    <a href="officecam.html">officecam</a>
    <a href="crespomize.html">crespomize</a>
    <a href="recipeasy.html">recipeasy</a>
  </nav>

  <h1>crespomize analytics</h1>
  
  <div class="container">
    <!-- Step 0: Analytics Type Selection -->
    <div id="step0" class="step">
      <div class="question">what type of analytics?</div>
      <select id="analyticsTypeSelect">
        <option value="" disabled selected>-- select analytics type --</option>
        <option value="easy" disabled style="display: none;">Weekly Analytics (this week's progress)</option>
        <option value="monthly">Monthly Reports</option>
        <option value="custom">Custom Analytics</option>
      </select>
    </div>

    <!-- Easy Graphs Section (now Weekly Analytics) -->
    <div id="easyGraphsSection" class="step hidden">
      <div class="question">select week for analytics:</div>
      <select id="monthSelect">
        <option value="" disabled selected>-- select week --</option>
      </select>
      <div id="easyGraphsContainer" class="hidden">
        <div class="question" id="easyGraphsTitle"></div>
        <div class="stats-summary" id="easyStatsSummary"></div>
        <div id="easyChartsList"></div>
        <div class="export-section" style="text-align: center; margin-top: 2em;">
          <div style="margin-bottom: 1em;">
            <button id="looksGoodBtn" class="looks-good-btn" onclick="app.exportClientReport()">
              âœ“ Export All MoonMedia PDF
            </button>
          </div>
          <div style="margin-top: 1em;">
            <label style="color: #0f0; margin-right: 1em;">Export Individual Client Report:</label>
            <select id="exportAccountSelect" style="background: #000; color: #0f0; border: 1px solid #0f0; padding: 0.5em;">
              <option value="">-- select account --</option>
            </select>
            <button onclick="app.exportIndividualClientReport()" style="margin-left: 1em; background: #000; color: #0f0; border: 1px solid #0f0; padding: 0.5em 1em; cursor: pointer;">
              Export Client PDF
            </button>
          </div>
        </div>
        <br>
        <button onclick="location.reload()">start over</button>
      </div>
    </div>

    <!-- Monthly Analytics Section -->
    <div id="monthlyGraphsSection" class="step hidden">
      <div class="question">select month for analytics:</div>
      <select id="monthlyMonthSelect">
        <option value="" disabled selected>-- select month --</option>
      </select>
      <div id="monthlyGraphsContainer" class="hidden monthly-reports-style-4">
        
        <div class="question" id="monthlyGraphsTitle"></div>
        
        <!-- Tab Navigation -->
        <div class="monthly-tabs-container">
          <div class="monthly-tabs">
            <button class="monthly-tab" data-tab="total" onclick="app.switchMonthlyTab('total')">Total Moon Media</button>
            <button class="monthly-tab" data-tab="popdartsgame" onclick="app.switchMonthlyTab('popdartsgame')">popdartsgame</button>
            <button class="monthly-tab" data-tab="bucketgolfgame" onclick="app.switchMonthlyTab('bucketgolfgame')">bucketgolfgame</button>
            <button class="monthly-tab" data-tab="playbattlegolf" onclick="app.switchMonthlyTab('playbattlegolf')">playbattlegolf</button>
            <button class="monthly-tab" data-tab="flinggolf" onclick="app.switchMonthlyTab('flinggolf')">flinggolf</button>
            <button class="monthly-tab" data-tab="golfponggames" onclick="app.switchMonthlyTab('golfponggames')">golfponggames</button>
            <button class="monthly-tab" data-tab="discgogames" onclick="app.switchMonthlyTab('discgogames')">discgogames</button>
            <button class="monthly-tab" data-tab="lowtidegolf" onclick="app.switchMonthlyTab('lowtidegolf')">lowtidegolf</button>
          </div>
        </div>
        
        <!-- Tab Content -->
        <div id="monthlyTabContent">
          <div class="stats-summary" id="monthlyStatsSummary"></div>
          <div id="monthlyChartsList"></div>
        </div>
        
        <div class="export-section" style="text-align: center; margin-top: 2em;">
          <div style="margin-bottom: 1em;">
            <button id="monthlyExportBtn" class="looks-good-btn" onclick="app.exportMonthlyReport()">
              Export Monthly Report PDF
            </button>
          </div>
        </div>
        <br>
        <button onclick="location.reload()">start over</button>
      </div>
    </div>

    <!-- Custom Analytics: Platform selection -->
    <div id="step0Custom" class="step hidden">
      <div class="question">which platform?</div>
      <select id="platformSelect">
        <option value="" disabled selected>-- select platform --</option>
        <option value="all" class="moonmedia-option">All MoonMedia Platforms</option>
        <option value="instagram">Instagram Reels</option>
        <option value="tiktok">TikTok</option>
        <option value="youtube">YouTube Shorts</option>
      </select>
    </div>

    <!-- Step 1: Select account (for single platform) -->
    <div id="step1" class="step hidden">
      <div class="question">pick a company:</div>
      <select id="accountSelect">
        <option value="" disabled selected>-- select an account --</option>
      </select>
    </div>

    <!-- Step 2: Time range selection -->
    <div id="step2" class="step hidden">
      <div class="question">select time range for analysis:</div>
      <div class="time-range-buttons" id="timeRangeButtons">
        <button id="btn-all" onclick="app.selectPresetTimeRange('all')">All Time</button>
        <button id="btn-365" onclick="app.selectPresetTimeRange(365)">1 Year</button>
        <button id="btn-180" onclick="app.selectPresetTimeRange(180)">6 Months</button>
        <button id="btn-30" onclick="app.selectPresetTimeRange(30)">1 Month</button>
      </div>
      
      <!-- Custom Date Range Slider -->
      <div class="custom-date-slider-container" id="customDateSliderContainer">
        <div class="custom-date-slider-label">or choose a custom date range:</div>
        <div class="dual-slider-wrapper">
          <div class="slider-track"></div>
          <div class="slider-range" id="sliderRange"></div>
          <input type="range" class="range-input" id="rangeMin" min="0" max="100" value="0">
          <input type="range" class="range-input" id="rangeMax" min="0" max="100" value="100">
        </div>
        <div class="slider-labels">
          <span id="minDateLabel">--</span>
          <span id="maxDateLabel">--</span>
        </div>
        <div style="text-align: center;">
          <div class="slider-date-display">
            <span id="selectedStartDate">--</span> to <span id="selectedEndDate">--</span>
          </div>
          <br>
          <button class="slider-apply-btn" onclick="app.applyCustomDateRange()">Apply Custom Range</button>
        </div>
      </div>
    </div>

    <!-- Charts display -->
    <div id="charts" class="hidden">
      <div class="question">analytics for <span id="accountName"></span> <span id="timeRangeLabel"></span></div>
      
      <!-- Summary stats -->
      <div class="stats-summary" id="statsSummary"></div>
      
      <!-- Platform breakdown for "All MoonMedia" -->
      <div id="platformBreakdown" class="hidden"></div>
      
      <!-- Charts -->
      <div id="chartsList"></div>
      <br>
      <button onclick="location.reload()">start over</button>
    </div>

    <div id="loading" class="loading hidden">loading data...</div>
  </div>

  <script>
    // Register Chart.js plugins
    Chart.register(ChartDataLabels);
    
    // Application state
    const app = {
      // Configuration
      SHEET_IDS: {
        tiktok: '1FUGfhPVsVi1WOOw88BKfUKueJh4eMPj1',
        instagram: '19PDIP7_YaluxsmvQsDJ89Bn5JkXnK2n2',
        youtube: '1yRLZpJLdaB9oPZtjcwIeJx-6q8lGF2dO'
      },
      
      // Explicit account mapping across platforms
      // Maps a canonical name to the actual account names on each platform
      // Update these if account names differ between platforms
      // Set to null if an account doesn't exist on a platform
      ACCOUNT_MAPPING: {
        'popdartsgame': { instagram: 'popdartsgame', tiktok: 'popdartsgame', youtube: 'popdartsgame' },
        'bucketgolfgame': { instagram: 'bucketgolfgame', tiktok: 'bucketgolfgame', youtube: 'bucketgolfgame' },
        'playbattlegolf': { instagram: 'playbattlegolf', tiktok: 'playbattlegolf', youtube: 'playbattlegolf' },
        'flinggolf': { instagram: 'flinggolf', tiktok: 'flinggolf', youtube: 'flinggolf' },
        'golfponggames': { instagram: 'golfpong.games', tiktok: 'golfponggames', youtube: 'golfponggames' },
        'discgogames': { instagram: 'discgogames', tiktok: 'discgogames', youtube: 'discgogames' },
        'lowtidegolf': { instagram: 'low_tide_golf', tiktok: 'lowtidegolf', youtube: null }  // No YouTube
      },
      
      // Anomaly detection thresholds
      ANOMALY_THRESHOLDS: {
        LIKES_VIEWS_RATIO: 0.05,     // Reject if likes within 5% of views (extraction error)
        MIN_LIKES_RATIO: 0.001,       // Reject if likes < 0.1% of views (implausibly low)
        SIGNIFICANT_VIEWS: 5000       // Views threshold for applying ratio checks
      },
      
      // Weekly calculation constants
      WEEKLY_CALC: {
        MS_PER_WEEK: 7 * 24 * 60 * 60 * 1000,
        RECENT_WEEKS_LOOKBACK: 4,     // Include incremental views from posts within this many weeks
        WEEKLY_DECAY_FACTOR: 0.15     // Estimated portion of views gained per week for recent posts
      },
      
      // Debug mode - set to true to see matching logs in console
      DEBUG_MODE: false,
      
      // Debug logging helper
      debugLog(...args) {
        if (this.DEBUG_MODE) {
          console.log(...args);
        }
      },
      
      // Smoothness constants for exponential smoothing
      SMOOTHNESS: {
        MIN_LEVEL: 1,
        MAX_LEVEL: 10,
        DEFAULT_LEVEL: 5,
        MAX_ALPHA: 0.5,    // Most responsive (smoothness level 1)
        MIN_ALPHA: 0.05,   // Smoothest (smoothness level 10)
        ALPHA_RANGE: 0.45  // MAX_ALPHA - MIN_ALPHA
      },
      
      // State variables
      selectedPlatform: '',
      workbookData: null,
      selectedAccount: '',
      accountData: {},
      isMoonMediaTotal: false,
      isAllPlatforms: false,
      selectedTimeRange: 'all',
      chartInstances: {},
      trendlineStates: {},
      trendlineDaysAverage: {},
      trendlineSmoothnessLevel: {},
      chartModeStates: {},
      chartMetricKeys: {},
      allPlatformsData: {},
      allVideosUnfiltered: [],
      
      // Easy graphs state
      easyGraphsData: {},
      currentEasyGraphsMonth: null,
      currentEasyGraphsYear: null,
      
      // Monthly analytics state
      currentMonthlyMonth: null,
      currentMonthlyYear: null,
      currentMonthlyStartDate: null,
      currentMonthlyEndDate: null,
      currentMonthlyAccountStats: [],
      donutLabelStyle: 'background', // Fixed to background style
      
      // Custom date range slider state
      dataDateRange: { min: null, max: null },
      customDateRange: { start: null, end: null },
      
      // Initialize the application
      init() {
        this.setupEventListeners();
        this.setupSliderListeners();
      },
      
      // Setup slider event listeners
      setupSliderListeners() {
        const rangeMin = document.getElementById('rangeMin');
        const rangeMax = document.getElementById('rangeMax');
        
        rangeMin.addEventListener('input', () => this.updateSlider());
        rangeMax.addEventListener('input', () => this.updateSlider());
      },
      
      // Update the slider UI
      updateSlider() {
        const rangeMin = document.getElementById('rangeMin');
        const rangeMax = document.getElementById('rangeMax');
        const sliderRange = document.getElementById('sliderRange');
        
        let minVal = parseInt(rangeMin.value);
        let maxVal = parseInt(rangeMax.value);
        
        // Prevent handles from crossing and ensure values are within bounds
        if (minVal > maxVal - 1) {
          if (this.lastChanged === 'min') {
            minVal = Math.min(maxVal - 1, 99);
            minVal = Math.max(minVal, 0);
            rangeMin.value = minVal;
          } else {
            maxVal = Math.min(minVal + 1, 100);
            maxVal = Math.max(maxVal, 1);
            rangeMax.value = maxVal;
          }
        }
        
        this.lastChanged = (document.activeElement === rangeMin) ? 'min' : 'max';
        
        // Update the range highlight
        const percent1 = minVal;
        const percent2 = maxVal;
        sliderRange.style.left = percent1 + '%';
        sliderRange.style.width = (percent2 - percent1) + '%';
        
        // Calculate and display dates
        if (this.dataDateRange.min && this.dataDateRange.max) {
          const totalDays = Math.floor((this.dataDateRange.max - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          
          const startDays = Math.floor(totalDays * (minVal / 100));
          const endDays = Math.floor(totalDays * (maxVal / 100));
          
          const startDate = new Date(this.dataDateRange.min);
          startDate.setDate(startDate.getDate() + startDays);
          
          const endDate = new Date(this.dataDateRange.min);
          endDate.setDate(endDate.getDate() + endDays);
          
          this.customDateRange.start = startDate;
          this.customDateRange.end = endDate;
          
          document.getElementById('selectedStartDate').textContent = this.formatDate(startDate);
          document.getElementById('selectedEndDate').textContent = this.formatDate(endDate);
        }
        
        // Clear active state from preset buttons
        document.querySelectorAll('#timeRangeButtons button').forEach(btn => {
          btn.classList.remove('active');
        });
      },
      
      // Format date for display
      formatDate(date) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      },
      
      // Initialize slider with data range
      initializeSliderWithData(minDate = null, maxDate = null) {
        // Use provided dates or fallback to defaults
        const now = new Date();
        let actualMin = minDate;
        let actualMax = maxDate || now;
        
        // If no min date provided, use a reasonable default (10 years back)
        if (!actualMin) {
          actualMin = new Date();
          actualMin.setFullYear(actualMin.getFullYear() - 10);
        }
        
        this.dataDateRange.min = actualMin;
        this.dataDateRange.max = actualMax;
        
        document.getElementById('minDateLabel').textContent = this.formatDate(actualMin);
        document.getElementById('maxDateLabel').textContent = this.formatDate(actualMax);
        
        // Initialize slider to full range
        document.getElementById('rangeMin').value = 0;
        document.getElementById('rangeMax').value = 100;
        
        this.customDateRange.start = actualMin;
        this.customDateRange.end = actualMax;
        
        document.getElementById('selectedStartDate').textContent = this.formatDate(actualMin);
        document.getElementById('selectedEndDate').textContent = this.formatDate(actualMax);
        
        // Update slider range highlight
        const sliderRange = document.getElementById('sliderRange');
        sliderRange.style.left = '0%';
        sliderRange.style.width = '100%';
      },
      
      // Update slider range with actual data dates
      updateSliderWithDataRange(videos, totalLikesHistory = [], followersHistory = []) {
        let minDate = null;
        let maxDate = null;
        
        // Extract dates from videos
        if (videos && videos.length > 0) {
          const videoDates = videos.filter(v => v.date && this.isValidDate(v.date)).map(v => v.date);
          if (videoDates.length > 0) {
            minDate = new Date(Math.min(...videoDates.map(d => d.getTime())));
            maxDate = new Date(Math.max(...videoDates.map(d => d.getTime())));
          }
        }
        
        // Also consider totalLikesHistory dates (may go back further)
        if (totalLikesHistory && totalLikesHistory.length > 0) {
          const historyDates = totalLikesHistory.filter(h => h.date && this.isValidDate(h.date)).map(h => h.date);
          if (historyDates.length > 0) {
            const historyMin = new Date(Math.min(...historyDates.map(d => d.getTime())));
            const historyMax = new Date(Math.max(...historyDates.map(d => d.getTime())));
            if (!minDate || historyMin < minDate) minDate = historyMin;
            if (!maxDate || historyMax > maxDate) maxDate = historyMax;
          }
        }
        
        // Also consider followersHistory dates
        if (followersHistory && followersHistory.length > 0) {
          const historyDates = followersHistory.filter(h => h.date && this.isValidDate(h.date)).map(h => h.date);
          if (historyDates.length > 0) {
            const historyMin = new Date(Math.min(...historyDates.map(d => d.getTime())));
            const historyMax = new Date(Math.max(...historyDates.map(d => d.getTime())));
            if (!minDate || historyMin < minDate) minDate = historyMin;
            if (!maxDate || historyMax > maxDate) maxDate = historyMax;
          }
        }
        
        // If we found valid dates, update the slider
        if (minDate && maxDate) {
          this.initializeSliderWithData(minDate, maxDate);
        }
      },
        
      
      // Select preset time range (from button click)
      selectPresetTimeRange(days) {
        // Update active button state
        document.querySelectorAll('#timeRangeButtons button').forEach(btn => {
          btn.classList.remove('active');
        });
        
        const btnId = days === 'all' ? 'btn-all' : `btn-${days}`;
        document.getElementById(btnId).classList.add('active');
        
        // Update slider to match preset
        if (this.dataDateRange.min && this.dataDateRange.max) {
          const now = new Date();
          let startDate;
          
          if (days === 'all') {
            startDate = this.dataDateRange.min;
          } else {
            // Create a new date by subtracting milliseconds (more robust than setDate)
            const daysInMs = days * 24 * 60 * 60 * 1000;
            startDate = new Date(now.getTime() - daysInMs);
            if (startDate < this.dataDateRange.min) {
              startDate = this.dataDateRange.min;
            }
          }
          
          const totalDays = Math.floor((this.dataDateRange.max - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          const startDays = Math.floor((startDate - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          
          const minPercent = totalDays > 0 ? Math.round((startDays / totalDays) * 100) : 0;
          const maxPercent = 100;
          
          document.getElementById('rangeMin').value = minPercent;
          document.getElementById('rangeMax').value = maxPercent;
          
          this.customDateRange.start = startDate;
          this.customDateRange.end = now;
          
          document.getElementById('selectedStartDate').textContent = this.formatDate(startDate);
          document.getElementById('selectedEndDate').textContent = this.formatDate(now);
          
          const sliderRange = document.getElementById('sliderRange');
          sliderRange.style.left = minPercent + '%';
          sliderRange.style.width = (maxPercent - minPercent) + '%';
        }
        
        // Apply the selection
        this.selectTimeRange(days);
      },
      
      // Apply custom date range
      applyCustomDateRange() {
        if (!this.customDateRange.start || !this.customDateRange.end) {
          return;
        }
        
        // Calculate days from start to end
        const daysDiff = Math.floor((this.customDateRange.end - this.customDateRange.start) / (1000 * 60 * 60 * 24));
        
        // Store custom range for filtering
        this.selectedTimeRange = 'custom';
        this.customStartDate = this.customDateRange.start;
        this.customEndDate = this.customDateRange.end;
        
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        
        if (this.isAllPlatforms) {
          this.loadAllPlatformsData('custom');
        } else {
          setTimeout(() => {
            this.processData('custom');
            this.finalizeDataDisplay('custom');
          }, 1000);
        }
      },
      
      // Setup all event listeners
      setupEventListeners() {
        // Analytics type selection (new first step)
        document.getElementById('analyticsTypeSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectAnalyticsType(e.target.value);
          }
        });
        
        // Platform selection (for custom analytics)
        document.getElementById('platformSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectPlatform(e.target.value);
          }
        });
        
        document.getElementById('accountSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectAccount(e.target.value);
          }
        });
        
        // Month selection (for easy graphs)
        document.getElementById('monthSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectMonthForEasyGraphs(e.target.value);
          }
        });
        
        // Month selection (for monthly analytics)
        document.getElementById('monthlyMonthSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectMonthForMonthlyAnalytics(e.target.value);
          }
        });
      },
      
      // Analytics type selection
      selectAnalyticsType(type) {
        document.getElementById('step0').classList.add('hidden');
        
        if (type === 'easy') {
          this.initializeEasyGraphsMode();
        } else if (type === 'monthly') {
          this.initializeMonthlyGraphsMode();
        } else if (type === 'custom') {
          document.getElementById('step0Custom').classList.remove('hidden');
        }
      },
      
      // Initialize Easy Graphs mode
      async initializeEasyGraphsMode() {
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('loading').textContent = 'loading data...';
        
        // Load all platforms data first
        await this.loadAllPlatformsDataForEasyGraphs();
        
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('easyGraphsSection').classList.remove('hidden');
        
        // Populate month dropdown
        this.populateMonthDropdown();
      },
      
      // Load all platforms data for easy graphs
      async loadAllPlatformsDataForEasyGraphs() {
        this.easyGraphsData = {
          instagram: null,
          tiktok: null,
          youtube: null
        };
        
        // Load Instagram data
        try {
          const igResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.instagram}/export?format=xlsx`);
          const igBuffer = await igResponse.arrayBuffer();
          this.easyGraphsData.instagramWorkbook = XLSX.read(igBuffer, { type: 'array' });
          this.easyGraphsData.instagram = this.processWorkbookData(this.easyGraphsData.instagramWorkbook, 'instagram', 'all');
        } catch (error) {
          console.error('Error loading Instagram data:', error);
        }
        
        // Load TikTok data
        try {
          const ttResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.tiktok}/export?format=xlsx`);
          const ttBuffer = await ttResponse.arrayBuffer();
          this.easyGraphsData.tiktokWorkbook = XLSX.read(ttBuffer, { type: 'array' });
          this.easyGraphsData.tiktok = this.processWorkbookData(this.easyGraphsData.tiktokWorkbook, 'tiktok', 'all');
        } catch (error) {
          console.error('Error loading TikTok data:', error);
        }
        
        // Load YouTube data
        try {
          const ytResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.youtube}/export?format=xlsx`);
          const ytBuffer = await ytResponse.arrayBuffer();
          this.easyGraphsData.youtubeWorkbook = XLSX.read(ytBuffer, { type: 'array' });
          this.easyGraphsData.youtube = this.processWorkbookData(this.easyGraphsData.youtubeWorkbook, 'youtube', 'all');
        } catch (error) {
          console.error('Error loading YouTube data:', error);
        }
      },
      
      // Initialize Monthly Graphs mode
      async initializeMonthlyGraphsMode() {
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('loading').textContent = 'loading data...';
        
        // Reuse the same data loading function as easy graphs
        await this.loadAllPlatformsDataForEasyGraphs();
        
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('monthlyGraphsSection').classList.remove('hidden');
        
        // Populate month dropdown with monthly options
        this.populateMonthlyDropdown();
      },
      
      // Populate month dropdown with December 2025 as default
      // At the start of each month, the previous month becomes available
      populateMonthlyDropdown() {
        const monthlySelect = document.getElementById('monthlyMonthSelect');
        monthlySelect.innerHTML = '<option value="" disabled selected>-- select month --</option>';
        
        const now = new Date();
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                            'July', 'August', 'September', 'October', 'November', 'December'];
        
        // Calculate the last completed month (previous month from current date)
        const lastCompletedMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        
        // Add completed months starting from the most recent
        // For now (January 2026), this will show December 2025
        // In February 2026, it will show January 2026 and December 2025, etc.
        let monthsToShow = 1; // Start with just showing the last completed month
        
        // If we're past January, show more historical months (up to 12 months back)
        if (now.getMonth() > 0 || now.getFullYear() > 2026) {
          // Calculate how many months since December 2025
          const monthsSinceDecember2025 = (now.getFullYear() - 2025) * 12 + (now.getMonth() - 11);
          monthsToShow = Math.min(monthsSinceDecember2025, 12); // Cap at 12 months
        }
        
        for (let i = 0; i < monthsToShow; i++) {
          const monthDate = new Date(lastCompletedMonth);
          monthDate.setMonth(lastCompletedMonth.getMonth() - i);
          
          const year = monthDate.getFullYear();
          const month = monthDate.getMonth();
          const value = `${year}-${String(month + 1).padStart(2, '0')}-01`; // YYYY-MM-01 format
          
          const label = `${monthNames[month]} ${year}`;
          
          const option = document.createElement('option');
          option.value = value;
          option.textContent = label;
          monthlySelect.appendChild(option);
        }
      },
      
      // Select month for monthly analytics
      async selectMonthForMonthlyAnalytics(monthStartValue) {
        // Parse the month start date (YYYY-MM-01)
        const monthStart = new Date(monthStartValue + 'T00:00:00');
        
        // Calculate month end (last day of the month)
        const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);
        monthEnd.setHours(23, 59, 59, 999);
        
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                            'July', 'August', 'September', 'October', 'November', 'December'];
        const monthLabel = `${monthNames[monthStart.getMonth()]} ${monthStart.getFullYear()}`;
        
        // Show loading
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('loading').textContent = 'generating monthly analytics...';
        
        // Store current month for all tabs
        this.currentMonthlyMonth = monthLabel;
        this.currentMonthlyYear = monthStart.getFullYear();
        this.currentMonthlyStartDate = monthStart;
        this.currentMonthlyEndDate = monthEnd;
        
        // Calculate stats for all clients once
        const matchedAccounts = this.matchAccountsAcrossPlatforms();
        this.currentMonthlyAccountStats = [];
        
        matchedAccounts.forEach(account => {
          const stats = {
            name: account.name,
            instagram: account.instagram ? this.getAccountMonthlyStats('instagram', account.instagram, monthStart, monthEnd) : null,
            tiktok: account.tiktok ? this.getAccountMonthlyStats('tiktok', account.tiktok, monthStart, monthEnd) : null,
            youtube: account.youtube ? this.getAccountMonthlyStats('youtube', account.youtube, monthStart, monthEnd) : null
          };
          this.currentMonthlyAccountStats.push(stats);
        });
        
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('monthlyGraphsContainer').classList.remove('hidden');
        document.getElementById('monthlyGraphsTitle').textContent = `Monthly Reports: ${monthLabel}`;
        
        // Set fixed compact style with background labels
        const container = document.getElementById('monthlyGraphsContainer');
        container.classList.add('monthly-reports-style-4');
        this.donutLabelStyle = 'background';
        
        // Switch to default tab (Total Moon Media)
        this.switchMonthlyTab('total');
      },
      
      // Switch between monthly analytics tabs
      switchMonthlyTab(tabName) {
        // Update tab button states
        const tabs = document.querySelectorAll('.monthly-tab');
        tabs.forEach(tab => {
          if (tab.getAttribute('data-tab') === tabName) {
            tab.classList.add('active');
          } else {
            tab.classList.remove('active');
          }
        });
        
        // Clear existing content
        const statsContainer = document.getElementById('monthlyStatsSummary');
        const chartsContainer = document.getElementById('monthlyChartsList');
        statsContainer.innerHTML = '';
        chartsContainer.innerHTML = '';
        
        // Reset chart instances
        this.chartInstances = {};
        
        // Render content based on tab
        if (tabName === 'total') {
          this.renderTotalMoonMediaMonthlyView();
        } else {
          this.renderClientMonthlyView(tabName);
        }
      },
      
      // Render Total Moon Media monthly view (aggregate all clients)
      renderTotalMoonMediaMonthlyView() {
        const statsContainer = document.getElementById('monthlyStatsSummary');
        const chartsContainer = document.getElementById('monthlyChartsList');
        
        // Filter to only the 7 clients from ACCOUNT_MAPPING
        const clientNames = Object.keys(this.ACCOUNT_MAPPING);
        const clientStats = this.currentMonthlyAccountStats.filter(stat => 
          clientNames.includes(stat.name)
        );
        
        // Aggregate metrics across all clients and platforms
        let totalFollowersStart = 0;
        let totalFollowersEnd = 0;
        let totalLikes = 0;
        let totalViews = 0;
        let totalComments = 0;
        let totalShares = 0;
        let platformFollowers = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformFollowersStart = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformFollowersChange = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformLikes = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformViews = { instagram: 0, tiktok: 0, youtube: 0 };
        let combinedFollowerData = { instagram: [], tiktok: [], youtube: [] };
        let totalVideoDuration = 0; // For average views/second calculation
        
        clientStats.forEach(client => {
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (client[platform]) {
              const followersStart = client[platform].followersStart || 0;
              const followersEnd = client[platform].followersEnd || 0;
              totalFollowersStart += followersStart;
              totalFollowersEnd += followersEnd;
              platformFollowers[platform] += followersEnd;
              platformFollowersStart[platform] += followersStart;
              platformFollowersChange[platform] += (followersEnd - followersStart);
              
              // Aggregate engagement metrics from month videos
              if (client[platform].monthVideos) {
                client[platform].monthVideos.forEach(video => {
                  const likes = video.likes || 0;
                  const views = video.views || 0;
                  const comments = video.comments || 0;
                  const shares = video.shares || 0;
                  const duration = video.duration || 0;
                  
                  totalLikes += likes;
                  totalViews += views;
                  totalComments += comments;
                  totalShares += shares;
                  totalVideoDuration += duration;
                  
                  platformLikes[platform] += likes;
                  platformViews[platform] += views;
                });
              }
              
              // Collect follower history data for combined chart
              // Sum follower counts across all clients for each date
              if (client[platform].dailyFollowerData && client[platform].dailyFollowerData.length > 0) {
                client[platform].dailyFollowerData.forEach(dataPoint => {
                  const dateKey = dataPoint.date.toISOString().split('T')[0];
                  // Find if we already have data for this date
                  const existingIndex = combinedFollowerData[platform].findIndex(
                    d => d.date.toISOString().split('T')[0] === dateKey
                  );
                  
                  if (existingIndex >= 0) {
                    // Add to existing follower count for this date
                    combinedFollowerData[platform][existingIndex].followers += dataPoint.followers;
                  } else {
                    // First entry for this date, create a new one
                    combinedFollowerData[platform].push({
                      date: dataPoint.date,
                      followers: dataPoint.followers
                    });
                  }
                });
              }
            }
          });
        });
        
        // Sort the combined follower data by date for each platform
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          if (combinedFollowerData[platform].length > 0) {
            combinedFollowerData[platform].sort((a, b) => a.date - b.date);
          }
        });
        
        // Calculate follower change and average views/second
        const followerChange = totalFollowersEnd - totalFollowersStart;
        const secondsInMonth = (this.currentMonthlyEndDate - this.currentMonthlyStartDate) / 1000;
        const avgViewsPerSecond = secondsInMonth > 0 ? (totalViews / secondsInMonth).toFixed(2) : 0;
        const changePrefix = followerChange >= 0 ? '+' : '';
        const changeColor = followerChange >= 0 ? '#00ff00' : '#ff0000';
        
        // Display summary statistics
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>TOTAL FOLLOWERS</h4>
            <div class="value">
              ${this.formatNumber(totalFollowersEnd)} <span style="color: ${changeColor}; font-size: 0.7em;">(${changePrefix}${this.formatNumber(followerChange)})</span>
            </div>
          </div>
          <div class="stat-card">
            <h4>AVERAGE VIEWS/SECOND</h4>
            <div class="value">${avgViewsPerSecond}</div>
          </div>
        `;
        
        // Create donut charts for Total Moon Media
        this.createTotalDonutCharts(chartsContainer, {
          platformFollowers,
          platformFollowersChange,
          platformLikes,
          platformViews,
          totalComments,
          totalShares,
          followerChange
        });
        
        // Create normalized follower growth chart
        this.createNormalizedFollowerGrowthChart(
          chartsContainer,
          'Total Moon Media Follower Growth',
          combinedFollowerData,
          this.currentMonthlyStartDate,
          this.currentMonthlyEndDate,
          'total-follower-growth'
        );
      },
      
      // Render individual client monthly view
      renderClientMonthlyView(clientName) {
        const statsContainer = document.getElementById('monthlyStatsSummary');
        const chartsContainer = document.getElementById('monthlyChartsList');
        
        // Find the client stats
        const clientStats = this.currentMonthlyAccountStats.find(stat => stat.name === clientName);
        
        if (!clientStats) {
          statsContainer.innerHTML = '<div class="no-data-message">No data available for this client</div>';
          return;
        }
        
        // Aggregate metrics for this client
        let totalFollowersStart = 0;
        let totalFollowersEnd = 0;
        let totalLikes = 0;
        let totalViews = 0;
        let totalComments = 0;
        let totalShares = 0;
        let platformFollowers = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformFollowersStart = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformFollowersChange = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformLikes = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformViews = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformComments = { instagram: 0, tiktok: 0, youtube: 0 };
        let platformShares = { instagram: 0, tiktok: 0, youtube: 0 };
        let combinedFollowerData = { instagram: [], tiktok: [], youtube: [] };
        let totalVideoDuration = 0; // For average views/second calculation
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          if (clientStats[platform]) {
            const followersStart = clientStats[platform].followersStart || 0;
            const followersEnd = clientStats[platform].followersEnd || 0;
            totalFollowersStart += followersStart;
            totalFollowersEnd += followersEnd;
            platformFollowers[platform] = followersEnd;
            platformFollowersStart[platform] = followersStart;
            platformFollowersChange[platform] = followersEnd - followersStart;
            
            // Aggregate engagement metrics from month videos
            if (clientStats[platform].monthVideos) {
              clientStats[platform].monthVideos.forEach(video => {
                const likes = video.likes || 0;
                const views = video.views || 0;
                const comments = video.comments || 0;
                const shares = video.shares || 0;
                const duration = video.duration || 0;
                
                totalLikes += likes;
                totalViews += views;
                totalComments += comments;
                totalShares += shares;
                totalVideoDuration += duration;
                
                platformLikes[platform] += likes;
                platformViews[platform] += views;
                platformComments[platform] += comments;
                platformShares[platform] += shares;
              });
            }
            
            // Collect follower history data
            if (clientStats[platform].dailyFollowerData && clientStats[platform].dailyFollowerData.length > 0) {
              combinedFollowerData[platform] = clientStats[platform].dailyFollowerData;
            }
          }
        });
        
        // Calculate follower change and average views/second
        const followerChange = totalFollowersEnd - totalFollowersStart;
        const secondsInMonth = (this.currentMonthlyEndDate - this.currentMonthlyStartDate) / 1000;
        const avgViewsPerSecond = secondsInMonth > 0 ? (totalViews / secondsInMonth).toFixed(2) : 0;
        const changePrefix = followerChange >= 0 ? '+' : '';
        const changeColor = followerChange >= 0 ? '#00ff00' : '#ff0000';
        
        // Display summary statistics
        let statsHTML = `
          <div class="stat-card">
            <h4>TOTAL FOLLOWERS</h4>
            <div class="value">
              ${this.formatNumber(totalFollowersEnd)} <span style="color: ${changeColor}; font-size: 0.7em;">(${changePrefix}${this.formatNumber(followerChange)})</span>
            </div>
          </div>
          <div class="stat-card">
            <h4>AVERAGE VIEWS/SECOND</h4>
            <div class="value">${avgViewsPerSecond}</div>
          </div>
        `;
        
        statsContainer.innerHTML = statsHTML;
        
        // Create donut charts for the client
        this.createClientDonutCharts(chartsContainer, {
          platformFollowers,
          platformFollowersChange,
          platformLikes,
          platformViews,
          totalComments,
          totalShares,
          followerChange
        });
        
        // Create normalized follower growth chart
        this.createNormalizedFollowerGrowthChart(
          chartsContainer,
          `${clientName} Follower Growth`,
          combinedFollowerData,
          this.currentMonthlyStartDate,
          this.currentMonthlyEndDate,
          `${clientName}-follower-growth`
        );
      },
      
      // Change monthly reports style
      changeMonthlyStyle(style) {
        const container = document.getElementById('monthlyGraphsContainer');
        // Remove all style classes
        container.classList.remove('monthly-reports-style-1', 'monthly-reports-style-2', 'monthly-reports-style-3', 'monthly-reports-style-4', 'monthly-reports-style-5', 'monthly-reports-style-6', 'monthly-reports-style-7');
        // Add selected style class
        container.classList.add(`monthly-reports-${style}`);
        // Store in session storage
        sessionStorage.setItem('monthlyReportsStyle', style);
      },
      
      // Change donut label style
      changeDonutLabelStyle(style) {
        this.donutLabelStyle = style;
        sessionStorage.setItem('donutLabelStyle', style);
        // Re-render current tab to apply new style
        const activeTab = document.querySelector('.monthly-tab.active');
        if (activeTab) {
          const tabName = activeTab.getAttribute('data-tab');
          this.switchMonthlyTab(tabName);
        }
      },
      
      // Create donut chart
      createDonutChart(container, title, data, labels, chartId, centerValue = null) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'donut-chart-container';
        
        const header = document.createElement('h4');
        header.textContent = title;
        
        const wrapper = document.createElement('div');
        wrapper.className = 'donut-chart-wrapper';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        chartDiv.appendChild(header);
        wrapper.appendChild(canvas);
        chartDiv.appendChild(wrapper);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        // Handle negative values by using absolute values for chart display
        const absData = data.map(v => Math.abs(v));
        
        // Calculate total for center display
        const total = centerValue !== null ? centerValue : absData.reduce((sum, val) => sum + val, 0);
        
        // Platform colors
        const colors = {
          'Instagram': '#E1306C',
          'TikTok': '#00f2ea',
          'YouTube': '#FF0000'
        };
        
        const backgroundColors = labels.map(label => colors[label] || '#0f0');
        
        // Center text plugin for total
        const centerTextPlugin = {
          id: 'centerText',
          afterDraw: (chart) => {
            const { width, height, ctx, chartArea } = chart;
            if (!chartArea) return;
            
            ctx.save();
            const fontSize = (height / 114).toFixed(2);
            ctx.font = `bold ${fontSize}em monospace`;
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#0f0';
            
            const text = this.formatNumber(total);
            const textX = Math.round((width - ctx.measureText(text).width) / 2);
            // Use chartArea to properly center in the donut
            const textY = (chartArea.top + chartArea.bottom) / 2;
            
            ctx.fillText(text, textX, textY);
            ctx.restore();
          }
        };
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: labels,
            datasets: [{
              data: absData,
              backgroundColor: backgroundColors,
              borderColor: '#000',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                position: 'bottom',
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 },
                  padding: 15
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    const label = context.label || '';
                    const value = data[context.dataIndex]; // Use original value (might be negative)
                    const total = data.reduce((sum, val) => sum + Math.abs(val), 0);
                    const percentage = total > 0 ? ((Math.abs(value) / total) * 100).toFixed(1) : 0;
                    return `${label}: ${this.formatNumber(value)} (${percentage}%)`;
                  }
                }
              },
              datalabels: {
                color: (context) => {
                  // Use original data value to determine color
                  const originalValue = data[context.dataIndex];
                  return originalValue >= 0 ? '#00ff00' : '#ff0000';
                },
                backgroundColor: (context) => {
                  if (this.donutLabelStyle === 'background') {
                    return 'rgba(0, 0, 0, 0.7)';
                  } else if (this.donutLabelStyle === 'box') {
                    return 'rgba(0, 0, 0, 0.8)';
                  }
                  return null;
                },
                borderColor: (context) => {
                  if (this.donutLabelStyle === 'box') {
                    const originalValue = data[context.dataIndex];
                    return originalValue >= 0 ? '#00ff00' : '#ff0000';
                  }
                  return null;
                },
                borderWidth: (context) => {
                  return this.donutLabelStyle === 'box' ? 2 : 0;
                },
                borderRadius: (context) => {
                  return (this.donutLabelStyle === 'background' || this.donutLabelStyle === 'box') ? 4 : 0;
                },
                padding: (context) => {
                  return (this.donutLabelStyle === 'background' || this.donutLabelStyle === 'box') ? 4 : 0;
                },
                font: {
                  weight: 'bold',
                  size: 14,
                  family: 'monospace'
                },
                textShadowBlur: (context) => {
                  return this.donutLabelStyle === 'shadow' ? 10 : 0;
                },
                textShadowColor: (context) => {
                  return this.donutLabelStyle === 'shadow' ? '#000000' : null;
                },
                formatter: (value, context) => {
                  const total = absData.reduce((sum, val) => sum + val, 0);
                  const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                  // Hide 0.0 values
                  if (+percentage === 0) {
                    return '';
                  }
                  return percentage + '%';
                }
              }
            }
          },
          plugins: [centerTextPlugin]
        });
      },
      
      // Create donut charts for Total Moon Media view
      createTotalDonutCharts(container, data) {
        const { platformFollowers, platformFollowersChange, platformLikes, platformViews, totalComments, totalShares, followerChange } = data;
        
        const donutSection = document.createElement('div');
        donutSection.className = 'donut-charts-section';
        
        const sectionTitle = document.createElement('h3');
        sectionTitle.textContent = 'Platform Breakdown';
        donutSection.appendChild(sectionTitle);
        
        const donutGrid = document.createElement('div');
        donutGrid.className = 'donut-charts-grid';
        
        // Followers donut chart - show follower CHANGE in center
        const followerLabels = ['Instagram', 'TikTok', 'YouTube'];
        const followerData = [
          platformFollowers.instagram,
          platformFollowers.tiktok,
          platformFollowers.youtube
        ];
        this.createDonutChart(donutGrid, 'Total Followers by Platform', followerData, followerLabels, 'total-followers-donut', followerChange);
        
        // Likes donut chart
        const likeData = [
          platformLikes.instagram,
          platformLikes.tiktok,
          platformLikes.youtube
        ];
        this.createDonutChart(donutGrid, 'Total Likes by Platform', likeData, followerLabels, 'total-likes-donut');
        
        // Views donut chart
        const viewData = [
          platformViews.instagram,
          platformViews.tiktok,
          platformViews.youtube
        ];
        this.createDonutChart(donutGrid, 'Total Views by Platform', viewData, followerLabels, 'total-views-donut');
        
        donutSection.appendChild(donutGrid);
        
        // Add shares & comments stat boxes if there's data
        if (totalComments > 0 || totalShares > 0) {
          const extraStatsGrid = document.createElement('div');
          extraStatsGrid.className = 'stats-summary';
          extraStatsGrid.style.marginTop = '1em';
          
          if (totalComments > 0) {
            extraStatsGrid.innerHTML += `
              <div class="stat-card">
                <h4>TOTAL COMMENTS</h4>
                <div class="value">${this.formatNumber(totalComments)}</div>
              </div>
            `;
          }
          
          if (totalShares > 0) {
            extraStatsGrid.innerHTML += `
              <div class="stat-card">
                <h4>TOTAL SHARES</h4>
                <div class="value">${this.formatNumber(totalShares)}</div>
              </div>
            `;
          }
          
          donutSection.appendChild(extraStatsGrid);
        }
        
        container.appendChild(donutSection);
      },
      
      // Create donut charts for individual client view
      createClientDonutCharts(container, data) {
        const { platformFollowers, platformFollowersChange, platformLikes, platformViews, totalComments, totalShares, followerChange } = data;
        
        const donutSection = document.createElement('div');
        donutSection.className = 'donut-charts-section';
        
        const sectionTitle = document.createElement('h3');
        sectionTitle.textContent = 'Platform Breakdown';
        donutSection.appendChild(sectionTitle);
        
        const donutGrid = document.createElement('div');
        donutGrid.className = 'donut-charts-grid';
        
        const followerLabels = ['Instagram', 'TikTok', 'YouTube'];
        
        // Followers donut chart - show follower CHANGE in center
        const followerData = [
          platformFollowers.instagram,
          platformFollowers.tiktok,
          platformFollowers.youtube
        ];
        if (followerData.some(v => v !== 0)) {
          this.createDonutChart(donutGrid, 'Followers by Platform', followerData, followerLabels, 'client-followers-donut', followerChange);
        }
        
        // Likes donut chart
        const likeData = [
          platformLikes.instagram,
          platformLikes.tiktok,
          platformLikes.youtube
        ];
        if (likeData.some(v => v !== 0)) {
          this.createDonutChart(donutGrid, 'Likes by Platform', likeData, followerLabels, 'client-likes-donut');
        }
        
        // Views donut chart
        const viewData = [
          platformViews.instagram,
          platformViews.tiktok,
          platformViews.youtube
        ];
        if (viewData.some(v => v !== 0)) {
          this.createDonutChart(donutGrid, 'Views by Platform', viewData, followerLabels, 'client-views-donut');
        }
        
        donutSection.appendChild(donutGrid);
        
        // Add shares & comments stat boxes if there's data
        if (totalComments > 0 || totalShares > 0) {
          const extraStatsGrid = document.createElement('div');
          extraStatsGrid.className = 'stats-summary';
          extraStatsGrid.style.marginTop = '1em';
          
          if (totalComments > 0) {
            extraStatsGrid.innerHTML += `
              <div class="stat-card">
                <h4>TOTAL COMMENTS</h4>
                <div class="value">${this.formatNumber(totalComments)}</div>
              </div>
            `;
          }
          
          if (totalShares > 0) {
            extraStatsGrid.innerHTML += `
              <div class="stat-card">
                <h4>TOTAL SHARES</h4>
                <div class="value">${this.formatNumber(totalShares)}</div>
              </div>
            `;
          }
          
          donutSection.appendChild(extraStatsGrid);
        }
        
        container.appendChild(donutSection);
      },
      
      // Create normalized follower growth chart (starts at 0)
      createNormalizedFollowerGrowthChart(container, title, followerData, startDate, endDate, chartId) {
        // Merge and normalize data from all platforms
        const allDates = new Set();
        const platformData = { instagram: {}, tiktok: {}, youtube: {} };
        
        // Collect all unique dates and organize data by platform
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          if (followerData[platform] && followerData[platform].length > 0) {
            followerData[platform].forEach(point => {
              const dateKey = point.date.toISOString().split('T')[0];
              allDates.add(dateKey);
              if (!platformData[platform][dateKey] || point.followers > platformData[platform][dateKey]) {
                platformData[platform][dateKey] = point.followers;
              }
            });
          }
        });
        
        // If no data, skip chart
        if (allDates.size === 0) {
          return;
        }
        
        // Create a sorted array of all dates in the month
        const monthDates = [];
        const currentDate = new Date(startDate);
        while (currentDate <= endDate) {
          monthDates.push(new Date(currentDate));
          currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // Build datasets for each platform with interpolation
        const datasets = [];
        const platformColors = {
          instagram: { border: '#E1306C', bg: 'rgba(225, 48, 108, 0.2)' },
          tiktok: { border: '#00f2ea', bg: 'rgba(0, 242, 234, 0.2)' },
          youtube: { border: '#FF0000', bg: 'rgba(255, 0, 0, 0.2)' }
        };
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const data = platformData[platform];
          const dateKeys = Object.keys(data).sort();
          
          if (dateKeys.length === 0) return;
          
          // Get initial value (baseline for normalization)
          // Use the value at the start of the month range to ensure consistent baseline
          const startDateKey = startDate.toISOString().split('T')[0];
          let initialValue = data[startDateKey];
          
          // If no data for exact start date, find the closest date at or after start
          if (initialValue === undefined) {
            for (const dateKey of dateKeys) {
              if (dateKey >= startDateKey) {
                initialValue = data[dateKey];
                break;
              }
            }
            // If still no value found, fall back to first available
            if (initialValue === undefined) {
              initialValue = data[dateKeys[0]];
            }
          }
          
          // Create normalized data points for all days in month with linear interpolation
          const chartData = [];
          let lastKnownValue = initialValue;
          
          monthDates.forEach((date, index) => {
            const dateKey = date.toISOString().split('T')[0];
            
            if (data[dateKey] !== undefined) {
              // We have data for this date
              lastKnownValue = data[dateKey];
              const normalizedValue = lastKnownValue - initialValue;
              chartData.push({ x: date, y: normalizedValue });
            } else {
              // No data for this date - need to interpolate
              // Find previous known value
              let prevIndex = -1;
              let prevValue = null;
              for (let i = index - 1; i >= 0; i--) {
                const prevDateKey = monthDates[i].toISOString().split('T')[0];
                if (data[prevDateKey] !== undefined) {
                  prevIndex = i;
                  prevValue = data[prevDateKey];
                  break;
                }
              }
              
              // Find next known value
              let nextIndex = -1;
              let nextValue = null;
              for (let i = index + 1; i < monthDates.length; i++) {
                const nextDateKey = monthDates[i].toISOString().split('T')[0];
                if (data[nextDateKey] !== undefined) {
                  nextIndex = i;
                  nextValue = data[nextDateKey];
                  break;
                }
              }
              
              let interpolatedValue;
              if (prevValue !== null && nextValue !== null) {
                // Linear interpolation between prev and next
                const ratio = (index - prevIndex) / (nextIndex - prevIndex);
                interpolatedValue = prevValue + (nextValue - prevValue) * ratio;
              } else if (prevValue !== null) {
                // No next value, use previous value
                interpolatedValue = prevValue;
              } else if (nextValue !== null) {
                // No previous value, use next value
                interpolatedValue = nextValue;
              } else {
                // No values at all, use initial
                interpolatedValue = initialValue;
              }
              
              const normalizedValue = interpolatedValue - initialValue;
              chartData.push({ x: date, y: normalizedValue });
            }
          });
          
          const platformName = platform.charAt(0).toUpperCase() + platform.slice(1);
          datasets.push({
            label: platformName,
            data: chartData,
            borderColor: platformColors[platform].border,
            backgroundColor: platformColors[platform].bg,
            borderWidth: 3,
            pointRadius: 3,
            pointHoverRadius: 5,
            tension: 0.4,
            fill: true
          });
        });
        
        // If no datasets were created, skip chart
        if (datasets.length === 0) {
          return;
        }
        
        // Create the chart
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': +' + this.formatNumber(context.parsed.y);
                  }
                }
              },
              datalabels: {
                display: false
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'day',
                  displayFormats: { day: 'MMM d' }
                },
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: 'linear',
                beginAtZero: true,
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return '+' + this.formatNumber(value);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Populate week dropdown with current and past 12 weeks
      populateMonthDropdown() {
        const monthSelect = document.getElementById('monthSelect');
        monthSelect.innerHTML = '<option value="" disabled selected>-- select week --</option>';
        
        const now = new Date();
        
        // Constants for week calculations
        const DAYS_IN_WEEK = 7;
        const SUNDAY_INDEX = 0;
        const DAYS_FROM_SUNDAY_TO_MONDAY = 6;
        
        // Get the start of the current week (Monday)
        const currentWeekStart = new Date(now);
        const dayOfWeek = now.getDay();
        // If today is Sunday (0), go back 6 days to Monday; otherwise go back (dayOfWeek - 1) days
        const daysToMonday = dayOfWeek === SUNDAY_INDEX ? DAYS_FROM_SUNDAY_TO_MONDAY : dayOfWeek - 1;
        currentWeekStart.setDate(now.getDate() - daysToMonday);
        currentWeekStart.setHours(0, 0, 0, 0);
        
        // Add current week and previous 12 weeks
        for (let i = 0; i <= 12; i++) {
          const weekStart = new Date(currentWeekStart);
          weekStart.setDate(weekStart.getDate() - (i * DAYS_IN_WEEK));
          
          const weekEnd = new Date(weekStart);
          weekEnd.setDate(weekEnd.getDate() + (DAYS_IN_WEEK - 1));
          weekEnd.setHours(23, 59, 59, 999);
          
          const value = weekStart.toISOString().split('T')[0]; // YYYY-MM-DD format
          
          const formatDate = (d) => {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[d.getMonth()]} ${d.getDate()}`;
          };
          
          let label = `${formatDate(weekStart)} - ${formatDate(weekEnd)}, ${weekEnd.getFullYear()}`;
          
          // Mark current week
          if (i === 0) {
            label = 'This Week (' + label + ')';
          } else if (i === 1) {
            label = 'Last Week (' + label + ')';
          }
          
          const option = document.createElement('option');
          option.value = value;
          option.textContent = label;
          monthSelect.appendChild(option);
        }
      },
      
      // Select week for easy graphs (renamed from selectMonthForEasyGraphs but keeping name for compatibility)
      async selectMonthForEasyGraphs(weekStartValue) {
        // Parse the week start date
        const weekStart = new Date(weekStartValue + 'T00:00:00');
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        const formatDate = (d) => {
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          return `${months[d.getMonth()]} ${d.getDate()}`;
        };
        
        const weekLabel = `${formatDate(weekStart)} - ${formatDate(weekEnd)}, ${weekEnd.getFullYear()}`;
        
        // Show loading
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('loading').textContent = 'generating weekly analytics...';
        
        // Render the weekly graphs
        await this.renderWeeklyGraphs(weekStart, weekEnd, weekLabel);
        
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('easyGraphsContainer').classList.remove('hidden');
        
        // Store current week for PDF export
        this.currentEasyGraphsMonth = weekLabel;
        this.currentEasyGraphsYear = weekEnd.getFullYear();
      },
      
      // Match accounts across platforms using explicit mapping first, then fuzzy matching
      matchAccountsAcrossPlatforms() {
        const platformAccounts = {
          instagram: [],
          tiktok: [],
          youtube: []
        };
        
        // Get account names from each platform
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const workbook = this.easyGraphsData[`${platform}Workbook`];
          if (workbook && workbook.SheetNames) {
            platformAccounts[platform] = workbook.SheetNames;
          }
        });
        
        this.debugLog('Platform accounts found:', platformAccounts);
        
        // Track which accounts have been matched
        const usedAccounts = { instagram: new Set(), tiktok: new Set(), youtube: new Set() };
        const matchedAccounts = [];
        
        // STEP 1: Use explicit account mapping first
        Object.entries(this.ACCOUNT_MAPPING).forEach(([canonicalName, mapping]) => {
          const match = {
            name: canonicalName,
            normalizedName: canonicalName.toLowerCase(),
            instagram: null,
            tiktok: null,
            youtube: null
          };
          
          // Check if mapped accounts exist in each platform
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            const mappedAccount = mapping[platform];
            if (mappedAccount && platformAccounts[platform].includes(mappedAccount)) {
              match[platform] = mappedAccount;
              usedAccounts[platform].add(mappedAccount);
            } else if (mappedAccount) {
              // Try case-insensitive match
              const found = platformAccounts[platform].find(
                a => a.toLowerCase() === mappedAccount.toLowerCase()
              );
              if (found) {
                match[platform] = found;
                usedAccounts[platform].add(found);
              }
            }
          });
          
          // Only add if at least one platform matched
          if (match.instagram || match.tiktok || match.youtube) {
            matchedAccounts.push(match);
            this.debugLog(`Explicit match: ${canonicalName}`, match);
          }
        });
        
        // STEP 2: Fuzzy matching for remaining accounts
        // Account name normalization patterns
        const ACCOUNT_PREFIX_PATTERNS = /^(the_?|official_?)/i;
        const ACCOUNT_SUFFIX_PATTERNS = /(_?official|_?tv|_?shorts|_?reels|_?yt|_?ig|_?tt)$/i;
        const ACCOUNT_SEPARATOR_PATTERN = /[._-]/g;
        const MIN_MATCH_LENGTH = 3;
        
        const normalizeAccountName = (name) => {
          return name.toLowerCase()
            .replace(ACCOUNT_PREFIX_PATTERNS, '')
            .replace(ACCOUNT_SUFFIX_PATTERNS, '')
            .replace(ACCOUNT_SEPARATOR_PATTERN, '')
            .trim();
        };
        
        const namesMatch = (name1, name2) => {
          if (name1 === name2) return true;
          if (name1.length >= MIN_MATCH_LENGTH && name2.length >= MIN_MATCH_LENGTH) {
            return name1.includes(name2) || name2.includes(name1);
          }
          return false;
        };
        
        // Match remaining Instagram accounts
        platformAccounts.instagram.forEach(igAccount => {
          if (usedAccounts.instagram.has(igAccount)) return;
          
          const normalized = normalizeAccountName(igAccount);
          const match = {
            name: igAccount,
            normalizedName: normalized,
            instagram: igAccount,
            tiktok: null,
            youtube: null
          };
          
          // Find matching TikTok account
          platformAccounts.tiktok.forEach(ttAccount => {
            if (!usedAccounts.tiktok.has(ttAccount)) {
              const ttNormalized = normalizeAccountName(ttAccount);
              if (namesMatch(ttNormalized, normalized)) {
                match.tiktok = ttAccount;
                usedAccounts.tiktok.add(ttAccount);
              }
            }
          });
          
          // Find matching YouTube account
          platformAccounts.youtube.forEach(ytAccount => {
            if (!usedAccounts.youtube.has(ytAccount)) {
              const ytNormalized = normalizeAccountName(ytAccount);
              if (namesMatch(ytNormalized, normalized)) {
                match.youtube = ytAccount;
                usedAccounts.youtube.add(ytAccount);
              }
            }
          });
          
          usedAccounts.instagram.add(igAccount);
          matchedAccounts.push(match);
          this.debugLog(`Fuzzy match (IG): ${igAccount}`, match);
        });
        
        // Add any unmatched TikTok accounts
        platformAccounts.tiktok.forEach(ttAccount => {
          if (!usedAccounts.tiktok.has(ttAccount)) {
            const match = {
              name: ttAccount,
              normalizedName: normalizeAccountName(ttAccount),
              instagram: null,
              tiktok: ttAccount,
              youtube: null
            };
            matchedAccounts.push(match);
            this.debugLog(`Unmatched TikTok: ${ttAccount}`, match);
          }
        });
        
        // Add any unmatched YouTube accounts
        platformAccounts.youtube.forEach(ytAccount => {
          if (!usedAccounts.youtube.has(ytAccount)) {
            const match = {
              name: ytAccount,
              normalizedName: normalizeAccountName(ytAccount),
              instagram: null,
              tiktok: null,
              youtube: ytAccount
            };
            matchedAccounts.push(match);
            this.debugLog(`Unmatched YouTube: ${ytAccount}`, match);
          }
        });
        
        this.debugLog('Final matched accounts:', matchedAccounts);
        return matchedAccounts;
      },
      
      // Get account stats for a specific week
      // Calculates: 
      // 1. Views from posts made that week
      // 2. PLUS incremental views gained on recent posts (within 4 weeks) during that week
      getAccountWeeklyStats(platform, accountName, startDate, endDate) {
        const workbook = this.easyGraphsData[`${platform}Workbook`];
        if (!workbook) {
          this.debugLog(`No workbook for ${platform}`);
          return null;
        }
        
        // Parse account data with full history
        const accountData = this.parseAccountDataFromWorkbook(workbook, accountName, platform, 'all');
        if (!accountData) {
          this.debugLog(`No account data for ${accountName} on ${platform}`);
          return null;
        }
        
        const allVideos = accountData.videos || [];
        
        // Filter videos posted this week
        const weekVideos = allVideos.filter(v => 
          v.date >= startDate && v.date <= endDate
        );
        
        // Calculate views from posts made this week (full views for new posts)
        let weeklyViews = weekVideos.reduce((sum, v) => sum + (v.views || 0), 0);
        let weeklyLikes = weekVideos.reduce((sum, v) => sum + (v.likes || 0), 0);
        let weeklyComments = weekVideos.reduce((sum, v) => sum + (v.comments || 0), 0);
        
        // Also include incremental views from recent posts (within 4 weeks before this week)
        // that gained traction during this week
        const fourWeeksBeforeStart = new Date(startDate);
        fourWeeksBeforeStart.setDate(fourWeeksBeforeStart.getDate() - 28);
        
        const recentOlderVideos = allVideos.filter(v => 
          v.date >= fourWeeksBeforeStart && v.date < startDate
        );
        
        // For older posts, we need to estimate view gains during this week
        // Using the viewsHistory if available, otherwise use a fraction of total views
        if (accountData.viewsHistory && accountData.viewsHistory.length > 0) {
          // Try to calculate actual view gains from history
          const weekViewsHistory = accountData.viewsHistory.filter(h => 
            h.date >= startDate && h.date <= endDate
          ).sort((a, b) => a.date - b.date);
          
          const prevWeekViewsHistory = accountData.viewsHistory.filter(h => 
            h.date >= fourWeeksBeforeStart && h.date < startDate
          ).sort((a, b) => a.date - b.date);
          
          if (weekViewsHistory.length >= 1 && prevWeekViewsHistory.length >= 1) {
            // Calculate view gain during this week
            const weekEndViews = weekViewsHistory[weekViewsHistory.length - 1].value;
            const weekStartViews = prevWeekViewsHistory[prevWeekViewsHistory.length - 1].value;
            const viewGain = Math.max(0, weekEndViews - weekStartViews);
            
            // If we have actual view gain data, use it instead of summing post views
            // This accounts for organic growth on older posts
            if (viewGain > 0) {
              weeklyViews = viewGain;
            }
          }
        } else {
          // Fallback: For recent older posts, add a portion of their views
          // (assuming they got a decaying portion of views in each of the first few weeks)
          for (const video of recentOlderVideos) {
            const videoAge = Math.floor((startDate - video.date) / this.WEEKLY_CALC.MS_PER_WEEK); // weeks old
            if (videoAge <= this.WEEKLY_CALC.RECENT_WEEKS_LOOKBACK && video.views) {
              // Estimate weekly view contribution (decay factor based on age)
              const weeklyContribution = video.views * (this.WEEKLY_CALC.WEEKLY_DECAY_FACTOR / (videoAge + 1));
              weeklyViews += Math.round(weeklyContribution);
            }
          }
        }
        
        const stats = {
          views: weeklyViews,
          likes: weeklyLikes,
          comments: weeklyComments,
          posts: weekVideos.length,
          newFollowers: 0,
          currentFollowers: accountData.followers || 0
        };
        
        // Calculate new followers this week
        const validFollowersHistory = (accountData.followersHistory || []).filter(h => 
          h && h.value != null && typeof h.value === 'number' && h.value > 0
        );
        
        if (validFollowersHistory.length > 0) {
          const weekHistory = validFollowersHistory.filter(h => 
            h.date >= startDate && h.date <= endDate
          ).sort((a, b) => a.date - b.date);
          
          if (weekHistory.length >= 2) {
            stats.newFollowers = weekHistory[weekHistory.length - 1].value - weekHistory[0].value;
          } else if (weekHistory.length === 1) {
            const prevWeekStart = new Date(startDate);
            prevWeekStart.setDate(prevWeekStart.getDate() - 7);
            const prevHistory = validFollowersHistory.filter(h => 
              h.date >= prevWeekStart && h.date < startDate
            ).sort((a, b) => a.date - b.date);
            
            if (prevHistory.length > 0) {
              stats.newFollowers = weekHistory[0].value - prevHistory[prevHistory.length - 1].value;
            }
          }
        }
        
        this.debugLog(`Stats for ${accountName} (${platform}):`, stats);
        return stats;
      },
      
      // Render weekly graphs (replaces renderEasyGraphs for weekly mode)
      async renderWeeklyGraphs(startDate, endDate, weekLabel) {
        const container = document.getElementById('easyChartsList');
        container.innerHTML = '';
        
        // Reset chart instances
        this.chartInstances = {};
        
        document.getElementById('easyGraphsTitle').textContent = 
          `Weekly Analytics: ${weekLabel}`;
        
        // Match accounts across platforms
        const matchedAccounts = this.matchAccountsAcrossPlatforms();
        
        // Calculate stats for each matched account
        const accountStats = [];
        let totalViews = 0;
        let totalLikes = 0;
        let totalComments = 0;
        let totalNewFollowers = 0;
        let totalPosts = 0;
        
        matchedAccounts.forEach(account => {
          const stats = {
            name: account.name,
            instagram: account.instagram ? this.getAccountWeeklyStats('instagram', account.instagram, startDate, endDate) : null,
            tiktok: account.tiktok ? this.getAccountWeeklyStats('tiktok', account.tiktok, startDate, endDate) : null,
            youtube: account.youtube ? this.getAccountWeeklyStats('youtube', account.youtube, startDate, endDate) : null
          };
          
          // Aggregate totals
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (stats[platform]) {
              totalViews += stats[platform].views || 0;
              totalLikes += stats[platform].likes || 0;
              totalComments += stats[platform].comments || 0;
              totalNewFollowers += stats[platform].newFollowers || 0;
              totalPosts += stats[platform].posts || 0;
            }
          });
          
          accountStats.push(stats);
        });
        
        // Render stats summary
        const statsContainer = document.getElementById('easyStatsSummary');
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>TOTAL VIEWS THIS WEEK</h4>
            <div class="value">${this.formatNumber(totalViews)}</div>
          </div>
          <div class="stat-card">
            <h4>NEW FOLLOWERS</h4>
            <div class="value">+${this.formatNumber(totalNewFollowers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL COMMENTS</h4>
            <div class="value">${this.formatNumber(totalComments)}</div>
          </div>
          <div class="stat-card">
            <h4>POSTS THIS WEEK</h4>
            <div class="value">${totalPosts}</div>
          </div>
        `;
        
        // Store account stats for export
        this.weeklyAccountStats = accountStats;
        this.weeklyMatchedAccounts = matchedAccounts;
        this.weeklyStartDate = startDate;
        this.weeklyEndDate = endDate;
        this.weeklyLabel = weekLabel;
        
        // Populate the export account dropdown
        const exportSelect = document.getElementById('exportAccountSelect');
        if (exportSelect) {
          exportSelect.innerHTML = '<option value="">-- select account --</option>' +
            matchedAccounts.map(acc => `<option value="${acc.name}">@${acc.name}</option>`).join('');
        }
        
        // Create per-account breakdown table
        this.createAccountBreakdownTable(container, accountStats);
        
        // Create platform comparison chart for the week
        this.createWeeklyPlatformComparisonChart(container, accountStats);
        
        // Create views by account chart
        this.createWeeklyViewsByAccountChart(container, accountStats);
        
        // Create new followers by account chart
        this.createWeeklyFollowersByAccountChart(container, accountStats);
      },
      
      // Create account breakdown table for weekly analytics
      createAccountBreakdownTable(container, accountStats) {
        const tableDiv = document.createElement('div');
        tableDiv.className = 'chart-container';
        tableDiv.style.overflowX = 'auto';
        
        const header = document.createElement('h3');
        header.textContent = 'Account Performance Breakdown';
        tableDiv.appendChild(header);
        
        const table = document.createElement('table');
        table.style.cssText = 'width: 100%; border-collapse: collapse; color: #0f0; font-family: monospace;';
        
        // Create header row
        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr style="border-bottom: 2px solid #0f0;">
            <th style="padding: 10px; text-align: left;">Account</th>
            <th style="padding: 10px; text-align: center;">IG Views</th>
            <th style="padding: 10px; text-align: center;">TT Views</th>
            <th style="padding: 10px; text-align: center;">YT Views</th>
            <th style="padding: 10px; text-align: center;">Total Views</th>
            <th style="padding: 10px; text-align: center;">New Followers</th>
            <th style="padding: 10px; text-align: center;">Posts</th>
          </tr>
        `;
        table.appendChild(thead);
        
        // Create body rows
        const tbody = document.createElement('tbody');
        accountStats.forEach(account => {
          const igStats = account.instagram || { views: 0, newFollowers: 0, posts: 0 };
          const ttStats = account.tiktok || { views: 0, newFollowers: 0, posts: 0 };
          const ytStats = account.youtube || { views: 0, newFollowers: 0, posts: 0 };
          
          const totalViews = (igStats.views || 0) + (ttStats.views || 0) + (ytStats.views || 0);
          const totalNewFollowers = (igStats.newFollowers || 0) + (ttStats.newFollowers || 0) + (ytStats.newFollowers || 0);
          const totalPosts = (igStats.posts || 0) + (ttStats.posts || 0) + (ytStats.posts || 0);
          
          // Only show accounts with activity
          if (totalViews > 0 || totalNewFollowers > 0 || totalPosts > 0) {
            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid rgba(0, 255, 0, 0.3)';
            row.innerHTML = `
              <td style="padding: 8px; text-align: left;">@${account.name}</td>
              <td style="padding: 8px; text-align: center; color: #E1306C;">${this.formatNumber(igStats.views || 0)}</td>
              <td style="padding: 8px; text-align: center; color: #00f2ea;">${this.formatNumber(ttStats.views || 0)}</td>
              <td style="padding: 8px; text-align: center; color: #FF0000;">${this.formatNumber(ytStats.views || 0)}</td>
              <td style="padding: 8px; text-align: center; font-weight: bold;">${this.formatNumber(totalViews)}</td>
              <td style="padding: 8px; text-align: center; color: ${totalNewFollowers >= 0 ? '#0f0' : '#ff0'};">+${this.formatNumber(totalNewFollowers)}</td>
              <td style="padding: 8px; text-align: center;">${totalPosts}</td>
            `;
            tbody.appendChild(row);
          }
        });
        table.appendChild(tbody);
        
        tableDiv.appendChild(table);
        container.appendChild(tableDiv);
      },
      
      // Create weekly platform comparison chart
      createWeeklyPlatformComparisonChart(container, accountStats) {
        // Aggregate by platform
        const platformTotals = {
          instagram: { views: 0, likes: 0, newFollowers: 0, posts: 0 },
          tiktok: { views: 0, likes: 0, newFollowers: 0, posts: 0 },
          youtube: { views: 0, likes: 0, newFollowers: 0, posts: 0 }
        };
        
        accountStats.forEach(account => {
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (account[platform]) {
              platformTotals[platform].views += account[platform].views || 0;
              platformTotals[platform].likes += account[platform].likes || 0;
              platformTotals[platform].newFollowers += account[platform].newFollowers || 0;
              platformTotals[platform].posts += account[platform].posts || 0;
            }
          });
        });
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'weekly-platform-comparison';
        
        const header = document.createElement('h3');
        header.textContent = 'Views by Platform This Week';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['weekly-platform-comparison'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              label: 'Views',
              data: [
                platformTotals.instagram.views,
                platformTotals.tiktok.views,
                platformTotals.youtube.views
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => 'Views: ' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Create weekly views by account chart
      createWeeklyViewsByAccountChart(container, accountStats) {
        // Get accounts with views, sorted by total views
        const accountsWithViews = accountStats
          .map(account => {
            const total = (account.instagram?.views || 0) + 
                          (account.tiktok?.views || 0) + 
                          (account.youtube?.views || 0);
            return { name: account.name, total, ...account };
          })
          .filter(a => a.total > 0)
          .sort((a, b) => b.total - a.total);
        
        if (accountsWithViews.length === 0) return;
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'weekly-views-by-account';
        
        const header = document.createElement('h3');
        header.textContent = 'Views by Account This Week';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['weekly-views-by-account'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: accountsWithViews.map(a => '@' + a.name),
            datasets: [
              {
                label: 'Instagram',
                data: accountsWithViews.map(a => a.instagram?.views || 0),
                backgroundColor: '#E1306C'
              },
              {
                label: 'TikTok',
                data: accountsWithViews.map(a => a.tiktok?.views || 0),
                backgroundColor: '#00f2ea'
              },
              {
                label: 'YouTube',
                data: accountsWithViews.map(a => a.youtube?.views || 0),
                backgroundColor: '#FF0000'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: true,
                labels: { color: '#0f0', font: { family: 'monospace' } }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => context.dataset.label + ': ' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                stacked: true,
                ticks: { color: '#0f0', font: { family: 'monospace', size: 10 } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                stacked: true,
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Create weekly new followers by account chart
      createWeeklyFollowersByAccountChart(container, accountStats) {
        // Get accounts with follower growth
        const accountsWithGrowth = accountStats
          .map(account => {
            const total = (account.instagram?.newFollowers || 0) + 
                          (account.tiktok?.newFollowers || 0) + 
                          (account.youtube?.newFollowers || 0);
            return { name: account.name, total, ...account };
          })
          .filter(a => a.total !== 0)
          .sort((a, b) => b.total - a.total);
        
        if (accountsWithGrowth.length === 0) return;
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'weekly-followers-by-account';
        
        const header = document.createElement('h3');
        header.textContent = 'New Followers by Account This Week';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['weekly-followers-by-account'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: accountsWithGrowth.map(a => '@' + a.name),
            datasets: [
              {
                label: 'Instagram',
                data: accountsWithGrowth.map(a => a.instagram?.newFollowers || 0),
                backgroundColor: '#E1306C'
              },
              {
                label: 'TikTok',
                data: accountsWithGrowth.map(a => a.tiktok?.newFollowers || 0),
                backgroundColor: '#00f2ea'
              },
              {
                label: 'YouTube',
                data: accountsWithGrowth.map(a => a.youtube?.newFollowers || 0),
                backgroundColor: '#FF0000'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: true,
                labels: { color: '#0f0', font: { family: 'monospace' } }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => context.dataset.label + ': +' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                stacked: true,
                ticks: { color: '#0f0', font: { family: 'monospace', size: 10 } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                stacked: true,
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => '+' + this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Render monthly graphs for a selected month
      async renderMonthlyGraphs(startDate, endDate, monthLabel) {
        const container = document.getElementById('monthlyChartsList');
        container.innerHTML = '';
        
        // Reset chart instances
        this.chartInstances = {};
        
        document.getElementById('monthlyGraphsTitle').textContent = 
          `Monthly Reports: ${monthLabel}`;
        
        // Match accounts across platforms
        const matchedAccounts = this.matchAccountsAcrossPlatforms();
        
        // Calculate monthly stats for each account
        const accountStats = [];
        let totalFollowersStart = 0;
        let totalFollowersEnd = 0;
        let totalPosts = 0;
        let platformTotals = {
          instagram: { start: 0, end: 0, posts: 0, accountCount: 0 },
          tiktok: { start: 0, end: 0, posts: 0, accountCount: 0 },
          youtube: { start: 0, end: 0, posts: 0, accountCount: 0 }
        };
        
        matchedAccounts.forEach(account => {
          const stats = {
            name: account.name,
            instagram: account.instagram ? this.getAccountMonthlyStats('instagram', account.instagram, startDate, endDate) : null,
            tiktok: account.tiktok ? this.getAccountMonthlyStats('tiktok', account.tiktok, startDate, endDate) : null,
            youtube: account.youtube ? this.getAccountMonthlyStats('youtube', account.youtube, startDate, endDate) : null
          };
          
          // Aggregate totals
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (stats[platform]) {
              totalFollowersStart += stats[platform].followersStart || 0;
              totalFollowersEnd += stats[platform].followersEnd || 0;
              totalPosts += stats[platform].posts || 0;
              
              platformTotals[platform].start += stats[platform].followersStart || 0;
              platformTotals[platform].end += stats[platform].followersEnd || 0;
              platformTotals[platform].posts += stats[platform].posts || 0;
              platformTotals[platform].accountCount++;
            }
          });
          
          accountStats.push(stats);
        });
        
        const totalFollowerGrowth = totalFollowersEnd - totalFollowersStart;
        
        // Render summary statistics
        const statsContainer = document.getElementById('monthlyStatsSummary');
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>TOTAL FOLLOWERS</h4>
            <div class="value">${this.formatNumber(totalFollowersEnd)}</div>
          </div>
          <div class="stat-card">
            <h4>FOLLOWER GROWTH THIS MONTH</h4>
            <div class="value">${totalFollowerGrowth >= 0 ? '+' : ''}${this.formatNumber(totalFollowerGrowth)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL POSTS PUBLISHED</h4>
            <div class="value">${totalPosts}</div>
          </div>
          <div class="stat-card">
            <h4>INSTAGRAM GROWTH</h4>
            <div class="value">${platformTotals.instagram.end - platformTotals.instagram.start >= 0 ? '+' : ''}${this.formatNumber(platformTotals.instagram.end - platformTotals.instagram.start)} (${platformTotals.instagram.accountCount} accounts)</div>
          </div>
          <div class="stat-card">
            <h4>TIKTOK GROWTH</h4>
            <div class="value">${platformTotals.tiktok.end - platformTotals.tiktok.start >= 0 ? '+' : ''}${this.formatNumber(platformTotals.tiktok.end - platformTotals.tiktok.start)} (${platformTotals.tiktok.accountCount} accounts)</div>
          </div>
          <div class="stat-card">
            <h4>YOUTUBE GROWTH</h4>
            <div class="value">${platformTotals.youtube.end - platformTotals.youtube.start >= 0 ? '+' : ''}${this.formatNumber(platformTotals.youtube.end - platformTotals.youtube.start)} (${platformTotals.youtube.accountCount} accounts)</div>
          </div>
        `;
        
        // Store monthly data for export
        this.monthlyAccountStats = accountStats;
        this.monthlyMatchedAccounts = matchedAccounts;
        this.monthlyPlatformTotals = platformTotals;
        
        // Create per-account follower growth charts (daily progression throughout the month)
        this.createMonthlyFollowerGrowthCharts(container, accountStats, startDate, endDate);
        
        // Create platform breakdown chart
        this.createMonthlyPlatformBreakdownChart(container, platformTotals);
        
        // Create content performance charts
        this.createMonthlyContentPerformanceCharts(container, accountStats, startDate, endDate);
      },
      
      // Get account monthly stats (followers at start/end of month, posts published)
      getAccountMonthlyStats(platform, accountName, startDate, endDate) {
        const workbook = this.easyGraphsData[`${platform}Workbook`];
        if (!workbook) {
          return null;
        }
        
        // Parse account data with full history
        const accountData = this.parseAccountDataFromWorkbook(workbook, accountName, platform, 'all');
        if (!accountData) {
          return null;
        }
        
        // Get follower history for this month
        const validFollowersHistory = (accountData.followersHistory || []).filter(h => 
          h && h.value != null && typeof h.value === 'number' && h.value > 0
        );
        
        let followersStart = 0;
        let followersEnd = 0;
        const dailyFollowerData = [];
        
        if (validFollowersHistory.length > 0) {
          // Find followers at start of month (or closest before)
          const beforeStart = validFollowersHistory.filter(h => h.date <= startDate).sort((a, b) => b.date - a.date);
          if (beforeStart.length > 0) {
            followersStart = beforeStart[0].value;
          }
          
          // Find followers at end of month (or closest before end)
          const beforeEnd = validFollowersHistory.filter(h => h.date <= endDate).sort((a, b) => b.date - a.date);
          if (beforeEnd.length > 0) {
            followersEnd = beforeEnd[0].value;
          }
          
          // Get daily follower progression throughout the month
          const monthData = validFollowersHistory.filter(h => h.date >= startDate && h.date <= endDate);
          dailyFollowerData.push(...monthData.map(h => ({ date: h.date, followers: h.value })));
        }
        
        // Filter posts published this month
        const allVideos = accountData.videos || [];
        const monthVideos = allVideos.filter(v => 
          v.date >= startDate && v.date <= endDate
        );
        
        return {
          followersStart,
          followersEnd,
          posts: monthVideos.length,
          dailyFollowerData,
          monthVideos
        };
      },
      
      // Create per-account follower growth charts showing daily progression
      createMonthlyFollowerGrowthCharts(container, accountStats, startDate, endDate) {
        accountStats.forEach(account => {
          // Combine daily follower data from all platforms for this account
          const allDailyData = [];
          
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (account[platform] && account[platform].dailyFollowerData) {
              account[platform].dailyFollowerData.forEach(d => {
                allDailyData.push({
                  date: d.date,
                  platform,
                  followers: d.followers
                });
              });
            }
          });
          
          if (allDailyData.length === 0) return;
          
          const chartDiv = document.createElement('div');
          chartDiv.className = 'chart-container';
          
          const canvas = document.createElement('canvas');
          canvas.id = `monthly-follower-growth-${account.name}`;
          
          const header = document.createElement('h3');
          header.textContent = `@${account.name} - Follower Growth`;
          
          chartDiv.appendChild(header);
          chartDiv.appendChild(canvas);
          container.appendChild(chartDiv);
          
          const ctx = canvas.getContext('2d');
          
          // Create datasets for each platform
          const datasets = [];
          const platformColors = {
            instagram: { border: '#E1306C', bg: 'rgba(225, 48, 108, 0.1)' },
            tiktok: { border: '#00f2ea', bg: 'rgba(0, 242, 234, 0.1)' },
            youtube: { border: '#FF0000', bg: 'rgba(255, 0, 0, 0.1)' }
          };
          
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (account[platform] && account[platform].dailyFollowerData && account[platform].dailyFollowerData.length > 0) {
              datasets.push({
                label: platform.charAt(0).toUpperCase() + platform.slice(1),
                data: account[platform].dailyFollowerData.map(d => ({ x: d.date, y: d.followers })),
                borderColor: platformColors[platform].border,
                backgroundColor: platformColors[platform].bg,
                borderWidth: 3,
                tension: 0.4,
                fill: true,
                pointRadius: 2,
                pointHoverRadius: 4
              });
            }
          });
          
          const chartId = `monthly-follower-growth-${account.name}`;
          this.chartInstances[chartId] = new Chart(ctx, {
            type: 'line',
            data: { datasets },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              plugins: {
                legend: {
                  display: true,
                  labels: { color: '#0f0', font: { family: 'monospace', size: 12 } }
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#0f0',
                  bodyColor: '#0f0',
                  borderColor: '#0f0',
                  borderWidth: 1,
                  callbacks: {
                    label: (context) => {
                      return context.dataset.label + ': ' + this.formatNumber(context.parsed.y) + ' followers';
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'day',
                    displayFormats: { day: 'MMM d' }
                  },
                  min: startDate.getTime(),
                  max: endDate.getTime(),
                  ticks: { color: '#0f0', font: { family: 'monospace' } },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                },
                y: {
                  type: 'linear',
                  ticks: {
                    color: '#0f0',
                    font: { family: 'monospace' },
                    callback: (value) => this.formatNumber(value)
                  },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                }
              }
            }
          });
        });
      },
      
      // Create platform breakdown chart for monthly analytics
      createMonthlyPlatformBreakdownChart(container, platformTotals) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'monthly-platform-breakdown';
        
        const header = document.createElement('h3');
        header.textContent = 'Follower Growth by Platform';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const platforms = ['instagram', 'tiktok', 'youtube'];
        const platformNames = ['Instagram', 'TikTok', 'YouTube'];
        const platformGrowth = platforms.map(p => platformTotals[p].end - platformTotals[p].start);
        const colors = ['#E1306C', '#00f2ea', '#FF0000'];
        
        this.chartInstances['monthly-platform-breakdown'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: platformNames,
            datasets: [{
              label: 'Follower Growth',
              data: platformGrowth,
              backgroundColor: colors,
              borderColor: colors,
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    const platform = platforms[context.dataIndex];
                    const start = platformTotals[platform].start;
                    const end = platformTotals[platform].end;
                    const growth = context.parsed.y;
                    return [
                      `Start: ${this.formatNumber(start)}`,
                      `End: ${this.formatNumber(end)}`,
                      `Growth: ${growth >= 0 ? '+' : ''}${this.formatNumber(growth)}`
                    ];
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => (value >= 0 ? '+' : '') + this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Create content performance charts for monthly analytics
      createMonthlyContentPerformanceCharts(container, accountStats, startDate, endDate) {
        // Collect all posts from all accounts for this month
        const allMonthlyPosts = [];
        
        accountStats.forEach(account => {
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (account[platform] && account[platform].monthVideos) {
              account[platform].monthVideos.forEach(video => {
                allMonthlyPosts.push({
                  ...video,
                  account: account.name,
                  platform
                });
              });
            }
          });
        });
        
        if (allMonthlyPosts.length === 0) return;
        
        // Top performing posts by views
        const topPosts = [...allMonthlyPosts]
          .sort((a, b) => (b.views || 0) - (a.views || 0))
          .slice(0, 10);
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'monthly-top-posts';
        
        const header = document.createElement('h3');
        header.textContent = 'Top 10 Posts This Month (by Views)';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const platformColors = {
          instagram: '#E1306C',
          tiktok: '#00f2ea',
          youtube: '#FF0000'
        };
        
        this.chartInstances['monthly-top-posts'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: topPosts.map((p, i) => `#${i+1} @${p.account}`),
            datasets: [{
              label: 'Views',
              data: topPosts.map(p => p.views || 0),
              backgroundColor: topPosts.map(p => platformColors[p.platform]),
              borderColor: topPosts.map(p => platformColors[p.platform]),
              borderWidth: 2
            }]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 1.5,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    const post = topPosts[context.dataIndex];
                    return [
                      `Platform: ${post.platform}`,
                      `Views: ${this.formatNumber(post.views || 0)}`,
                      `Likes: ${this.formatNumber(post.likes || 0)}`,
                      `Engagement: ${(post.engagement || 0).toFixed(2)}%`
                    ];
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                ticks: { color: '#0f0', font: { family: 'monospace', size: 10 } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
        
        // Posts per platform breakdown
        const platformPostCounts = {
          instagram: 0,
          tiktok: 0,
          youtube: 0
        };
        
        allMonthlyPosts.forEach(post => {
          platformPostCounts[post.platform]++;
        });
        
        const pieChartDiv = document.createElement('div');
        pieChartDiv.className = 'chart-container';
        pieChartDiv.style.maxWidth = '500px';
        pieChartDiv.style.margin = '2em auto';
        
        const pieCanvas = document.createElement('canvas');
        pieCanvas.id = 'monthly-posts-platform-breakdown';
        
        const pieHeader = document.createElement('h3');
        pieHeader.textContent = 'Posts Distribution by Platform';
        
        pieChartDiv.appendChild(pieHeader);
        pieChartDiv.appendChild(pieCanvas);
        container.appendChild(pieChartDiv);
        
        const pieCtx = pieCanvas.getContext('2d');
        
        this.chartInstances['monthly-posts-platform-breakdown'] = new Chart(pieCtx, {
          type: 'doughnut',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              data: [platformPostCounts.instagram, platformPostCounts.tiktok, platformPostCounts.youtube],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: '#000',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                position: 'bottom',
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    const total = allMonthlyPosts.length;
                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                    return `${context.label}: ${context.parsed} posts (${percentage}%)`;
                  }
                }
              }
            }
          }
        });
      },
      
      // Export monthly report PDF
      exportMonthlyReport() {
        // For now, show a helpful message
        // TODO: Implement full PDF export similar to exportClientReport()
        const message = document.createElement('div');
        message.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #000; color: #0f0; border: 3px solid #0f0; padding: 2em; border-radius: 10px; z-index: 10000; text-align: center; font-family: monospace; max-width: 500px;';
        message.innerHTML = `
          <h3 style="margin-top: 0; color: #ffff00;">Export Feature Coming Soon!</h3>
          <p>For now, please use screenshot tools to capture the charts.</p>
          <p style="margin-bottom: 0;">Press any key or click to close.</p>
        `;
        document.body.appendChild(message);
        
        const closeMessage = () => {
          document.body.removeChild(message);
          document.removeEventListener('click', closeMessage);
          document.removeEventListener('keydown', closeMessage);
        };
        
        document.addEventListener('click', closeMessage);
        document.addEventListener('keydown', closeMessage);
      },
      
      // Render easy graphs for client report
      async renderEasyGraphs(startDate, endDate, monthName, year) {
        const container = document.getElementById('easyChartsList');
        container.innerHTML = '';
        
        // Reset chart instances
        this.chartInstances = {};
        
        document.getElementById('easyGraphsTitle').textContent = 
          `${monthName} ${year} Analytics for MoonMedia`;
        
        // Calculate stats for each platform for this month
        const platformStats = {};
        const platforms = ['instagram', 'tiktok', 'youtube'];
        
        let totalViews = 0;
        let totalNewFollowers = 0;
        
        platforms.forEach(platform => {
          const data = this.easyGraphsData[platform];
          if (data && data.videos) {
            // Filter videos for this month
            const monthVideos = data.videos.filter(v => 
              v.date >= startDate && v.date <= endDate
            );
            
            const views = monthVideos.reduce((sum, v) => sum + (v.views || 0), 0);
            const likes = monthVideos.reduce((sum, v) => sum + (v.likes || 0), 0);
            const posts = monthVideos.length;
            
            // Calculate new followers with extrapolation for sparse data
            let newFollowers = 0;
            if (data.followersHistory && data.followersHistory.length > 0) {
              const monthHistory = data.followersHistory.filter(h => 
                h.date >= startDate && h.date <= endDate
              );
              
              if (monthHistory.length >= 2) {
                // Direct calculation when we have enough data points
                const sorted = monthHistory.sort((a, b) => a.date - b.date);
                newFollowers = sorted[sorted.length - 1].value - sorted[0].value;
              } else {
                // Extrapolate from all available history if month data is sparse
                const allHistory = data.followersHistory.sort((a, b) => a.date - b.date);
                
                if (allHistory.length >= 2) {
                  // Calculate daily growth rate from all history
                  const firstPoint = allHistory[0];
                  const lastPoint = allHistory[allHistory.length - 1];
                  const totalDays = (lastPoint.date - firstPoint.date) / (1000 * 60 * 60 * 24);
                  const totalGrowth = lastPoint.value - firstPoint.value;
                  
                  if (totalDays > 0 && totalGrowth > 0) {
                    const dailyGrowthRate = totalGrowth / totalDays;
                    
                    // Calculate days in this month's range
                    const monthDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
                    
                    // Extrapolate growth for this month
                    newFollowers = Math.round(dailyGrowthRate * monthDays);
                    
                    // Note: This is an extrapolated value
                    if (newFollowers > 0) {
                      console.log(`[${platform}] Extrapolated follower growth: ~${newFollowers} (from ${dailyGrowthRate.toFixed(2)}/day avg)`);
                    }
                  }
                } else if (monthHistory.length === 1) {
                  // If we only have one data point this month, check if there's data before
                  const beforeMonth = data.followersHistory.filter(h => h.date < startDate);
                  if (beforeMonth.length > 0) {
                    const lastBefore = beforeMonth.sort((a, b) => a.date - b.date).pop();
                    newFollowers = monthHistory[0].value - lastBefore.value;
                    if (newFollowers < 0) newFollowers = 0; // Don't show negative
                  }
                }
              }
            }
            
            platformStats[platform] = { views, likes, posts, newFollowers };
            totalViews += views;
            totalNewFollowers += newFollowers;
          }
        });
        
        // Render stats summary
        const statsContainer = document.getElementById('easyStatsSummary');
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>TOTAL VIEWS</h4>
            <div class="value">${this.formatNumber(totalViews)}</div>
          </div>
          <div class="stat-card">
            <h4>NEW FOLLOWERS</h4>
            <div class="value">+${this.formatNumber(totalNewFollowers)}</div>
          </div>
          <div class="stat-card">
            <h4>INSTAGRAM VIEWS</h4>
            <div class="value">${this.formatNumber(platformStats.instagram?.views || 0)}</div>
          </div>
          <div class="stat-card">
            <h4>TIKTOK VIEWS</h4>
            <div class="value">${this.formatNumber(platformStats.tiktok?.views || 0)}</div>
          </div>
          <div class="stat-card">
            <h4>YOUTUBE VIEWS</h4>
            <div class="value">${this.formatNumber(platformStats.youtube?.views || 0)}</div>
          </div>
        `;
        
        // Create platform views comparison chart
        this.createEasyPlatformViewsChart(container, platformStats);
        
        // Create views over time chart for the month
        this.createEasyViewsOverTimeChart(container, startDate, endDate);
        
        // Create followers growth chart
        this.createEasyFollowersChart(container, startDate, endDate);
      },
      
      // Create platform views comparison chart for easy graphs
      createEasyPlatformViewsChart(container, platformStats) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'easy-platform-views';
        
        const header = document.createElement('h3');
        header.textContent = 'Views by Platform';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['easy-platform-views'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              label: 'Views',
              data: [
                platformStats.instagram?.views || 0,
                platformStats.tiktok?.views || 0,
                platformStats.youtube?.views || 0
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => 'Views: ' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Create views over time chart for easy graphs (with cumulative line and logarithmic scale)
      createEasyViewsOverTimeChart(container, startDate, endDate) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'easy-views-time';
        
        const header = document.createElement('h3');
        header.textContent = 'Views Over Time (Cumulative + Per-Post)';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        // Combine all videos from all platforms
        const allVideos = [];
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const data = this.easyGraphsData[platform];
          if (data && data.videos) {
            const monthVideos = data.videos.filter(v => 
              v.date >= startDate && v.date <= endDate
            );
            allVideos.push(...monthVideos.map(v => ({ ...v, platform })));
          }
        });
        
        allVideos.sort((a, b) => a.date - b.date);
        
        // Calculate cumulative views
        let cumulativeViews = 0;
        const cumulativeData = allVideos.map(v => {
          cumulativeViews += (v.views || 0);
          return { x: v.date, y: cumulativeViews };
        });
        
        // Determine if logarithmic scale is appropriate (large range)
        const viewsArray = allVideos.map(v => v.views || 0).filter(v => v > 0);
        const maxViews = Math.max(...viewsArray, 1);
        const minViews = Math.min(...viewsArray.filter(v => v > 0), maxViews);
        const useLogScale = maxViews / minViews > 100 && maxViews > 10000;
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['easy-views-time'] = new Chart(ctx, {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'Cumulative Views',
                data: cumulativeData,
                borderColor: '#0f0',
                backgroundColor: 'rgba(0, 255, 0, 0.1)',
                borderWidth: 2,
                fill: true,
                tension: 0.3,
                yAxisID: 'y-cumulative'
              },
              {
                label: 'Views per Post',
                data: allVideos.map(v => ({ x: v.date, y: v.views || 0 })),
                borderColor: '#00d2d3',
                backgroundColor: 'rgba(0, 210, 211, 0.7)',
                pointRadius: 4,
                pointHoverRadius: 6,
                type: 'scatter',
                yAxisID: 'y-individual'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: {
                display: true,
                labels: { color: '#0f0', font: { family: 'monospace' } }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => {
                    const label = context.dataset.label || '';
                    return label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'day',
                  displayFormats: { day: 'MMM d' }
                },
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              'y-cumulative': {
                type: useLogScale ? 'logarithmic' : 'linear',
                position: 'left',
                title: {
                  display: true,
                  text: 'Cumulative Views' + (useLogScale ? ' (log)' : ''),
                  color: '#0f0',
                  font: { family: 'monospace' }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              'y-individual': {
                type: useLogScale ? 'logarithmic' : 'linear',
                position: 'right',
                title: {
                  display: true,
                  text: 'Per-Post Views' + (useLogScale ? ' (log)' : ''),
                  color: '#00d2d3',
                  font: { family: 'monospace' }
                },
                ticks: {
                  color: '#00d2d3',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { drawOnChartArea: false }
              }
            }
          }
        });
      },
      
      // Create followers chart for easy graphs
      createEasyFollowersChart(container, startDate, endDate) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'easy-followers';
        
        const header = document.createElement('h3');
        header.textContent = 'Followers/Subscribers Growth';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        // Get followers data from each platform
        const datasets = [];
        const platformColors = {
          instagram: { border: '#E1306C', bg: 'rgba(225, 48, 108, 0.3)' },
          tiktok: { border: '#00f2ea', bg: 'rgba(0, 242, 234, 0.3)' },
          youtube: { border: '#FF0000', bg: 'rgba(255, 0, 0, 0.3)' }
        };
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const data = this.easyGraphsData[platform];
          if (data && data.followersHistory) {
            const monthHistory = data.followersHistory
              .filter(h => h.date >= startDate && h.date <= endDate)
              .sort((a, b) => a.date - b.date);
            
            if (monthHistory.length > 0) {
              datasets.push({
                label: platform.charAt(0).toUpperCase() + platform.slice(1),
                data: monthHistory.map(h => ({ x: h.date, y: h.value })),
                borderColor: platformColors[platform].border,
                backgroundColor: platformColors[platform].bg,
                borderWidth: 2,
                tension: 0.3,
                fill: false
              });
            }
          }
        });
        
        if (datasets.length > 0) {
          const ctx = canvas.getContext('2d');
          
          this.chartInstances['easy-followers'] = new Chart(ctx, {
            type: 'line',
            data: { datasets },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: '#0f0',
                    font: { family: 'monospace' }
                  }
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#0f0',
                  bodyColor: '#0f0',
                  callbacks: {
                    label: (context) => context.dataset.label + ': ' + this.formatNumber(context.parsed.y)
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'day',
                    displayFormats: { day: 'MMM d' }
                  },
                  ticks: { color: '#0f0', font: { family: 'monospace' } },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                },
                y: {
                  ticks: {
                    color: '#0f0',
                    font: { family: 'monospace' },
                    callback: (value) => this.formatNumber(value)
                  },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                }
              }
            }
          });
        }
      },
      
      // Export client report as PDF
      async exportClientReport() {
        const monthName = this.currentEasyGraphsMonth;
        const year = this.currentEasyGraphsYear;
        const filename = `${monthName}_${year}_analytics_for_MoonMedia.pdf`;
        
        // Create a temporary container for the export
        const exportContainer = document.createElement('div');
        exportContainer.style.position = 'absolute';
        exportContainer.style.left = '-9999px';
        exportContainer.style.background = '#000';
        exportContainer.style.padding = '20px';
        exportContainer.style.width = '800px';
        document.body.appendChild(exportContainer);
        
        // Clone the charts section
        const chartsClone = document.getElementById('easyGraphsContainer').cloneNode(true);
        
        // Remove the export button from clone
        const exportBtns = chartsClone.querySelectorAll('.looks-good-btn, .export-section');
        exportBtns.forEach(btn => btn.remove());
        
        exportContainer.appendChild(chartsClone);
        
        try {
          // Use html2canvas if available, otherwise use a simpler approach
          if (typeof html2canvas !== 'undefined') {
            const canvas = await html2canvas(exportContainer, {
              backgroundColor: '#000000',
              scale: 2
            });
            
            const imgData = canvas.toDataURL('image/png');
            
            // Create download link
            const link = document.createElement('a');
            link.download = filename.replace('.pdf', '.png');
            link.href = imgData;
            link.click();
          } else {
            // Fallback: export charts as images
            alert(`Export feature: In a full implementation, this would generate "${filename}"\n\nTo enable PDF export, add html2canvas and jsPDF libraries.`);
            
            // Export each chart individually
            Object.keys(this.chartInstances).forEach(chartId => {
              if (chartId.startsWith('easy-')) {
                const chart = this.chartInstances[chartId];
                if (chart) {
                  const imageUrl = chart.toBase64Image();
                  const link = document.createElement('a');
                  link.download = `${monthName}_${year}_${chartId}.png`;
                  link.href = imageUrl;
                  link.click();
                }
              }
            });
          }
        } catch (error) {
          console.error('Export error:', error);
          alert('Export failed. Charts have been downloaded individually.');
        } finally {
          document.body.removeChild(exportContainer);
        }
      },
      
      // Export individual client report as PDF
      async exportIndividualClientReport() {
        const accountSelect = document.getElementById('exportAccountSelect');
        const selectedAccount = accountSelect.value;
        
        if (!selectedAccount) {
          alert('Please select an account to export.');
          return;
        }
        
        // Find the account data
        const accountStats = this.weeklyAccountStats.find(a => a.name === selectedAccount);
        if (!accountStats) {
          alert('Account data not found.');
          return;
        }
        
        const weekLabel = this.weeklyLabel || this.currentEasyGraphsMonth;
        const year = this.currentEasyGraphsYear || new Date().getFullYear();
        const filename = `${selectedAccount}_${weekLabel.replace(/\s+/g, '_')}_${year}_report.pdf`;
        
        // Create a temporary container for the individual client report
        const exportContainer = document.createElement('div');
        exportContainer.style.position = 'fixed';
        exportContainer.style.top = '0';
        exportContainer.style.left = '0';
        exportContainer.style.right = '0';
        exportContainer.style.bottom = '0';
        exportContainer.style.background = '#000';
        exportContainer.style.padding = '20px';
        exportContainer.style.overflow = 'auto';
        exportContainer.style.zIndex = '9999';
        exportContainer.id = 'individualExportContainer';
        document.body.appendChild(exportContainer);
        
        // Create the individual client report content
        exportContainer.innerHTML = `
          <div style="max-width: 900px; margin: 0 auto; color: #0f0; font-family: monospace;">
            <div style="text-align: center; margin-bottom: 2em;">
              <h1 style="color: #0f0; font-size: 2em;">@${selectedAccount}</h1>
              <h2 style="color: #0a0; font-size: 1.2em;">${weekLabel} ${year} Analytics Report</h2>
              <p style="color: #080;">Prepared by MoonMedia</p>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1em; margin-bottom: 2em;">
              <div style="background: #111; border: 1px solid #0f0; padding: 1em; text-align: center; border-radius: 8px;">
                <h4 style="margin: 0; color: #0a0;">Total Views</h4>
                <div style="font-size: 1.5em; color: #0f0;">${this.formatNumber(
                  (accountStats.instagram?.views || 0) + 
                  (accountStats.tiktok?.views || 0) + 
                  (accountStats.youtube?.views || 0)
                )}</div>
              </div>
              <div style="background: #111; border: 1px solid #0f0; padding: 1em; text-align: center; border-radius: 8px;">
                <h4 style="margin: 0; color: #0a0;">New Followers</h4>
                <div style="font-size: 1.5em; color: #0f0;">+${this.formatNumber(
                  (accountStats.instagram?.newFollowers || 0) + 
                  (accountStats.tiktok?.newFollowers || 0) + 
                  (accountStats.youtube?.newFollowers || 0)
                )}</div>
              </div>
              <div style="background: #111; border: 1px solid #0f0; padding: 1em; text-align: center; border-radius: 8px;">
                <h4 style="margin: 0; color: #0a0;">Posts This Week</h4>
                <div style="font-size: 1.5em; color: #0f0;">${
                  (accountStats.instagram?.posts || 0) + 
                  (accountStats.tiktok?.posts || 0) + 
                  (accountStats.youtube?.posts || 0)
                }</div>
              </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1em; margin-bottom: 2em;">
              <div style="background: #111; border: 1px solid #0f0; padding: 1em; border-radius: 8px;">
                <h3 style="color: #0f0; margin-top: 0;">Views by Platform</h3>
                <canvas id="clientViewsChart" height="200"></canvas>
              </div>
              <div style="background: #111; border: 1px solid #0f0; padding: 1em; border-radius: 8px;">
                <h3 style="color: #0f0; margin-top: 0;">New Followers by Platform</h3>
                <canvas id="clientFollowersChart" height="200"></canvas>
              </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1em; margin-bottom: 2em;">
              <div style="background: #111; border: 1px solid #0f0; padding: 1em; border-radius: 8px;">
                <h3 style="color: #0f0; margin-top: 0;">Posts by Platform</h3>
                <canvas id="clientPostsChart" height="200"></canvas>
              </div>
              <div style="background: #111; border: 1px solid #0f0; padding: 1em; border-radius: 8px;">
                <h3 style="color: #0f0; margin-top: 0;">Likes by Platform</h3>
                <canvas id="clientLikesChart" height="200"></canvas>
              </div>
            </div>
            
            <div style="background: #111; border: 1px solid #0f0; padding: 1em; border-radius: 8px; margin-bottom: 2em;">
              <h3 style="color: #0f0; margin-top: 0;">Platform Breakdown</h3>
              <table style="width: 100%; border-collapse: collapse; color: #0f0;">
                <thead>
                  <tr style="border-bottom: 1px solid #0f0;">
                    <th style="padding: 10px; text-align: left;">Platform</th>
                    <th style="padding: 10px; text-align: center;">Views</th>
                    <th style="padding: 10px; text-align: center;">New Followers</th>
                    <th style="padding: 10px; text-align: center;">Likes</th>
                    <th style="padding: 10px; text-align: center;">Comments</th>
                    <th style="padding: 10px; text-align: center;">Posts</th>
                  </tr>
                </thead>
                <tbody>
                  <tr style="border-bottom: 1px solid #060;">
                    <td style="padding: 10px;">Instagram</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.instagram?.views || 0)}</td>
                    <td style="padding: 10px; text-align: center;">+${this.formatNumber(accountStats.instagram?.newFollowers || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.instagram?.likes || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.instagram?.comments || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${accountStats.instagram?.posts || 0}</td>
                  </tr>
                  <tr style="border-bottom: 1px solid #060;">
                    <td style="padding: 10px;">TikTok</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.tiktok?.views || 0)}</td>
                    <td style="padding: 10px; text-align: center;">+${this.formatNumber(accountStats.tiktok?.newFollowers || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.tiktok?.likes || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.tiktok?.comments || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${accountStats.tiktok?.posts || 0}</td>
                  </tr>
                  <tr>
                    <td style="padding: 10px;">YouTube</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.youtube?.views || 0)}</td>
                    <td style="padding: 10px; text-align: center;">+${this.formatNumber(accountStats.youtube?.newFollowers || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.youtube?.likes || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${this.formatNumber(accountStats.youtube?.comments || 0)}</td>
                    <td style="padding: 10px; text-align: center;">${accountStats.youtube?.posts || 0}</td>
                  </tr>
                </tbody>
              </table>
            </div>
            
            <div style="text-align: center; margin-top: 2em;">
              <button onclick="app.downloadClientReport('${selectedAccount}')" style="background: #0f0; color: #000; border: none; padding: 1em 2em; font-size: 1.2em; cursor: pointer; border-radius: 5px; margin-right: 1em;">
                ðŸ“¥ Download Report
              </button>
              <button onclick="document.getElementById('individualExportContainer').remove()" style="background: #333; color: #0f0; border: 1px solid #0f0; padding: 1em 2em; font-size: 1.2em; cursor: pointer; border-radius: 5px;">
                âœ• Close Preview
              </button>
            </div>
          </div>
        `;
        
        // Create the charts
        this.createClientViewsChart('clientViewsChart', accountStats);
        this.createClientFollowersChart('clientFollowersChart', accountStats);
        this.createClientPostsChart('clientPostsChart', accountStats);
        this.createClientLikesChart('clientLikesChart', accountStats);
      },
      
      // Create views chart for individual client
      createClientViewsChart(canvasId, accountStats) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              label: 'Views',
              data: [
                accountStats.instagram?.views || 0,
                accountStats.tiktok?.views || 0,
                accountStats.youtube?.views || 0
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: false }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: { color: '#0f0' },
                grid: { color: '#030' }
              },
              x: {
                ticks: { color: '#0f0' },
                grid: { display: false }
              }
            }
          }
        });
      },
      
      // Create followers chart for individual client
      createClientFollowersChart(canvasId, accountStats) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              label: 'New Followers',
              data: [
                accountStats.instagram?.newFollowers || 0,
                accountStats.tiktok?.newFollowers || 0,
                accountStats.youtube?.newFollowers || 0
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: false }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: { color: '#0f0' },
                grid: { color: '#030' }
              },
              x: {
                ticks: { color: '#0f0' },
                grid: { display: false }
              }
            }
          }
        });
      },
      
      // Create posts chart for individual client
      createClientPostsChart(canvasId, accountStats) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              data: [
                accountStats.instagram?.posts || 0,
                accountStats.tiktok?.posts || 0,
                accountStats.youtube?.posts || 0
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: '#000',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: 'bottom',
                labels: { color: '#0f0' }
              }
            }
          }
        });
      },
      
      // Create likes chart for individual client
      createClientLikesChart(canvasId, accountStats) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              label: 'Likes',
              data: [
                accountStats.instagram?.likes || 0,
                accountStats.tiktok?.likes || 0,
                accountStats.youtube?.likes || 0
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: false }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: { color: '#0f0' },
                grid: { color: '#030' }
              },
              x: {
                ticks: { color: '#0f0' },
                grid: { display: false }
              }
            }
          }
        });
      },
      
      // Download individual client report
      async downloadClientReport(accountName) {
        const weekLabel = this.weeklyLabel || this.currentEasyGraphsMonth;
        const year = this.currentEasyGraphsYear || new Date().getFullYear();
        const filename = `${accountName}_${weekLabel.replace(/\s+/g, '_')}_${year}_report`;
        
        const exportContainer = document.getElementById('individualExportContainer');
        
        try {
          if (typeof html2canvas !== 'undefined') {
            const canvas = await html2canvas(exportContainer, {
              backgroundColor: '#000000',
              scale: 2
            });
            
            const imgData = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = imgData;
            link.click();
          } else {
            // Fallback: download charts as images
            alert(`To download as PDF, add html2canvas library.\n\nDownloading charts as separate images...`);
            
            ['clientViewsChart', 'clientFollowersChart', 'clientPostsChart', 'clientLikesChart'].forEach(chartId => {
              const canvas = document.getElementById(chartId);
              if (canvas) {
                const link = document.createElement('a');
                link.download = `${filename}_${chartId}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
              }
            });
          }
        } catch (error) {
          console.error('Download error:', error);
          alert('Download failed. Please try again.');
        }
      },
      
      // Platform selection
      async selectPlatform(platform) {
        this.selectedPlatform = platform;
        this.isAllPlatforms = (platform === 'all');
        
        document.getElementById('step0Custom').classList.add('hidden');
        
        if (this.isAllPlatforms) {
          // Show loading while fetching data to determine date range
          document.getElementById('loading').classList.remove('hidden');
          document.getElementById('loading').textContent = 'loading data for date range...';
          
          // Load all platforms data with 'all' time range to get date range
          await this.loadAllPlatformsDataForDateRange();
          
          document.getElementById('loading').classList.add('hidden');
          document.getElementById('loading').textContent = 'loading data...';
          document.getElementById('step2').classList.remove('hidden');
        } else {
          document.getElementById('step1').classList.remove('hidden');
          this.loadSheetData();
        }
      },
      
      // Load all platforms data just to determine date range
      async loadAllPlatformsDataForDateRange() {
        let allVideos = [];
        let allTotalLikesHistory = [];
        let allFollowersHistory = [];
        
        // Load Instagram data
        try {
          const igResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.instagram}/export?format=xlsx`);
          const igBuffer = await igResponse.arrayBuffer();
          const igWorkbook = XLSX.read(igBuffer, { type: 'array' });
          const igData = this.processWorkbookData(igWorkbook, 'instagram', 'all');
          if (igData && igData.videos) {
            allVideos = allVideos.concat(igData.videos);
          }
        } catch (error) {
          console.error('Error loading Instagram data for date range:', error);
        }
        
        // Load TikTok data
        try {
          const ttResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.tiktok}/export?format=xlsx`);
          const ttBuffer = await ttResponse.arrayBuffer();
          const ttWorkbook = XLSX.read(ttBuffer, { type: 'array' });
          const ttData = this.processWorkbookData(ttWorkbook, 'tiktok', 'all');
          if (ttData && ttData.videos) {
            allVideos = allVideos.concat(ttData.videos);
          }
        } catch (error) {
          console.error('Error loading TikTok data for date range:', error);
        }
        
        // Load YouTube data
        try {
          const ytResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.youtube}/export?format=xlsx`);
          const ytBuffer = await ytResponse.arrayBuffer();
          const ytWorkbook = XLSX.read(ytBuffer, { type: 'array' });
          const ytData = this.processWorkbookData(ytWorkbook, 'youtube', 'all');
          if (ytData && ytData.videos) {
            allVideos = allVideos.concat(ytData.videos);
          }
        } catch (error) {
          console.error('Error loading YouTube data for date range:', error);
        }
        
        // Update slider with the extracted date range
        this.updateSliderWithDataRange(allVideos, allTotalLikesHistory, allFollowersHistory);
      },
      
      // Account selection
      selectAccount(account) {
        this.selectedAccount = account;
        this.isMoonMediaTotal = (account === 'MOONMEDIA_TOTAL');
        document.getElementById('step1').classList.add('hidden');
        document.getElementById('step2').classList.remove('hidden');
        
        // Parse data with 'all' time range to extract the full date range
        const fullData = this.isMoonMediaTotal 
          ? this.parseMoonMediaTotal('all')
          : this.parseAccountData(this.selectedAccount, 'all');
        
        // Update slider with actual data date range
        if (fullData) {
          this.updateSliderWithDataRange(
            fullData.videos || [], 
            fullData.totalLikesHistory || [], 
            fullData.followersHistory || []
          );
        } else {
          this.initializeSliderWithData();
        }
      },
      
      // Time range selection
      async selectTimeRange(days) {
        this.selectedTimeRange = days;
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        
        if (this.isAllPlatforms) {
          await this.loadAllPlatformsData(days);
        } else {
          setTimeout(() => {
            this.processData(days);
            this.finalizeDataDisplay(days);
          }, 1000);
        }
      },
      
      // Finalize data display
      finalizeDataDisplay(days) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('charts').classList.remove('hidden');
        
        // Update UI labels
        let accountText = '';
        if (this.isAllPlatforms) {
          accountText = 'All MoonMedia Platforms';
        } else if (this.isMoonMediaTotal) {
          accountText = 'All MoonMedia';
        } else {
          accountText = '@' + this.selectedAccount;
        }
        
        document.getElementById('accountName').textContent = accountText;
        
        let rangeText = '';
        if (days === 'all') rangeText = '(All Time)';
        else if (days === 365) rangeText = '(Last 1 Year)';
        else if (days === 180) rangeText = '(Last 6 Months)';
        else if (days === 30) rangeText = '(Last 1 Month)';
        else if (days === 'custom' && this.customStartDate && this.customEndDate) {
          rangeText = `(${this.formatDate(this.customStartDate)} - ${this.formatDate(this.customEndDate)})`;
        }
        document.getElementById('timeRangeLabel').textContent = rangeText;
        
        if (this.isAllPlatforms) {
          this.renderAllPlatformsDashboard();
        } else {
          this.renderDashboard();
        }
      },
      
      // Load all platforms data
      async loadAllPlatformsData(timeRangeDays) {
        this.allPlatformsData = {
          instagram: null,
          tiktok: null,
          youtube: null,
          combined: {
            totalFollowers: 0,
            totalLikes: 0,
            totalViews: 0,
            totalPosts: 0,
            viewsPerSecond: 0
          }
        };
        
        // Also store unfiltered videos for cumulative calculations with historical context
        this.allVideosUnfiltered = [];
        
        // Load Instagram data
        try {
          const igResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.instagram}/export?format=xlsx`);
          const igBuffer = await igResponse.arrayBuffer();
          const igWorkbook = XLSX.read(igBuffer, { type: 'array' });
          this.allPlatformsData.instagram = this.processWorkbookData(igWorkbook, 'instagram', timeRangeDays);
          // Store unfiltered videos
          const igUnfiltered = this.processWorkbookData(igWorkbook, 'instagram', 'all');
          if (igUnfiltered && igUnfiltered.videos) {
            this.allVideosUnfiltered = this.allVideosUnfiltered.concat(igUnfiltered.videos);
          }
        } catch (error) {
          console.error('Error loading Instagram data:', error);
        }
        
        // Load TikTok data
        try {
          const ttResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.tiktok}/export?format=xlsx`);
          const ttBuffer = await ttResponse.arrayBuffer();
          const ttWorkbook = XLSX.read(ttBuffer, { type: 'array' });
          this.allPlatformsData.tiktok = this.processWorkbookData(ttWorkbook, 'tiktok', timeRangeDays);
          // Store unfiltered videos
          const ttUnfiltered = this.processWorkbookData(ttWorkbook, 'tiktok', 'all');
          if (ttUnfiltered && ttUnfiltered.videos) {
            this.allVideosUnfiltered = this.allVideosUnfiltered.concat(ttUnfiltered.videos);
          }
        } catch (error) {
          console.error('Error loading TikTok data:', error);
        }
        
        // Load YouTube data
        try {
          const ytResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.youtube}/export?format=xlsx`);
          const ytBuffer = await ytResponse.arrayBuffer();
          const ytWorkbook = XLSX.read(ytBuffer, { type: 'array' });
          this.allPlatformsData.youtube = this.processWorkbookData(ytWorkbook, 'youtube', timeRangeDays);
          // Store unfiltered videos
          const ytUnfiltered = this.processWorkbookData(ytWorkbook, 'youtube', 'all');
          if (ytUnfiltered && ytUnfiltered.videos) {
            this.allVideosUnfiltered = this.allVideosUnfiltered.concat(ytUnfiltered.videos);
          }
        } catch (error) {
          console.error('Error loading YouTube data:', error);
        }
        
        // Calculate combined metrics
        this.calculateCombinedMetrics();
        
        this.finalizeDataDisplay(timeRangeDays);
      },
      
      // Process workbook data for all platforms view
      processWorkbookData(workbook, platform, timeRangeDays) {
        const accounts = workbook.SheetNames;
        let totalFollowers = 0;
        let totalLikes = 0;
        let totalPosts = 0;
        let allVideos = [];
        
        // Aggregate followers history across all accounts
        // Using timestamp-based aggregation similar to parseMoonMediaTotal
        let followersByTimestamp = {};
        let highestKnownFollowersByAccount = {};
        
        accounts.forEach(sheetName => {
          const data = this.parseAccountDataFromWorkbook(workbook, sheetName, platform, timeRangeDays);
          if (data) {
            totalFollowers += data.followers || 0;
            totalLikes += data.totalLikes || 0;
            totalPosts += data.postsScraped || 0;
            if (data.videos) {
              allVideos = allVideos.concat(data.videos);
            }
            
            // Aggregate followers history for this account
            if (data.followersHistory && data.followersHistory.length > 0) {
              data.followersHistory.forEach(item => {
                if (!this.isValidDate(item.date)) return;
                
                const dateKey = item.date.toISOString();
                if (!followersByTimestamp[dateKey]) {
                  followersByTimestamp[dateKey] = { 
                    date: item.date, 
                    accountValues: {} 
                  };
                }
                followersByTimestamp[dateKey].accountValues[sheetName] = item.value;
              });
            }
          }
        });
        
        // Build aggregated followers history using highest known values
        // (followers should never decrease - lower values are scrape errors)
        const sortedFollowersTimestamps = Object.values(followersByTimestamp)
          .filter(item => this.isValidDate(item.date))
          .sort((a, b) => a.date - b.date);
        
        const followersHistory = [];
        accounts.forEach(acc => { highestKnownFollowersByAccount[acc] = 0; });
        
        // Build history using highest value seen UP TO each timestamp
        sortedFollowersTimestamps.forEach(item => {
          // Update current values for accounts that have data at this timestamp
          // Only update if the new value is higher (followers shouldn't decrease)
          Object.keys(item.accountValues).forEach(acc => {
            const newValue = item.accountValues[acc];
            if (newValue > highestKnownFollowersByAccount[acc]) {
              highestKnownFollowersByAccount[acc] = newValue;
            }
          });
          
          // Sum all current highest known values
          const cumulativeTotal = Object.values(highestKnownFollowersByAccount).reduce((sum, val) => sum + val, 0);
          
          // Only add if we have a meaningful total
          if (cumulativeTotal > 0) {
            // Check if this is different from the last entry to avoid duplicates
            const lastEntry = followersHistory[followersHistory.length - 1];
            if (!lastEntry || lastEntry.value !== cumulativeTotal) {
              followersHistory.push({
                date: item.date,
                value: cumulativeTotal
              });
            }
          }
        });
        
        const totalViews = allVideos.reduce((sum, v) => sum + (v.views || 0), 0);
        
        return {
          platform: platform,
          followers: totalFollowers,
          totalLikes: totalLikes,
          totalViews: totalViews,
          postsScraped: totalPosts,
          videos: allVideos,
          accountCount: accounts.length,
          followersHistory: followersHistory
        };
      },
      
      // Calculate combined metrics for all platforms
      calculateCombinedMetrics() {
        const platforms = ['instagram', 'tiktok', 'youtube'];
        let totalViews = 0;
        let allVideos = [];
        
        platforms.forEach(platform => {
          if (this.allPlatformsData[platform]) {
            const data = this.allPlatformsData[platform];
            this.allPlatformsData.combined.totalFollowers += data.followers || 0;
            this.allPlatformsData.combined.totalLikes += data.totalLikes || 0;
            this.allPlatformsData.combined.totalViews += data.totalViews || 0;
            this.allPlatformsData.combined.totalPosts += data.postsScraped || 0;
            
            if (data.videos) {
              allVideos = allVideos.concat(data.videos);
            }
          }
        });
        
        // Calculate views per second
        allVideos.sort((a, b) => (a.date || 0) - (b.date || 0));
        
        if (allVideos.length >= 2) {
          const validVideos = allVideos.filter(v => v.date && v.views);
          if (validVideos.length >= 2) {
            const oldestVideo = validVideos[0];
            const newestVideo = validVideos[validVideos.length - 1];
            const timeSpanSeconds = (newestVideo.date - oldestVideo.date) / 1000;
            
            if (timeSpanSeconds > 0) {
              const totalViewsInPeriod = validVideos.reduce((sum, v) => sum + v.views, 0);
              this.allPlatformsData.combined.viewsPerSecond = totalViewsInPeriod / timeSpanSeconds;
            }
          }
        }
      },
      
      // Parse account data from workbook
      parseAccountDataFromWorkbook(workbook, sheetName, platform, timeRangeDays) {
        if (platform === 'instagram') {
          return this.parseInstagramDataFromWorkbook(workbook, sheetName, timeRangeDays);
        } else if (platform === 'tiktok') {
          return this.parseTikTokDataFromWorkbook(workbook, sheetName, timeRangeDays);
        } else if (platform === 'youtube') {
          return this.parseYouTubeDataFromWorkbook(workbook, sheetName, timeRangeDays);
        }
        return null;
      },
      
      // Load sheet data
      async loadSheetData() {
        const accountSelect = document.getElementById('accountSelect');
        
        try {
          accountSelect.innerHTML = '<option value="" disabled>loading accounts...</option>';
          
          const sheetId = this.SHEET_IDS[this.selectedPlatform];
          const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=xlsx`;
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          
          this.workbookData = XLSX.read(arrayBuffer, { type: 'array' });
          
          const accounts = this.workbookData.SheetNames;
          
          if (accounts.length === 0) {
            accountSelect.innerHTML = '<option>no accounts found</option>';
            return;
          }
          
          accountSelect.innerHTML = 
            '<option value="" disabled selected>-- select an account --</option>' +
            '<option value="MOONMEDIA_TOTAL" class="moonmedia-option">All MoonMedia Analytics</option>' +
            accounts.map(acc => `<option value="${acc}">@${acc}</option>`).join('');
          
          console.log('Loaded accounts:', accounts);
          
        } catch (error) {
          console.error('Error loading data:', error);
          accountSelect.innerHTML = '<option>error loading - check file permissions</option>';
        }
      },
      
      // Process data based on platform and account
      processData(timeRangeDays) {
        if (this.isMoonMediaTotal) {
          this.accountData = this.parseMoonMediaTotal(timeRangeDays);
          // Also store unfiltered videos for cumulative calculations with historical context
          const unfilteredData = this.parseMoonMediaTotal('all');
          this.allVideosUnfiltered = unfilteredData.videos || [];
        } else {
          this.accountData = this.parseAccountData(this.selectedAccount, timeRangeDays);
          // Also store unfiltered videos for cumulative calculations with historical context
          const unfilteredData = this.parseAccountData(this.selectedAccount, 'all');
          this.allVideosUnfiltered = unfilteredData.videos || [];
        }
      },
      
      // Parse account data
      parseAccountData(sheetName, timeRangeDays = 'all') {
        if (this.selectedPlatform === 'instagram') {
          return this.parseInstagramData(sheetName, timeRangeDays);
        } else if (this.selectedPlatform === 'tiktok') {
          return this.parseTikTokData(sheetName, timeRangeDays);
        } else if (this.selectedPlatform === 'youtube') {
          return this.parseYouTubeData(sheetName, timeRangeDays);
        }
      },
      
      // Parse YouTube data from sheet
      parseYouTubeData(sheetName, timeRangeDays) {
        return this.parseYouTubeDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse YouTube data from workbook
      parseYouTubeDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        // Parse YouTube data similar to TikTok structure
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'subscribers' || rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName === 'total_likes') {
            totalLikesHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName.startsWith('post_') || rowName.startsWith('video_') || rowName.startsWith('short_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            if (metric === 'Date' || metric === 'date') {
              allUniqueVideoIds.add(videoId);
            }
            
            // For views and likes, use the HIGHEST REALISTIC value across all scrapes
            // Filter out anomalies: likes â‰ˆ views, likes > views, implausibly low likes
            const metricLower = metric.toLowerCase();
            if (metricLower === 'views' || metricLower === 'likes') {
              let highestValue = 0;
              let allValues = [];
              
              // Collect all values first
              for (let colIdx = 1; colIdx < row.length; colIdx++) {
                const cellValue = parseInt(row[colIdx]) || 0;
                if (cellValue > 0) {
                  allValues.push({ colIdx, value: cellValue });
                }
              }
              
              // For likes, we need to filter out anomalies
              if (metricLower === 'likes' && allValues.length > 0) {
                // Get the views for this video to detect anomalies
                const viewsRow = allVideosMap.get(videoId);
                const videoViews = viewsRow ? viewsRow.Views : null;
                
                // Filter out anomalous likes values
                const realisticValues = allValues.filter(item => {
                  if (videoViews) {
                    // Reject if likes â‰ˆ views (likely extraction error)
                    if (Math.abs(item.value - videoViews) / videoViews < this.ANOMALY_THRESHOLDS.LIKES_VIEWS_RATIO) {
                      return false;
                    }
                    // Reject if likes > views (impossible)
                    if (item.value > videoViews) {
                      return false;
                    }
                    // Reject if likes < threshold of views for significant views (implausibly low)
                    if (videoViews > this.ANOMALY_THRESHOLDS.SIGNIFICANT_VIEWS && 
                        item.value < videoViews * this.ANOMALY_THRESHOLDS.MIN_LIKES_RATIO) {
                      return false;
                    }
                  }
                  return true;
                });
                
                // Use highest realistic value, or fall back to highest overall if all filtered
                if (realisticValues.length > 0) {
                  highestValue = Math.max(...realisticValues.map(v => v.value));
                } else if (allValues.length > 0) {
                  // All values are anomalous - use the median as best guess
                  const sorted = allValues.map(v => v.value).sort((a, b) => a - b);
                  highestValue = sorted[Math.floor(sorted.length / 2)];
                }
              } else {
                // For views, just use highest
                highestValue = allValues.length > 0 ? Math.max(...allValues.map(v => v.value)) : 0;
              }
              
              if (highestValue > 0) {
                if (!allVideosMap.has(videoId)) {
                  allVideosMap.set(videoId, { id: videoId });
                }
                allVideosMap.get(videoId)[metric] = highestValue;
              }
            } else {
              // For other metrics, use most recent non-empty value
              for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                const cellValue = row[colIdx];
                
                if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  
                  const video = allVideosMap.get(videoId);
                  if (video[metric] === undefined) {
                    video[metric] = cellValue;
                  }
                  break;
                }
              }
            }
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        // Get latest non-zero values after interpolation
        const followers = followersHistory.length > 0 ? 
          followersHistory[followersHistory.length - 1].value : 0;
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date || v.date).map(v => {
          const dateObj = new Date(v.Date || v.date);
          
          if (!this.isValidDate(dateObj)) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views || v.views) || 0,
            likes: parseInt(v.Likes || v.likes) || 0,
            comments: parseInt(v.Comments || v.comments) || 0,
            shares: parseInt(v.Shares || v.shares) || 0,
            engagement: parseFloat(v.EngagementRate || v.engagement) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: followers,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => item.value > 0),
          platform: 'youtube'
        };
      },
      // Parse TikTok data
      parseTikTokData(sheetName, timeRangeDays) {
        return this.parseTikTokDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse TikTok data from workbook
      parseTikTokDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName === 'total_likes') {
            totalLikesHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName.startsWith('post_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            if (metric === 'Date') {
              allUniqueVideoIds.add(videoId);
            }
            
            // For Views and Likes, use the HIGHEST value across all scrapes
            // (since they should never decrease - if they do, it's a scrape error)
            if (metric === 'Views' || metric === 'Likes') {
              let highestValue = 0;
              for (let colIdx = 1; colIdx < row.length; colIdx++) {
                const cellValue = parseInt(row[colIdx]) || 0;
                if (cellValue > highestValue) {
                  highestValue = cellValue;
                }
              }
              if (highestValue > 0) {
                if (!allVideosMap.has(videoId)) {
                  allVideosMap.set(videoId, { id: videoId });
                }
                allVideosMap.get(videoId)[metric] = highestValue;
              }
            } else {
              // For other metrics, use most recent non-empty value
              for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                const cellValue = row[colIdx];
                
                if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  
                  const video = allVideosMap.get(videoId);
                  if (video[metric] === undefined) {
                    video[metric] = cellValue;
                  }
                  break;
                }
              }
            }
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        // Get latest non-zero values after interpolation
        const followers = followersHistory.length > 0 ? 
          followersHistory[followersHistory.length - 1].value : 0;
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          // Use robust date parsing
          const dateObj = this.parseDate(v.Date);
          
          if (!dateObj) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: parseInt(v.Shares) || 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: followers,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => item.value > 0)
        };
      },
      
      // Parse Instagram data
      parseInstagramData(sheetName, timeRangeDays) {
        return this.parseInstagramDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse Instagram data from workbook
      parseInstagramDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName.startsWith('reel_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            const metricMapping = {
              'date': 'Date',
              'views': 'Views',
              'likes': 'Likes',
              'comments': 'Comments',
              'engagement': 'EngagementRate'
            };
            
            const mappedMetric = metricMapping[metric];
            
            if (metric === 'date') {
              allUniqueVideoIds.add(videoId);
            }
            
            if (metric === 'date_display') continue;
            
            if (mappedMetric) {
              // For views and likes, use the HIGHEST REALISTIC value across all scrapes
              // Filter out anomalies: likes â‰ˆ views, likes > views
              if (metric === 'views' || metric === 'likes') {
                let allValues = [];
                for (let colIdx = 1; colIdx < row.length; colIdx++) {
                  const cellValue = parseInt(row[colIdx]) || 0;
                  if (cellValue > 0) {
                    allValues.push({ colIdx, value: cellValue });
                  }
                }
                
                let highestValue = 0;
                
                if (metric === 'likes' && allValues.length > 0) {
                  // Get views for this video to detect anomalies
                  const viewsData = allVideosMap.get(videoId);
                  const videoViews = viewsData ? viewsData.Views : null;
                  
                  // Filter out anomalous likes
                  const realisticValues = allValues.filter(item => {
                    if (videoViews) {
                      // Reject if likes â‰ˆ views (extraction error)
                      if (Math.abs(item.value - videoViews) / videoViews < this.ANOMALY_THRESHOLDS.LIKES_VIEWS_RATIO) {
                        return false;
                      }
                      // Reject if likes > views
                      if (item.value > videoViews) {
                        return false;
                      }
                      // Reject if likes < threshold of views for significant views
                      if (videoViews > this.ANOMALY_THRESHOLDS.SIGNIFICANT_VIEWS && 
                          item.value < videoViews * this.ANOMALY_THRESHOLDS.MIN_LIKES_RATIO) {
                        return false;
                      }
                    }
                    return true;
                  });
                  
                  if (realisticValues.length > 0) {
                    highestValue = Math.max(...realisticValues.map(v => v.value));
                  } else if (allValues.length > 0) {
                    // All anomalous - use median
                    const sorted = allValues.map(v => v.value).sort((a, b) => a - b);
                    highestValue = sorted[Math.floor(sorted.length / 2)];
                  }
                } else {
                  highestValue = allValues.length > 0 ? Math.max(...allValues.map(v => v.value)) : 0;
                }
                
                if (highestValue > 0) {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  allVideosMap.get(videoId)[mappedMetric] = highestValue;
                }
              } else {
                // For date, comments, engagement - use most recent non-empty value
                for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                  const cellValue = row[colIdx];
                  
                  if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                    if (!allVideosMap.has(videoId)) {
                      allVideosMap.set(videoId, { id: videoId });
                    }
                    
                    const video = allVideosMap.get(videoId);
                    if (video[mappedMetric] === undefined) {
                      video[mappedMetric] = cellValue;
                    }
                    break;
                  }
                }
              }
            }
          }
        }
        
        // Calculate total likes history using only the most recent scrape data per post
        // First, build a map of video IDs to their likes rows
        const likesRowsMap = new Map();
        const viewsRowsMap = new Map();
        const postDatesMap = new Map();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_likes')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            likesRowsMap.set(videoId, row);
          }
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_views')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            viewsRowsMap.set(videoId, row);
          }
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_date')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            // Find the post date (most recent non-empty value)
            for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
              const cellValue = row[colIdx];
              if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                postDatesMap.set(videoId, new Date(cellValue));
                break;
              }
            }
          }
        }
        
        // Determine which scrape columns have actual post data (not just followers)
        // Early scrapes may only have follower data, which causes misaligned graphs
        const columnsWithPostData = new Set();
        for (let colIdx = 0; colIdx < headers.length; colIdx++) {
          // Check if any post has data in this column
          for (const [videoId, likesRow] of likesRowsMap) {
            if (colIdx + 1 < likesRow.length) {
              const value = parseInt(likesRow[colIdx + 1]) || 0;
              if (value > 0) {
                columnsWithPostData.add(colIdx);
                break;
              }
            }
          }
        }
        
        // For each scrape timestamp (column), calculate total likes using the HIGHEST value per post
        // (since likes should never decrease - if they do, it's a scrape error)
        for (let colIdx = 0; colIdx < headers.length; colIdx++) {
          const scrapeDate = new Date(headers[colIdx]);
          if (!this.isValidDate(scrapeDate)) continue;
          
          let columnTotalLikes = 0;
          
          // For each post, get the HIGHEST likes value up to this column
          for (const [videoId, likesRow] of likesRowsMap) {
            const postDate = postDatesMap.get(videoId);
            
            // Only include posts that existed by this scrape date
            if (postDate && postDate <= scrapeDate) {
              // Find the HIGHEST likes value for this post up to this column
              let highestLikes = 0;
              for (let prevColIdx = 0; prevColIdx <= colIdx; prevColIdx++) {
                // Check array bounds before accessing
                if (prevColIdx + 1 < likesRow.length) {
                  const value = parseInt(likesRow[prevColIdx + 1]) || 0;
                  if (value > highestLikes) {
                    highestLikes = value;
                  }
                }
              }
              columnTotalLikes += highestLikes;
            }
          }
          
          if (columnTotalLikes > 0) {
            totalLikesHistory.push({
              date: scrapeDate,
              value: columnTotalLikes
            });
          }
        }
        
        // NOTE: We no longer filter follower history based on post data availability
        // Early scrapes may only have follower counts without video data, but those
        // follower counts are still valid and should be included in the graph.
        // The key insight is that follower counts should never decrease, so we can
        // safely include all valid data points and rely on interpolation to handle gaps.
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        // Get latest non-zero values after interpolation
        const followers = followersHistory.length > 0 ? 
          followersHistory[followersHistory.length - 1].value : 0;
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          // Use robust date parsing to handle various formats
          const dateObj = this.parseDate(v.Date);
          
          if (!dateObj) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: followers,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => this.isValidDate(item.date) && item.value > 0)
        };
      },
      
      // Parse all MoonMedia accounts combined
      parseMoonMediaTotal(timeRangeDays) {
        const accounts = this.workbookData.SheetNames;
        let totalFollowers = 0;
        let totalLikes = 0;
        let totalPosts = 0;
        let allVideos = [];
        
        let followersByTimestamp = {};
        let likesByTimestamp = {};
        
        // Track highest known values for each account (followers should never decrease)
        let highestKnownFollowersByAccount = {};
        let lastKnownLikesByAccount = {};
        
        accounts.forEach(sheetName => {
          const data = this.parseAccountData(sheetName, timeRangeDays);
          totalFollowers += data.followers;
          totalLikes += data.totalLikes;
          totalPosts += data.postsScraped;
          allVideos = allVideos.concat(data.videos);
          
          // For followers, store per-account values to enable cumulative calculation
          data.followersHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!followersByTimestamp[dateKey]) {
              followersByTimestamp[dateKey] = { 
                date: item.date, 
                accountValues: {} 
              };
            }
            followersByTimestamp[dateKey].accountValues[sheetName] = item.value;
          });
          
          // For likes, store per-account values to enable cumulative calculation
          data.totalLikesHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!likesByTimestamp[dateKey]) {
              likesByTimestamp[dateKey] = { 
                date: item.date, 
                accountValues: {} 
              };
            }
            likesByTimestamp[dateKey].accountValues[sheetName] = item.value;
          });
        });
        
        const totalAccountCount = accounts.length;
        
        // Followers: include ALL timestamps, using highest known value for each account
        // Sort timestamps chronologically first
        const sortedFollowersTimestamps = Object.values(followersByTimestamp)
          .filter(item => this.isValidDate(item.date))
          .sort((a, b) => a.date - b.date);
        
        // Build cumulative total followers history using HIGHEST values
        // (since followers should never decrease - lower values are scrape errors)
        const followersHistory = [];
        accounts.forEach(acc => { highestKnownFollowersByAccount[acc] = 0; });
        
        // First pass: determine the highest value each account ever reaches
        sortedFollowersTimestamps.forEach(item => {
          Object.keys(item.accountValues).forEach(acc => {
            const newValue = item.accountValues[acc];
            if (newValue > highestKnownFollowersByAccount[acc]) {
              highestKnownFollowersByAccount[acc] = newValue;
            }
          });
        });
        
        // Reset for second pass
        const currentFollowersByAccount = {};
        accounts.forEach(acc => { currentFollowersByAccount[acc] = 0; });
        
        // Second pass: build history using highest value seen UP TO each timestamp
        sortedFollowersTimestamps.forEach(item => {
          // Update current values for accounts that have data at this timestamp
          // Only update if the new value is higher (followers shouldn't decrease)
          Object.keys(item.accountValues).forEach(acc => {
            const newValue = item.accountValues[acc];
            if (newValue > currentFollowersByAccount[acc]) {
              currentFollowersByAccount[acc] = newValue;
            }
          });
          
          // Sum all current values
          const cumulativeTotal = Object.values(currentFollowersByAccount).reduce((sum, val) => sum + val, 0);
          
          // Only add if we have a meaningful total and at least some accounts have data
          const accountsWithData = Object.values(currentFollowersByAccount).filter(v => v > 0).length;
          
          if (cumulativeTotal > 0 && accountsWithData > 0) {
            // Check if this is significantly different from the last entry to avoid duplicates
            const lastEntry = followersHistory[followersHistory.length - 1];
            if (!lastEntry || lastEntry.value !== cumulativeTotal) {
              followersHistory.push({
                date: item.date,
                value: cumulativeTotal
              });
            }
          }
        });
        
        // Total Likes: include ALL timestamps, using last known value for missing accounts
        // Sort timestamps chronologically first
        const sortedLikesTimestamps = Object.values(likesByTimestamp)
          .filter(item => this.isValidDate(item.date))
          .sort((a, b) => a.date - b.date);
        
        // Build cumulative total likes history
        const totalLikesHistory = [];
        accounts.forEach(acc => { lastKnownLikesByAccount[acc] = 0; });
        
        sortedLikesTimestamps.forEach(item => {
          // Update last known values for accounts that have data at this timestamp
          Object.keys(item.accountValues).forEach(acc => {
            lastKnownLikesByAccount[acc] = item.accountValues[acc];
          });
          
          // Sum all last known values (ensures cumulative behavior)
          const cumulativeTotal = Object.values(lastKnownLikesByAccount).reduce((sum, val) => sum + val, 0);
          
          if (cumulativeTotal > 0) {
            totalLikesHistory.push({
              date: item.date,
              value: cumulativeTotal
            });
          }
        });
        
        allVideos.sort((a, b) => a.date - b.date);
        
        let totalViews = allVideos.reduce((sum, v) => sum + v.views, 0);
        let viewsPerSecond = 0;
        
        const last100Posts = allVideos.slice(-100);
        if (last100Posts.length >= 2) {
          const oldestPost = last100Posts[0];
          const newestPost = last100Posts[last100Posts.length - 1];
          const totalViewsInPeriod = last100Posts.reduce((sum, v) => sum + v.views, 0);
          const timeSpanSeconds = (newestPost.date - oldestPost.date) / 1000;
          
          if (timeSpanSeconds > 0) {
            viewsPerSecond = totalViewsInPeriod / timeSpanSeconds;
          }
        }
        
        return {
          followers: totalFollowers,
          totalLikes: totalLikes,
          postsScraped: totalPosts,
          videos: allVideos,
          followersHistory: followersHistory,
          totalLikesHistory: totalLikesHistory,
          totalViews: totalViews,
          viewsPerSecond: viewsPerSecond,
          accountCount: accounts.length
        };
      },
      
      // Utility functions
      isValidDate(date) {
        if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
          return false;
        }
        const year = date.getFullYear();
        const currentYear = new Date().getFullYear();
        return year >= 2020 && year <= currentYear + 1;
      },
      
      // Robust date parsing that handles various date formats from Excel/scrapers
      parseDate(dateValue) {
        if (!dateValue) return null;
        
        // If it's already a valid Date object
        if (dateValue instanceof Date && !isNaN(dateValue.getTime())) {
          return this.isValidDate(dateValue) ? dateValue : null;
        }
        
        // Handle Excel serial date numbers (days since 1900-01-01)
        if (typeof dateValue === 'number') {
          // Excel serial date conversion
          const excelEpoch = new Date(1899, 11, 30); // Excel epoch
          const millisecondsPerDay = 24 * 60 * 60 * 1000;
          const date = new Date(excelEpoch.getTime() + (dateValue * millisecondsPerDay));
          return this.isValidDate(date) ? date : null;
        }
        
        // Handle string formats
        if (typeof dateValue === 'string') {
          dateValue = dateValue.trim();
          
          // Try ISO format first (most common from scrapers: 2024-01-15T12:00:00)
          let date = new Date(dateValue);
          if (this.isValidDate(date)) return date;
          
          // Try YYYY-MM-DD format
          const isoMatch = dateValue.match(/^(\d{4})-(\d{2})-(\d{2})/);
          if (isoMatch) {
            date = new Date(parseInt(isoMatch[1]), parseInt(isoMatch[2]) - 1, parseInt(isoMatch[3]));
            if (this.isValidDate(date)) return date;
          }
          
          // Try MM/DD/YYYY format
          const usMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
          if (usMatch) {
            date = new Date(parseInt(usMatch[3]), parseInt(usMatch[1]) - 1, parseInt(usMatch[2]));
            if (this.isValidDate(date)) return date;
          }
          
          // Try DD/MM/YYYY format (European)
          const euMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
          if (euMatch) {
            // Try European format (day first)
            date = new Date(parseInt(euMatch[3]), parseInt(euMatch[2]) - 1, parseInt(euMatch[1]));
            if (this.isValidDate(date)) return date;
          }
          
          // Try "Month DD, YYYY" format (e.g., "January 15, 2024")
          const monthNameMatch = dateValue.match(/^([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})/);
          if (monthNameMatch) {
            const monthNames = ['january', 'february', 'march', 'april', 'may', 'june', 
                               'july', 'august', 'september', 'october', 'november', 'december'];
            const monthIdx = monthNames.indexOf(monthNameMatch[1].toLowerCase());
            if (monthIdx !== -1) {
              date = new Date(parseInt(monthNameMatch[3]), monthIdx, parseInt(monthNameMatch[2]));
              if (this.isValidDate(date)) return date;
            }
          }
          
          // Try "DD Mon YYYY" format (e.g., "15 Jan 2024")
          const shortMonthMatch = dateValue.match(/^(\d{1,2})\s+([A-Za-z]{3,})\s+(\d{4})/);
          if (shortMonthMatch) {
            const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 
                               'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            const monthIdx = monthNames.findIndex(m => shortMonthMatch[2].toLowerCase().startsWith(m));
            if (monthIdx !== -1) {
              date = new Date(parseInt(shortMonthMatch[3]), monthIdx, parseInt(shortMonthMatch[1]));
              if (this.isValidDate(date)) return date;
            }
          }
        }
        
        return null;
      },
      
      filterDataByTimeRange(videos, timeRangeDays) {
        if (timeRangeDays === 'all') return videos;
        
        // Handle custom date range
        if (timeRangeDays === 'custom') {
          if (this.customStartDate && this.customEndDate) {
            return videos.filter(v => v.date >= this.customStartDate && v.date <= this.customEndDate);
          }
          return videos;
        }
        
        // Create cutoff date using milliseconds (more robust than setDate for month/year boundaries)
        const daysInMs = timeRangeDays * 24 * 60 * 60 * 1000;
        const cutoffDate = new Date(Date.now() - daysInMs);
        
        return videos.filter(v => v.date >= cutoffDate);
      },
      
      interpolateHistoricalData(historyArray) {
        if (historyArray.length === 0) return historyArray;
        
        // First pass: mark items that need interpolation (0, null, undefined, or abnormal drops)
        const interpolated = historyArray.map((item, idx, arr) => {
          let needsInterp = item.value === 0 || item.value === null || item.value === undefined;
          
          // Also check for abnormal drops (50%+ drop from previous valid value)
          if (!needsInterp && idx > 0) {
            // Find the previous valid value
            let prevValidValue = null;
            for (let j = idx - 1; j >= 0; j--) {
              const prevVal = arr[j].value;
              if (prevVal > 0 && prevVal !== null && prevVal !== undefined) {
                prevValidValue = prevVal;
                break;
              }
            }
            
            // If there's a 50%+ drop, consider it invalid
            if (prevValidValue !== null && item.value < prevValidValue * 0.5) {
              needsInterp = true;
            }
          }
          
          return {
            ...item,
            index: idx,
            needsInterp: needsInterp
          };
        });
        
        let i = 0;
        while (i < interpolated.length) {
          if (!interpolated[i].needsInterp) {
            i++;
            continue;
          }
          
          let groupStart = i;
          let groupEnd = i;
          while (groupEnd < interpolated.length && interpolated[groupEnd].needsInterp) {
            groupEnd++;
          }
          groupEnd--;
          
          let prevValue = null;
          for (let j = groupStart - 1; j >= 0; j--) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              prevValue = interpolated[j].value;
              break;
            }
          }
          
          let nextValue = null;
          for (let j = groupEnd + 1; j < interpolated.length; j++) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              nextValue = interpolated[j].value;
              break;
            }
          }
          
          if (prevValue !== null && nextValue !== null) {
            const groupSize = groupEnd - groupStart + 1;
            const totalSteps = groupSize + 1;
            
            for (let j = groupStart; j <= groupEnd; j++) {
              const stepNumber = j - groupStart + 1;
              const interpolatedValue = prevValue + ((nextValue - prevValue) * stepNumber / totalSteps);
              interpolated[j].value = Math.round(interpolatedValue);
            }
          } else if (prevValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = prevValue;
            }
          } else if (nextValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = nextValue;
            }
          }
          
          i = groupEnd + 1;
        }
        
        return interpolated.map(item => ({
          date: item.date,
          value: item.value
        }));
      },
      
      shouldUseLogScale(data) {
        if (data.length === 0) return false;
        
        const values = data.filter(v => v > 0);
        if (values.length === 0) return false;
        
        const max = Math.max(...values);
        const min = Math.min(...values);
        const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
        
        const ratio = max / min;
        const medianRatio = max / median;
        
        return ratio > 100 || medianRatio > 10;
      },
      
      formatNumber(num) {
        if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
        if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        return num.toLocaleString();
      },
      
      formatNumberAxisSmart(value, dataRange) {
        const range = dataRange.max - dataRange.min;
        
        if (value >= 1000000000) {
          const val = value / 1000000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'B';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'B';
          return val.toFixed(1) + 'B';
        }
        if (value >= 1000000) {
          const val = value / 1000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'M';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'M';
          return val.toFixed(1) + 'M';
        }
        if (value >= 1000) {
          const val = value / 1000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(2) + 'K';
          return val.toFixed(1) + 'K';
        }
        return value.toLocaleString();
      },
      
      calculateMovingAverageByDays(data, days = 7) {
        const result = [];
        const halfWindow = Math.floor(days / 2);
        
        for (let i = 0; i < data.length; i++) {
          const currentDate = new Date(data[i].x);
          const startDate = new Date(currentDate);
          const endDate = new Date(currentDate);
          
          startDate.setDate(startDate.getDate() - halfWindow);
          endDate.setDate(endDate.getDate() + (days - halfWindow));
          
          const windowPoints = [];
          for (let j = 0; j < data.length; j++) {
            const pointDate = new Date(data[j].x);
            if (pointDate >= startDate && pointDate <= endDate) {
              windowPoints.push(data[j].y);
            }
          }
          
          if (windowPoints.length > 0) {
            const sum = windowPoints.reduce((acc, val) => acc + val, 0);
            const avg = sum / windowPoints.length;
            result.push({ x: data[i].x, y: avg });
          } else {
            result.push({ x: data[i].x, y: data[i].y });
          }
        }
        
        return result;
      },
      
      // Calculate cumulative data from video data
      calculateCumulativeData(data, historicalSum = 0) {
        if (!data || data.length === 0) return [];
        
        // Sort by date first
        const sortedData = [...data].sort((a, b) => new Date(a.x) - new Date(b.x));
        
        // Start cumulative from historical sum (all data before the selected time range)
        let cumulative = historicalSum;
        return sortedData.map(point => {
          cumulative += point.y;
          return { x: point.x, y: cumulative };
        });
      },
      
      // Calculate the sum of a metric for all videos before a given date
      calculateHistoricalSum(allVideos, metricKey, startDate) {
        if (!allVideos || allVideos.length === 0 || !startDate) return 0;
        
        return allVideos
          .filter(v => v.date && new Date(v.date) < new Date(startDate))
          .reduce((sum, v) => sum + (v[metricKey] || 0), 0);
      },
      
      // Get the start date for the current time range filter
      getTimeRangeStartDate() {
        if (this.selectedTimeRange === 'all') return null;
        
        if (this.selectedTimeRange === 'custom') {
          return this.customStartDate;
        }
        
        // For preset time ranges (30, 180, 365 days)
        const daysInMs = this.selectedTimeRange * 24 * 60 * 60 * 1000;
        return new Date(Date.now() - daysInMs);
      },
      
      // Calculate smoothed curve for cumulative data using exponential smoothing
      calculateSmoothedCurve(data, smoothnessLevel = this.SMOOTHNESS.DEFAULT_LEVEL) {
        if (!data || data.length === 0) return [];
        
        // Smoothness level: MIN_LEVEL = most responsive, MAX_LEVEL = smoothest
        // Alpha ranges from MAX_ALPHA (responsive) to MIN_ALPHA (smooth)
        const levelRange = this.SMOOTHNESS.MAX_LEVEL - this.SMOOTHNESS.MIN_LEVEL;
        const alpha = this.SMOOTHNESS.MAX_ALPHA - ((smoothnessLevel - this.SMOOTHNESS.MIN_LEVEL) / levelRange) * this.SMOOTHNESS.ALPHA_RANGE;
        
        const result = [];
        let smoothedValue = data[0].y;
        
        for (let i = 0; i < data.length; i++) {
          if (i === 0) {
            result.push({ x: data[i].x, y: data[i].y });
          } else {
            smoothedValue = alpha * data[i].y + (1 - alpha) * smoothedValue;
            result.push({ x: data[i].x, y: smoothedValue });
          }
        }
        
        return result;
      },
      
      // Toggle between Average and Cumulative modes
      toggleChartMode(chartId, metricKey) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        // Toggle mode state
        const currentMode = this.chartModeStates[chartId] || 'average';
        const newMode = currentMode === 'average' ? 'cumulative' : 'average';
        this.chartModeStates[chartId] = newMode;
        
        // Get the filtered video data (currently displayed)
        const videos = this.isAllPlatforms ? 
          [...(this.allPlatformsData.instagram?.videos || []), 
           ...(this.allPlatformsData.tiktok?.videos || []),
           ...(this.allPlatformsData.youtube?.videos || [])] :
          this.accountData.videos;
        
        if (!videos || videos.length === 0) return;
        
        // Recalculate data based on mode
        let newData;
        if (newMode === 'cumulative') {
          const rawData = videos.map(v => ({ x: v.date, y: v[metricKey] }));
          
          // Calculate historical sum (all data before the selected time range)
          const startDate = this.getTimeRangeStartDate();
          let historicalSum = 0;
          
          if (startDate) {
            // Get all unfiltered videos
            const allVideos = this.isAllPlatforms ?
              [...(this.allPlatformsData.instagram?.videos || []),
               ...(this.allPlatformsData.tiktok?.videos || []),
               ...(this.allPlatformsData.youtube?.videos || [])] :
              (this.allVideosUnfiltered || []);
            
            historicalSum = this.calculateHistoricalSum(allVideos, metricKey, startDate);
          }
          
          newData = this.calculateCumulativeData(rawData, historicalSum);
        } else {
          newData = videos.map(v => ({ x: v.date, y: v[metricKey] }));
        }
        
        // Update main dataset
        const mainDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
        if (mainDataset) {
          mainDataset.data = newData;
        }
        
        // Update trendline if visible
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset && this.trendlineStates[chartId]) {
          if (newMode === 'cumulative') {
            // Use smoothed curve for cumulative mode
            const smoothnessLevel = this.trendlineSmoothnessLevel[chartId] || this.SMOOTHNESS.DEFAULT_LEVEL;
            trendlineDataset.data = this.calculateSmoothedCurve(newData, smoothnessLevel);
          } else {
            // Use moving average for average mode
            const days = this.trendlineDaysAverage[chartId] || 7;
            trendlineDataset.data = this.calculateMovingAverageByDays(newData, days);
          }
        }
        
        chart.update();
        
        // Update mode badge
        const badge = document.querySelector(`[data-mode-id="${chartId}"]`);
        if (badge) {
          if (newMode === 'cumulative') {
            badge.classList.add('cumulative');
            badge.textContent = 'CUMULATIVE';
          } else {
            badge.classList.remove('cumulative');
            badge.textContent = 'AVERAGE';
          }
        }
        
        // Update smoothness controls visibility - show for cumulative, hide for average
        const smoothnessControls = document.querySelector(`[data-smoothness-controls="${chartId}"]`);
        const daysDisplay = document.querySelector(`[data-days-display="${chartId}"]`);
        if (smoothnessControls && this.trendlineStates[chartId]) {
          if (newMode === 'cumulative') {
            // Switch to smoothness level display
            if (daysDisplay) {
              daysDisplay.textContent = this.trendlineSmoothnessLevel[chartId] || 5;
            }
          } else {
            // Switch to days display
            if (daysDisplay) {
              daysDisplay.textContent = this.trendlineDaysAverage[chartId] || 7;
            }
          }
        }
      },
      
      // Chart manipulation functions
      toggleLogScale(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const currentType = chart.options.scales.y.type;
        const newType = currentType === 'logarithmic' ? 'linear' : 'logarithmic';
        
        chart.options.scales.y.type = newType;
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.type = newType;
        }
        
        if (chartId === 'correlation' && chart.options.scales.x) {
          chart.options.scales.x.type = newType;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-chart-id="${chartId}"]`);
        if (badge) {
          if (newType === 'logarithmic') {
            badge.classList.remove('inactive');
            badge.textContent = 'LOG SCALE';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'LINEAR';
          }
        }
      },
      
      toggleTrendline(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        this.trendlineStates[chartId] = !this.trendlineStates[chartId];
        const showTrendline = this.trendlineStates[chartId];
        
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset) {
          trendlineDataset.hidden = !showTrendline;
          
          // When enabling the trendline, recalculate it based on the current mode
          if (showTrendline) {
            const currentMode = this.chartModeStates[chartId] || 'average';
            const mainDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
            
            if (mainDataset && mainDataset.data) {
              if (currentMode === 'cumulative') {
                // Use smoothed curve for cumulative mode
                const smoothnessLevel = this.trendlineSmoothnessLevel[chartId] || this.SMOOTHNESS.DEFAULT_LEVEL;
                trendlineDataset.data = this.calculateSmoothedCurve(mainDataset.data, smoothnessLevel);
              } else {
                // Use moving average for average mode
                const days = this.trendlineDaysAverage[chartId] || 7;
                trendlineDataset.data = this.calculateMovingAverageByDays(mainDataset.data, days);
              }
            }
          }
        }
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.display = showTrendline;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-trendline-id="${chartId}"]`);
        if (badge) {
          if (showTrendline) {
            badge.classList.remove('inactive');
            badge.textContent = 'TREND ON';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'TREND OFF';
          }
        }
        
        const controls = document.querySelector(`[data-smoothness-controls="${chartId}"]`);
        if (controls) {
          controls.style.display = showTrendline ? 'inline-block' : 'none';
        }
        
        // Update the smoothness/days display based on current mode
        const daysDisplay = document.querySelector(`[data-days-display="${chartId}"]`);
        if (daysDisplay && showTrendline) {
          const currentMode = this.chartModeStates[chartId] || 'average';
          if (currentMode === 'cumulative') {
            daysDisplay.textContent = this.trendlineSmoothnessLevel[chartId] || this.SMOOTHNESS.DEFAULT_LEVEL;
          } else {
            daysDisplay.textContent = this.trendlineDaysAverage[chartId] || 7;
          }
        }
      },
      
      adjustTrendlineSmoothness(chartId, direction) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const currentMode = this.chartModeStates[chartId] || 'average';
        
        if (currentMode === 'cumulative') {
          // Adjust smoothness level for cumulative mode
          if (this.trendlineSmoothnessLevel[chartId] === undefined) {
            this.trendlineSmoothnessLevel[chartId] = this.SMOOTHNESS.DEFAULT_LEVEL;
          }
          
          this.trendlineSmoothnessLevel[chartId] += direction;
          this.trendlineSmoothnessLevel[chartId] = Math.max(
            this.SMOOTHNESS.MIN_LEVEL, 
            Math.min(this.SMOOTHNESS.MAX_LEVEL, this.trendlineSmoothnessLevel[chartId])
          );
          
          const dataDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
          if (!dataDataset) return;
          
          const trendlineData = this.calculateSmoothedCurve(
            dataDataset.data, 
            this.trendlineSmoothnessLevel[chartId]
          );
          
          const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
          if (trendlineDataset) {
            trendlineDataset.data = trendlineData;
          }
          
          chart.update();
          
          const display = document.querySelector(`[data-days-display="${chartId}"]`);
          if (display) {
            display.textContent = this.trendlineSmoothnessLevel[chartId];
          }
        } else {
          // Adjust days for average mode
          if (this.trendlineDaysAverage[chartId] === undefined) {
            this.trendlineDaysAverage[chartId] = 7;
          }
          
          this.trendlineDaysAverage[chartId] += direction;
          this.trendlineDaysAverage[chartId] = Math.max(1, this.trendlineDaysAverage[chartId]);
          
          const dataDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
          if (!dataDataset) return;
          
          const trendlineData = this.calculateMovingAverageByDays(
            dataDataset.data, 
            this.trendlineDaysAverage[chartId]
          );
          
          const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
          if (trendlineDataset) {
            trendlineDataset.data = trendlineData;
          }
          
          chart.update();
          
          const display = document.querySelector(`[data-days-display="${chartId}"]`);
          if (display) {
            display.textContent = this.trendlineDaysAverage[chartId];
          }
        }
      },
      
      exportChart(chartId, title) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const canvas = chart.canvas;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + 80;
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCtx.fillStyle = '#000000';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        tempCtx.fillStyle = '#ffffff';
        tempCtx.font = 'bold 24px monospace';
        tempCtx.textAlign = 'center';
        tempCtx.fillText(title, tempCanvas.width / 2, 35);
        
        tempCtx.font = '16px monospace';
        let accountText = '';
        if (this.isAllPlatforms) {
          accountText = 'All MoonMedia Platforms';
        } else if (this.isMoonMediaTotal) {
          accountText = 'All MoonMedia';
        } else {
          accountText = '@' + this.selectedAccount;
        }
        
        let rangeText = '';
        if (this.selectedTimeRange === 'all') rangeText = '(All Time)';
        else if (this.selectedTimeRange === 365) rangeText = '(Last 1 Year)';
        else if (this.selectedTimeRange === 180) rangeText = '(Last 6 Months)';
        else if (this.selectedTimeRange === 30) rangeText = '(Last 1 Month)';
        
        tempCtx.fillText(`${accountText} ${rangeText}`, tempCanvas.width / 2, 60);
        
        tempCtx.drawImage(canvas, 0, 80);
        
        const link = document.createElement('a');
        const platformSuffix = this.isAllPlatforms ? 'all_platforms' : this.selectedPlatform;
        link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${accountText.replace('@', '')}_${platformSuffix}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      },
      // Chart creation functions continued
      createLineChart(container, title, historyData, datasets, useLog, chartId) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allValues = datasets.flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'day',
                  displayFormats: { day: 'MMM d, yyyy' }
                },
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLog ? 'logarithmic' : 'linear',
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRange);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      createTimeBasedChart(container, title, videos, datasets, useLog, chartId, includeTrendline = false, metricKey = null) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        // Add mode toggle for time-series charts with metric data
        if (metricKey && includeTrendline) {
          const modeBadge = document.createElement('span');
          modeBadge.className = 'mode-toggle-badge';
          modeBadge.textContent = 'AVERAGE';
          modeBadge.setAttribute('data-mode-id', chartId);
          modeBadge.onclick = () => this.toggleChartMode(chartId, metricKey);
          header.appendChild(modeBadge);
          
          // Initialize mode state and store metricKey for later use
          this.chartModeStates[chartId] = 'average';
          this.chartMetricKeys[chartId] = metricKey;
          this.trendlineSmoothnessLevel[chartId] = this.SMOOTHNESS.DEFAULT_LEVEL;
        }
        
        if (includeTrendline) {
          const trendlineBadge = document.createElement('span');
          trendlineBadge.className = 'trendline-badge inactive';
          trendlineBadge.textContent = 'TREND OFF';
          trendlineBadge.setAttribute('data-trendline-id', chartId);
          trendlineBadge.onclick = () => this.toggleTrendline(chartId);
          header.appendChild(trendlineBadge);
          
          this.trendlineStates[chartId] = false;
          this.trendlineDaysAverage[chartId] = 7;
          
          const smoothnessControls = document.createElement('span');
          smoothnessControls.className = 'smoothness-controls';
          smoothnessControls.setAttribute('data-smoothness-controls', chartId);
          smoothnessControls.style.display = 'none';
          
          const downBtn = document.createElement('button');
          downBtn.className = 'smoothness-btn';
          downBtn.textContent = 'â—„';
          downBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, -1);
          
          const daysDisplay = document.createElement('span');
          daysDisplay.className = 'smoothness-btn';
          daysDisplay.textContent = '7';
          daysDisplay.style.cursor = 'default';
          daysDisplay.setAttribute('data-days-display', chartId);
          
          const upBtn = document.createElement('button');
          upBtn.className = 'smoothness-btn';
          upBtn.textContent = 'â–º';
          upBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, 1);
          
          smoothnessControls.appendChild(downBtn);
          smoothnessControls.appendChild(daysDisplay);
          smoothnessControls.appendChild(upBtn);
          
          header.appendChild(smoothnessControls);
        }
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        // Ensure scatter plot is behind trendline
        datasets[0].order = 1;
        
        if (includeTrendline && datasets.length > 0) {
          const trendlineData = this.calculateMovingAverageByDays(datasets[0].data, 7);
          
          datasets.push({
            label: 'Trend',
            data: trendlineData,
            type: 'line',
            borderColor: '#ffff00',
            backgroundColor: 'transparent',
            borderWidth: 3,
            pointRadius: 0,
            tension: 0.4,
            yAxisID: 'y1',
            hidden: true,
            order: -1  // Trendline on top
          });
        }
        
        const allValues = datasets.filter(ds => ds.label !== 'Trend')
          .flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        const scales = {
          x: {
            type: 'time',
            time: {
              unit: 'day',
              displayFormats: { day: 'MMM d, yyyy' }
            },
            ticks: { color: '#0f0', font: { family: 'monospace' } },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          },
          y: {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'left',
            ticks: {
              color: '#0f0',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          }
        };
        
        if (includeTrendline) {
          scales.y1 = {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'right',
            display: false,
            ticks: {
              color: '#ffff00',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: {
              drawOnChartArea: false
            }
          };
        }
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: datasets[0].type || 'scatter',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 },
                  filter: (item) => {
                    if (item.text === 'Trend') {
                      return this.trendlineStates[chartId] === true;
                    }
                    return true;
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              },
              datalabels: {
                display: false  // Disable grey text labels on data points
              }
            },
            scales: scales
          }
        });
      },
      
      createCorrelationChart(container) {
        const correlationValues = this.accountData.videos.map(v => v.views);
        const useLogCorrelation = this.shouldUseLogScale(correlationValues);
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'correlation';
        
        const header = document.createElement('h3');
        header.textContent = 'Likes vs Views Correlation';
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLogCorrelation ? '' : ' inactive');
        scaleBadge.textContent = useLogCorrelation ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', 'correlation');
        scaleBadge.onclick = () => this.toggleLogScale('correlation');
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart('correlation', 'Likes vs Views Correlation');
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allViews = this.accountData.videos.map(v => v.views).filter(v => v > 0);
        const allLikes = this.accountData.videos.map(v => v.likes).filter(v => v > 0);
        const dataRangeX = {
          min: Math.min(...allViews),
          max: Math.max(...allViews)
        };
        const dataRangeY = {
          min: Math.min(...allLikes),
          max: Math.max(...allLikes)
        };
        
        this.chartInstances['correlation'] = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [{
              label: 'Posts',
              data: this.accountData.videos.map(v => ({ x: v.views, y: v.likes })),
              backgroundColor: 'rgba(0, 210, 211, 0.6)',
              borderColor: '#00d2d3',
              pointRadius: 6,
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return 'Views: ' + this.formatNumber(context.parsed.x) + 
                           ', Likes: ' + this.formatNumber(context.parsed.y);
                  }
                }
              },
              datalabels: {
                display: false  // Disable grey text labels on data points
              }
            },
            scales: {
              x: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Views',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeX);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Likes',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeY);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Main dashboard rendering
      renderDashboard() {
        // Reset chart instances
        this.chartInstances = {};
        this.trendlineStates = {};
        this.trendlineDaysAverage = {};
        this.chartModeStates = {};
        this.chartMetricKeys = {};
        this.trendlineSmoothnessLevel = {};
        
        const statsContainer = document.getElementById('statsSummary');
        const chartsContainer = document.getElementById('chartsList');
        chartsContainer.innerHTML = '';
        
        // Determine content type based on platform
        let contentType = 'POSTS';
        if (this.selectedPlatform === 'instagram') contentType = 'REELS';
        else if (this.selectedPlatform === 'youtube') contentType = 'SHORTS';
        
        // Render summary statistics
        let statsHTML = `
          <div class="stat-card">
            <h4>FOLLOWERS</h4>
            <div class="value">${this.formatNumber(this.accountData.followers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(this.accountData.totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>${contentType} TRACKED</h4>
            <div class="value">${this.accountData.postsScraped}</div>
          </div>
          <div class="stat-card">
            <h4>AVG ENGAGEMENT</h4>
            <div class="value">${this.accountData.videos.length > 0 ? 
              (this.accountData.videos.reduce((sum, v) => sum + v.engagement, 0) / 
               this.accountData.videos.length).toFixed(2) : 0}%</div>
          </div>
        `;
        
        if (this.isMoonMediaTotal) {
          statsHTML += `
            <div class="stat-card">
              <h4>TOTAL VIEWS</h4>
              <div class="value">${this.formatNumber(this.accountData.totalViews)}</div>
            </div>
            <div class="stat-card">
              <h4>VIEWS PER SECOND</h4>
              <div class="value">${this.accountData.viewsPerSecond.toFixed(2)}</div>
            </div>
            <div class="stat-card">
              <h4>TOTAL ACCOUNTS</h4>
              <div class="value">${this.accountData.accountCount}</div>
            </div>
          `;
        }
        
        statsContainer.innerHTML = statsHTML;
        
        // Create charts
        // Followers Over Time (first chart)
        if (this.accountData.followersHistory && this.accountData.followersHistory.length > 0) {
          const followerValues = this.accountData.followersHistory.map(h => h.value);
          const useLogFollowers = this.shouldUseLogScale(followerValues);
          
          this.createLineChart(chartsContainer, 'Followers Over Time', 
            this.accountData.followersHistory,
            [{
              label: 'Followers',
              data: this.accountData.followersHistory.map(h => ({ x: h.date, y: h.value })),
              borderColor: '#9b59b6',
              backgroundColor: 'rgba(155, 89, 182, 0.1)',
              borderWidth: 3,
              tension: 0.4,
              fill: true
            }],
            useLogFollowers,
            'followers-history'
          );
        }
        
        // NOTE: "Total Likes Growth" chart has been removed per requirements
        
        if (this.accountData.videos.length > 0) {
          const viewsData = this.accountData.videos.map(v => v.views);
          const likesData = this.accountData.videos.map(v => v.likes);
          const useLogViews = this.shouldUseLogScale(viewsData);
          const useLogLikes = this.shouldUseLogScale(likesData);
          
          // Likes Over Time - with mode toggle
          this.createTimeBasedChart(chartsContainer, 'Likes Over Time',
            this.accountData.videos,
            [{
              label: 'Likes',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.likes })),
              borderColor: '#ff6b6b',
              backgroundColor: 'rgba(255, 107, 107, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogLikes,
            'likes-time',
            true,
            'likes'
          );
          
          // Views Over Time - with mode toggle
          this.createTimeBasedChart(chartsContainer, 'Views Over Time',
            this.accountData.videos,
            [{
              label: 'Views',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.views })),
              borderColor: '#00d2d3',
              backgroundColor: 'rgba(0, 210, 211, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogViews,
            'views-time',
            true,
            'views'
          );
          
          // Comments Over Time - with mode toggle
          const commentsData = this.accountData.videos.map(v => v.comments);
          const useLogComments = this.shouldUseLogScale(commentsData);
          
          this.createTimeBasedChart(chartsContainer, 'Comments Over Time',
            this.accountData.videos,
            [{
              label: 'Comments',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.comments })),
              borderColor: '#1abc9c',
              backgroundColor: 'rgba(26, 188, 156, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogComments,
            'comments-time',
            true,
            'comments'
          );
          
          // Shares Over Time (TikTok only) - with mode toggle
          if (this.selectedPlatform === 'tiktok') {
            const sharesData = this.accountData.videos.map(v => v.shares);
            const useLogShares = this.shouldUseLogScale(sharesData);
            
            this.createTimeBasedChart(chartsContainer, 'Shares Over Time',
              this.accountData.videos,
              [{
                label: 'Shares',
                data: this.accountData.videos.map(v => ({ x: v.date, y: v.shares })),
                borderColor: '#e74c3c',
                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                pointRadius: 4,
                pointHoverRadius: 6
              }],
              useLogShares,
              'shares-time',
              true,
              'shares'
            );
          }
          
          // Engagement Rate Over Time (no mode toggle - doesn't make sense for cumulative)
          this.createTimeBasedChart(chartsContainer, 'Engagement Rate Over Time',
            this.accountData.videos,
            [{
              label: 'Engagement %',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.engagement })),
              borderColor: '#2ecc71',
              backgroundColor: 'rgba(46, 204, 113, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            false,
            'engagement-time',
            true
          );
          
          // Create correlation chart
          this.createCorrelationChart(chartsContainer);
        }
      },
      
      // Render all platforms dashboard
      renderAllPlatformsDashboard() {
        // Reset chart instances
        this.chartInstances = {};
        this.trendlineStates = {};
        this.trendlineDaysAverage = {};
        this.chartModeStates = {};
        this.chartMetricKeys = {};
        this.trendlineSmoothnessLevel = {};
        
        const statsContainer = document.getElementById('statsSummary');
        const platformBreakdown = document.getElementById('platformBreakdown');
        const chartsContainer = document.getElementById('chartsList');
        
        platformBreakdown.classList.remove('hidden');
        chartsContainer.innerHTML = '';
        
        // Combined statistics
        const combined = this.allPlatformsData.combined;
        
        // Calculate total comments across all platforms
        const allVideos = [
          ...(this.allPlatformsData.instagram?.videos || []),
          ...(this.allPlatformsData.tiktok?.videos || []),
          ...(this.allPlatformsData.youtube?.videos || [])
        ];
        const totalComments = allVideos.reduce((sum, v) => sum + (v.comments || 0), 0);
        
        // Calculate average engagement
        const avgEngagement = allVideos.length > 0 ? 
          allVideos.reduce((sum, v) => sum + (v.engagement || 0), 0) / allVideos.length : 0;
        
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>FOLLOWERS/SUBS</h4>
            <div class="value">${this.formatNumber(combined.totalFollowers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(combined.totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL VIEWS</h4>
            <div class="value">${this.formatNumber(combined.totalViews)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL COMMENTS</h4>
            <div class="value">${this.formatNumber(totalComments)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL POSTS</h4>
            <div class="value">${combined.totalPosts}</div>
          </div>
          <div class="stat-card">
            <h4>VIEWS PER SECOND</h4>
            <div class="value">${combined.viewsPerSecond.toFixed(2)}</div>
          </div>
          <div class="stat-card">
            <h4>AVG ENGAGEMENT</h4>
            <div class="value">${avgEngagement.toFixed(2)}%</div>
          </div>
          <div class="stat-card">
            <h4>PLATFORMS</h4>
            <div class="value">3</div>
          </div>
        `;
        
        // Platform breakdown - use appropriate terminology for each platform
        let breakdownHTML = '<h3 style="color: #ffff00;">Platform Breakdown</h3><div class="stats-summary">';
        
        const platforms = [
          { key: 'instagram', name: 'Instagram', followerTerm: 'Followers' },
          { key: 'tiktok', name: 'TikTok', followerTerm: 'Followers' },
          { key: 'youtube', name: 'YouTube', followerTerm: 'Subscribers' }
        ];
        
        platforms.forEach(platform => {
          const data = this.allPlatformsData[platform.key];
          if (data) {
            breakdownHTML += `
              <div class="platform-stats">
                <h3>${platform.name}</h3>
                <div>${platform.followerTerm}: ${this.formatNumber(data.followers)}</div>
                <div>Likes: ${this.formatNumber(data.totalLikes)}</div>
                <div>Views: ${this.formatNumber(data.totalViews)}</div>
                <div>Posts: ${data.postsScraped}</div>
                <div>Accounts: ${data.accountCount}</div>
              </div>
            `;
          }
        });
        
        breakdownHTML += '</div>';
        platformBreakdown.innerHTML = breakdownHTML;
        
        // Create combined charts
        this.createCombinedPlatformCharts(chartsContainer);
      },
      
      // Create combined platform charts
      createCombinedPlatformCharts(container) {
        // Views by platform comparison
        const platformNames = [];
        const platformViews = [];
        const platformLikes = [];
        const platformFollowers = [];
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          if (this.allPlatformsData[platform]) {
            platformNames.push(platform.charAt(0).toUpperCase() + platform.slice(1));
            platformViews.push(this.allPlatformsData[platform].totalViews);
            platformLikes.push(this.allPlatformsData[platform].totalLikes);
            platformFollowers.push(this.allPlatformsData[platform].followers);
          }
        });
        
        // Platform comparison chart
        const comparisonDiv = document.createElement('div');
        comparisonDiv.className = 'chart-container';
        
        const comparisonCanvas = document.createElement('canvas');
        comparisonCanvas.id = 'platform-comparison';
        
        const comparisonHeader = document.createElement('h3');
        comparisonHeader.textContent = 'Platform Comparison';
        
        comparisonDiv.appendChild(comparisonHeader);
        comparisonDiv.appendChild(comparisonCanvas);
        container.appendChild(comparisonDiv);
        
        const comparisonCtx = comparisonCanvas.getContext('2d');
        
        this.chartInstances['platform-comparison'] = new Chart(comparisonCtx, {
          type: 'bar',
          data: {
            labels: platformNames,
            datasets: [
              {
                label: 'Views',
                data: platformViews,
                backgroundColor: '#00d2d3',
                borderColor: '#00d2d3',
                borderWidth: 2
              },
              {
                label: 'Likes',
                data: platformLikes,
                backgroundColor: '#ff6b6b',
                borderColor: '#ff6b6b',
                borderWidth: 2
              },
              {
                label: 'Followers/Subscribers',
                data: platformFollowers,
                backgroundColor: '#9b59b6',
                borderColor: '#9b59b6',
                borderWidth: 2
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              },
              datalabels: {
                display: false  // Disable grey text labels on data points
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: 'logarithmic',
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumber(value);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
        
        // Combine all videos from all platforms for time-series charts
        const allVideos = [
          ...(this.allPlatformsData.instagram?.videos || []),
          ...(this.allPlatformsData.tiktok?.videos || []),
          ...(this.allPlatformsData.youtube?.videos || [])
        ].filter(v => v.date);
        
        // Sort by date
        allVideos.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        if (allVideos.length > 0) {
          // Combined Views Over Time
          const viewsData = allVideos.map(v => v.views || 0);
          const useLogViews = this.shouldUseLogScale(viewsData);
          
          this.createTimeBasedChart(container, 'Combined Views Over Time',
            allVideos,
            [{
              label: 'Views',
              data: allVideos.map(v => ({ x: v.date, y: v.views || 0 })),
              borderColor: '#00d2d3',
              backgroundColor: 'rgba(0, 210, 211, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogViews,
            'all-views-time',
            true,
            'views'
          );
          
          // Combined Likes Over Time
          const likesData = allVideos.map(v => v.likes || 0);
          const useLogLikes = this.shouldUseLogScale(likesData);
          
          this.createTimeBasedChart(container, 'Combined Likes Over Time',
            allVideos,
            [{
              label: 'Likes',
              data: allVideos.map(v => ({ x: v.date, y: v.likes || 0 })),
              borderColor: '#ff6b6b',
              backgroundColor: 'rgba(255, 107, 107, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogLikes,
            'all-likes-time',
            true,
            'likes'
          );
          
          // Combined Comments Over Time
          const commentsData = allVideos.map(v => v.comments || 0);
          const useLogComments = this.shouldUseLogScale(commentsData);
          
          this.createTimeBasedChart(container, 'Combined Comments Over Time',
            allVideos,
            [{
              label: 'Comments',
              data: allVideos.map(v => ({ x: v.date, y: v.comments || 0 })),
              borderColor: '#1abc9c',
              backgroundColor: 'rgba(26, 188, 156, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogComments,
            'all-comments-time',
            true,
            'comments'
          );
        }
        
        // Create platform-specific growth comparison charts
        this.createPlatformGrowthChart(container);
      },
      
      // Create platform growth comparison chart
      createPlatformGrowthChart(container) {
        // Gather videos with platform info for stacked visualization
        const platformColors = {
          instagram: { border: '#E1306C', bg: 'rgba(225, 48, 108, 0.7)' },
          tiktok: { border: '#00f2ea', bg: 'rgba(0, 242, 234, 0.7)' },
          youtube: { border: '#FF0000', bg: 'rgba(255, 0, 0, 0.7)' }
        };
        
        const datasets = [];
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const data = this.allPlatformsData[platform];
          if (data && data.videos && data.videos.length > 0) {
            const sortedVideos = [...data.videos].sort((a, b) => new Date(a.date) - new Date(b.date));
            datasets.push({
              label: platform.charAt(0).toUpperCase() + platform.slice(1) + ' Views',
              data: sortedVideos.map(v => ({ x: v.date, y: v.views || 0 })),
              borderColor: platformColors[platform].border,
              backgroundColor: platformColors[platform].bg,
              pointRadius: 3,
              pointHoverRadius: 5,
              tension: 0.3
            });
          }
        });
        
        if (datasets.length > 0) {
          const chartDiv = document.createElement('div');
          chartDiv.className = 'chart-container';
          
          const canvas = document.createElement('canvas');
          canvas.id = 'platform-views-comparison';
          
          const header = document.createElement('h3');
          header.textContent = 'Views by Platform Over Time';
          
          const scaleBadge = document.createElement('span');
          scaleBadge.className = 'scale-badge';
          scaleBadge.textContent = 'LOG SCALE';
          scaleBadge.setAttribute('data-chart-id', 'platform-views-comparison');
          scaleBadge.onclick = () => this.toggleLogScale('platform-views-comparison');
          header.appendChild(scaleBadge);
          
          chartDiv.appendChild(header);
          chartDiv.appendChild(canvas);
          container.appendChild(chartDiv);
          
          const ctx = canvas.getContext('2d');
          
          this.chartInstances['platform-views-comparison'] = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: '#0f0',
                    font: { family: 'monospace', size: 12 }
                  }
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#0f0',
                  bodyColor: '#0f0',
                  borderColor: '#0f0',
                  borderWidth: 1,
                  callbacks: {
                    label: (context) => {
                      return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'day',
                    displayFormats: { day: 'MMM d, yyyy' }
                  },
                  ticks: { color: '#0f0', font: { family: 'monospace' } },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                },
                y: {
                  type: 'logarithmic',
                  ticks: {
                    color: '#0f0',
                    font: { family: 'monospace' },
                    callback: (value) => {
                      return this.formatNumber(value);
                    }
                  },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                }
              }
            }
          });
        }
        
        // Create posts per platform pie chart
        this.createPostsDistributionChart(container);
      },
      
      // Create posts distribution pie chart
      createPostsDistributionChart(container) {
        const platformNames = [];
        const postsCounts = [];
        const colors = ['#E1306C', '#00f2ea', '#FF0000'];
        
        ['instagram', 'tiktok', 'youtube'].forEach((platform, index) => {
          if (this.allPlatformsData[platform]) {
            platformNames.push(platform.charAt(0).toUpperCase() + platform.slice(1));
            postsCounts.push(this.allPlatformsData[platform].postsScraped || 0);
          }
        });
        
        if (postsCounts.some(c => c > 0)) {
          const chartDiv = document.createElement('div');
          chartDiv.className = 'chart-container';
          chartDiv.style.maxWidth = '500px';
          chartDiv.style.margin = '0 auto';
          
          const canvas = document.createElement('canvas');
          canvas.id = 'posts-distribution';
          
          const header = document.createElement('h3');
          header.textContent = 'Content Distribution by Platform';
          
          chartDiv.appendChild(header);
          chartDiv.appendChild(canvas);
          container.appendChild(chartDiv);
          
          const ctx = canvas.getContext('2d');
          
          this.chartInstances['posts-distribution'] = new Chart(ctx, {
            type: 'doughnut',
            data: {
              labels: platformNames,
              datasets: [{
                data: postsCounts,
                backgroundColor: colors.slice(0, platformNames.length),
                borderColor: '#000',
                borderWidth: 2
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom',
                  labels: {
                    color: '#0f0',
                    font: { family: 'monospace', size: 12 }
                  }
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#0f0',
                  bodyColor: '#0f0',
                  borderColor: '#0f0',
                  borderWidth: 1,
                  callbacks: {
                    label: (context) => {
                      const total = postsCounts.reduce((a, b) => a + b, 0);
                      const percentage = ((context.parsed / total) * 100).toFixed(1);
                      return `${context.label}: ${context.parsed} posts (${percentage}%)`;
                    }
                  }
                }
              }
            }
          });
        }
      }
    };
    
    // Expose app to global scope for inline event handlers
    window.app = app;
    
    // Initialize the app when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
