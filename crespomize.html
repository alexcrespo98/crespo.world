<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>crespomize - crespo.world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 2em;
    }
    nav {
      margin-bottom: 2em;
    }
    nav a {
      color: #0f0;
      text-decoration: none;
      margin: 0 1em;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    h1 { 
      font-size: 2.5em; 
      margin-bottom: 0.5em; 
      text-shadow: 0 0 10px #0f0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2em;
      border: 2px solid #0f0;
      background: #111;
      border-radius: 10px;
      text-align: left;
    }
    .question {
      margin: 2em 0;
      font-size: 1.2em;
    }
    button {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em 1.5em;
      margin: 0.5em;
      cursor: pointer;
      font-family: monospace;
      font-size: 1em;
      transition: all 0.3s;
    }
    button:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 15px #0f0;
    }
    select {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em;
      font-family: monospace;
      font-size: 1em;
      width: 100%;
      margin: 1em 0;
      cursor: pointer;
    }
    select option {
      background: #000;
      color: #0f0;
    }
    select option:disabled {
      color: #666;
    }
    .hidden {
      display: none;
    }
    #charts {
      margin-top: 2em;
    }
    .chart-container {
      margin: 2em 0;
      padding: 1.5em;
      border: 2px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
      position: relative;
    }
    .chart-container h3 {
      color: #0f0;
      margin-bottom: 1em;
      font-size: 1.3em;
      display: inline-block;
    }
    canvas {
      max-width: 100%;
    }
    .loading {
      font-size: 1.5em;
      margin: 2em;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1em;
      margin: 2em 0;
    }
    .stat-card {
      background: #0a0a0a;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 1.5em;
    }
    .stat-card h4 {
      margin: 0 0 0.5em 0;
      color: #0f0;
      font-size: 0.9em;
    }
    .stat-card .value {
      font-size: 1.8em;
      font-weight: bold;
      color: #0f0;
    }
    .moonmedia-option {
      font-weight: bold;
      color: #ffff00;
    }
    .time-range-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1em;
      margin: 1em 0;
    }
    .time-range-buttons button.active {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 15px #0f0;
    }
    .custom-date-slider-container {
      margin: 2em 0 1em 0;
      padding: 1.5em;
      border: 1px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
    }
    .custom-date-slider-label {
      margin-bottom: 1em;
      color: #0f0;
      font-size: 0.9em;
    }
    .dual-slider-wrapper {
      position: relative;
      height: 40px;
      margin: 1em 0;
    }
    .slider-track {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
    }
    .slider-range {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      height: 6px;
      background: #0f0;
      border-radius: 3px;
    }
    .range-input {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 6px;
      background: none;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
    }
    .range-input::-webkit-slider-thumb {
      pointer-events: all;
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #0f0;
      border: 3px solid #000;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #0f0;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .range-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px #0f0;
    }
    .range-input::-moz-range-thumb {
      pointer-events: all;
      width: 20px;
      height: 20px;
      background: #0f0;
      border: 3px solid #000;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #0f0;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .range-input::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px #0f0;
    }
    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5em;
      font-size: 0.85em;
      color: #0f0;
    }
    .slider-date-display {
      text-align: center;
      margin-top: 1em;
      font-size: 1em;
      color: #0f0;
      background: #000;
      padding: 0.5em 1em;
      border: 1px solid #0f0;
      border-radius: 3px;
      display: inline-block;
    }
    .slider-apply-btn {
      margin-top: 1em;
      background: #0f0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.6em 1.5em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.9em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 3px;
    }
    .slider-apply-btn:hover {
      background: #00ff7f;
      box-shadow: 0 0 15px #0f0;
    }
    .scale-badge {
      display: inline-block;
      background: #0f0;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .scale-badge:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .scale-badge.inactive {
      background: #333;
      color: #666;
    }
    .trendline-badge {
      display: inline-block;
      background: #ffff00;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .trendline-badge:hover {
      background: #ffdd00;
      box-shadow: 0 0 10px #ffff00;
    }
    .trendline-badge.inactive {
      background: #333;
      color: #666;
    }
    .smoothness-controls {
      display: inline-block;
      margin-left: 0.3em;
      vertical-align: middle;
    }
    .smoothness-btn {
      background: #ffff00;
      color: #000;
      border: 2px solid #ffff00;
      padding: 0.2em 0.5em;
      margin: 0 0.1em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.8em;
      font-weight: bold;
      transition: all 0.3s;
      user-select: none;
      display: inline-block;
      min-width: 30px;
    }
    .smoothness-btn:hover {
      background: #ffdd00;
      box-shadow: 0 0 5px #ffff00;
    }
    .smoothness-btn:active {
      transform: scale(0.95);
    }
    .export-btn {
      position: absolute;
      top: 1.5em;
      right: 1.5em;
      background: #0f0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.4em 0.8em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.85em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 3px;
    }
    .export-btn:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .no-data-message {
      text-align: center;
      padding: 3em;
      color: #ff0;
      font-size: 1.2em;
      border: 2px dashed #ff0;
      border-radius: 10px;
      margin: 2em 0;
      background: rgba(255, 255, 0, 0.05);
    }
    .platform-stats {
      background: #0a0a0a;
      border: 2px solid #ffff00;
      border-radius: 10px;
      padding: 1.5em;
      margin: 1.5em 0;
    }
    .platform-stats h3 {
      color: #ffff00;
      margin-bottom: 1em;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">home</a>
    <a href="chemocam.html">chemocam</a>
    <a href="crespomize.html">crespomize</a>
    <a href="instalogin.html">instalogin</a>
  </nav>

  <h1>crespomize analytics</h1>
  
  <div class="container">
    <!-- Step 0: Platform selection -->
    <div id="step0" class="step">
      <div class="question">which platform?</div>
      <select id="platformSelect">
        <option value="" disabled selected>-- select platform --</option>
        <option value="all" class="moonmedia-option">All MoonMedia Platforms</option>
        <option value="instagram">Instagram Reels</option>
        <option value="tiktok">TikTok</option>
        <option value="youtube">YouTube Shorts</option>
      </select>
    </div>

    <!-- Step 1: Select account (for single platform) -->
    <div id="step1" class="step hidden">
      <div class="question">pick a company:</div>
      <select id="accountSelect">
        <option value="" disabled selected>-- select an account --</option>
      </select>
    </div>

    <!-- Step 2: Time range selection -->
    <div id="step2" class="step hidden">
      <div class="question">select time range for analysis:</div>
      <div class="time-range-buttons" id="timeRangeButtons">
        <button id="btn-all" onclick="app.selectPresetTimeRange('all')">All Time</button>
        <button id="btn-365" onclick="app.selectPresetTimeRange(365)">1 Year</button>
        <button id="btn-180" onclick="app.selectPresetTimeRange(180)">6 Months</button>
        <button id="btn-30" onclick="app.selectPresetTimeRange(30)">1 Month</button>
      </div>
      
      <!-- Custom Date Range Slider -->
      <div class="custom-date-slider-container" id="customDateSliderContainer">
        <div class="custom-date-slider-label">or choose a custom date range:</div>
        <div class="dual-slider-wrapper">
          <div class="slider-track"></div>
          <div class="slider-range" id="sliderRange"></div>
          <input type="range" class="range-input" id="rangeMin" min="0" max="100" value="0">
          <input type="range" class="range-input" id="rangeMax" min="0" max="100" value="100">
        </div>
        <div class="slider-labels">
          <span id="minDateLabel">--</span>
          <span id="maxDateLabel">--</span>
        </div>
        <div style="text-align: center;">
          <div class="slider-date-display">
            <span id="selectedStartDate">--</span> to <span id="selectedEndDate">--</span>
          </div>
          <br>
          <button class="slider-apply-btn" onclick="app.applyCustomDateRange()">Apply Custom Range</button>
        </div>
      </div>
    </div>

    <!-- Charts display -->
    <div id="charts" class="hidden">
      <div class="question">analytics for <span id="accountName"></span> <span id="timeRangeLabel"></span></div>
      
      <!-- Summary stats -->
      <div class="stats-summary" id="statsSummary"></div>
      
      <!-- Platform breakdown for "All MoonMedia" -->
      <div id="platformBreakdown" class="hidden"></div>
      
      <!-- Charts -->
      <div id="chartsList"></div>
      <br>
      <button onclick="location.reload()">start over</button>
    </div>

    <div id="loading" class="loading hidden">loading data...</div>
  </div>

  <script>
    // Application state
    const app = {
      // Configuration
      SHEET_IDS: {
        tiktok: '1FUGfhPVsVi1WOOw88BKfUKueJh4eMPj1',
        instagram: '19PDIP7_YaluxsmvQsDJ89Bn5JkXnK2n2',
        youtube: '1yRLZpJLdaB9oPZtjcwIeJx-6q8lGF2dO'
      },
      
      // State variables
      selectedPlatform: '',
      workbookData: null,
      selectedAccount: '',
      accountData: {},
      isMoonMediaTotal: false,
      isAllPlatforms: false,
      selectedTimeRange: 'all',
      chartInstances: {},
      trendlineStates: {},
      trendlineDaysAverage: {},
      allPlatformsData: {},
      
      // Custom date range slider state
      dataDateRange: { min: null, max: null },
      customDateRange: { start: null, end: null },
      
      // Initialize the application
      init() {
        this.setupEventListeners();
        this.setupSliderListeners();
      },
      
      // Setup slider event listeners
      setupSliderListeners() {
        const rangeMin = document.getElementById('rangeMin');
        const rangeMax = document.getElementById('rangeMax');
        
        rangeMin.addEventListener('input', () => this.updateSlider());
        rangeMax.addEventListener('input', () => this.updateSlider());
      },
      
      // Update the slider UI
      updateSlider() {
        const rangeMin = document.getElementById('rangeMin');
        const rangeMax = document.getElementById('rangeMax');
        const sliderRange = document.getElementById('sliderRange');
        
        let minVal = parseInt(rangeMin.value);
        let maxVal = parseInt(rangeMax.value);
        
        // Prevent handles from crossing and ensure values are within bounds
        if (minVal > maxVal - 1) {
          if (this.lastChanged === 'min') {
            minVal = Math.min(maxVal - 1, 99);
            minVal = Math.max(minVal, 0);
            rangeMin.value = minVal;
          } else {
            maxVal = Math.min(minVal + 1, 100);
            maxVal = Math.max(maxVal, 1);
            rangeMax.value = maxVal;
          }
        }
        
        this.lastChanged = (document.activeElement === rangeMin) ? 'min' : 'max';
        
        // Update the range highlight
        const percent1 = minVal;
        const percent2 = maxVal;
        sliderRange.style.left = percent1 + '%';
        sliderRange.style.width = (percent2 - percent1) + '%';
        
        // Calculate and display dates
        if (this.dataDateRange.min && this.dataDateRange.max) {
          const totalDays = Math.floor((this.dataDateRange.max - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          
          const startDays = Math.floor(totalDays * (minVal / 100));
          const endDays = Math.floor(totalDays * (maxVal / 100));
          
          const startDate = new Date(this.dataDateRange.min);
          startDate.setDate(startDate.getDate() + startDays);
          
          const endDate = new Date(this.dataDateRange.min);
          endDate.setDate(endDate.getDate() + endDays);
          
          this.customDateRange.start = startDate;
          this.customDateRange.end = endDate;
          
          document.getElementById('selectedStartDate').textContent = this.formatDate(startDate);
          document.getElementById('selectedEndDate').textContent = this.formatDate(endDate);
        }
        
        // Clear active state from preset buttons
        document.querySelectorAll('#timeRangeButtons button').forEach(btn => {
          btn.classList.remove('active');
        });
      },
      
      // Format date for display
      formatDate(date) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      },
      
      // Initialize slider with data range
      initializeSliderWithData() {
        // This will be called after we know the data range
        // For now, use a default range
        const now = new Date();
        const yearAgo = new Date();
        yearAgo. setFullYear(yearAgo. getFullYear() - 10); // Fallback to 10 years
        
        this.dataDateRange.min = yearAgo;
        this.dataDateRange.max = now;
        
        document.getElementById('minDateLabel').textContent = this.formatDate(yearAgo);
        document.getElementById('maxDateLabel').textContent = this.formatDate(now);
        
        // Initialize slider to full range
        document.getElementById('rangeMin').value = 0;
        document.getElementById('rangeMax').value = 100;
        
        this.customDateRange.start = yearAgo;
        this.customDateRange.end = now;
        
        document.getElementById('selectedStartDate').textContent = this.formatDate(yearAgo);
        document.getElementById('selectedEndDate').textContent = this.formatDate(now);
        
        // Update slider range highlight
        const sliderRange = document.getElementById('sliderRange');
        sliderRange.style.left = '0%';
        sliderRange.style.width = '100%';
      },
        
      
      // Select preset time range (from button click)
      selectPresetTimeRange(days) {
        // Update active button state
        document.querySelectorAll('#timeRangeButtons button').forEach(btn => {
          btn.classList.remove('active');
        });
        
        const btnId = days === 'all' ? 'btn-all' : `btn-${days}`;
        document.getElementById(btnId).classList.add('active');
        
        // Update slider to match preset
        if (this.dataDateRange.min && this.dataDateRange.max) {
          const now = new Date();
          let startDate;
          
          if (days === 'all') {
            startDate = this.dataDateRange.min;
          } else {
            // Create a new date by subtracting milliseconds (more robust than setDate)
            const daysInMs = days * 24 * 60 * 60 * 1000;
            startDate = new Date(now.getTime() - daysInMs);
            if (startDate < this.dataDateRange.min) {
              startDate = this.dataDateRange.min;
            }
          }
          
          const totalDays = Math.floor((this.dataDateRange.max - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          const startDays = Math.floor((startDate - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          
          const minPercent = totalDays > 0 ? Math.round((startDays / totalDays) * 100) : 0;
          const maxPercent = 100;
          
          document.getElementById('rangeMin').value = minPercent;
          document.getElementById('rangeMax').value = maxPercent;
          
          this.customDateRange.start = startDate;
          this.customDateRange.end = now;
          
          document.getElementById('selectedStartDate').textContent = this.formatDate(startDate);
          document.getElementById('selectedEndDate').textContent = this.formatDate(now);
          
          const sliderRange = document.getElementById('sliderRange');
          sliderRange.style.left = minPercent + '%';
          sliderRange.style.width = (maxPercent - minPercent) + '%';
        }
        
        // Apply the selection
        this.selectTimeRange(days);
      },
      
      // Apply custom date range
      applyCustomDateRange() {
        if (!this.customDateRange.start || !this.customDateRange.end) {
          return;
        }
        
        // Calculate days from start to end
        const daysDiff = Math.floor((this.customDateRange.end - this.customDateRange.start) / (1000 * 60 * 60 * 24));
        
        // Store custom range for filtering
        this.selectedTimeRange = 'custom';
        this.customStartDate = this.customDateRange.start;
        this.customEndDate = this.customDateRange.end;
        
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        
        if (this.isAllPlatforms) {
          this.loadAllPlatformsData('custom');
        } else {
          setTimeout(() => {
            this.processData('custom');
            this.finalizeDataDisplay('custom');
          }, 1000);
        }
      },
      
      // Setup all event listeners
      setupEventListeners() {
        document.getElementById('platformSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectPlatform(e.target.value);
          }
        });
        
        document.getElementById('accountSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectAccount(e.target.value);
          }
        });
      },
      
      // Platform selection
      selectPlatform(platform) {
        this.selectedPlatform = platform;
        this.isAllPlatforms = (platform === 'all');
        
        document.getElementById('step0').classList.add('hidden');
        
        if (this.isAllPlatforms) {
          // Skip account selection for all platforms
          document.getElementById('step2').classList.remove('hidden');
          this.initializeSliderWithData();
        } else {
          document.getElementById('step1').classList.remove('hidden');
          this.loadSheetData();
        }
      },
      
      // Account selection
      selectAccount(account) {
        this.selectedAccount = account;
        this.isMoonMediaTotal = (account === 'MOONMEDIA_TOTAL');
        document.getElementById('step1').classList.add('hidden');
        document.getElementById('step2').classList.remove('hidden');
        this.initializeSliderWithData();
      },
      
      // Time range selection
      async selectTimeRange(days) {
        this.selectedTimeRange = days;
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        
        if (this.isAllPlatforms) {
          await this.loadAllPlatformsData(days);
        } else {
          setTimeout(() => {
            this.processData(days);
            this.finalizeDataDisplay(days);
          }, 1000);
        }
      },
      
      // Finalize data display
      finalizeDataDisplay(days) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('charts').classList.remove('hidden');
        
        // Update UI labels
        let accountText = '';
        if (this.isAllPlatforms) {
          accountText = 'All MoonMedia Platforms';
        } else if (this.isMoonMediaTotal) {
          accountText = 'All MoonMedia';
        } else {
          accountText = '@' + this.selectedAccount;
        }
        
        document.getElementById('accountName').textContent = accountText;
        
        let rangeText = '';
        if (days === 'all') rangeText = '(All Time)';
        else if (days === 365) rangeText = '(Last 1 Year)';
        else if (days === 180) rangeText = '(Last 6 Months)';
        else if (days === 30) rangeText = '(Last 1 Month)';
        else if (days === 'custom' && this.customStartDate && this.customEndDate) {
          rangeText = `(${this.formatDate(this.customStartDate)} - ${this.formatDate(this.customEndDate)})`;
        }
        document.getElementById('timeRangeLabel').textContent = rangeText;
        
        if (this.isAllPlatforms) {
          this.renderAllPlatformsDashboard();
        } else {
          this.renderDashboard();
        }
      },
      
      // Load all platforms data
      async loadAllPlatformsData(timeRangeDays) {
        this.allPlatformsData = {
          instagram: null,
          tiktok: null,
          youtube: null,
          combined: {
            totalFollowers: 0,
            totalLikes: 0,
            totalViews: 0,
            totalPosts: 0,
            viewsPerSecond: 0
          }
        };
        
        // Load Instagram data
        try {
          const igResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.instagram}/export?format=xlsx`);
          const igBuffer = await igResponse.arrayBuffer();
          const igWorkbook = XLSX.read(igBuffer, { type: 'array' });
          this.allPlatformsData.instagram = this.processWorkbookData(igWorkbook, 'instagram', timeRangeDays);
        } catch (error) {
          console.error('Error loading Instagram data:', error);
        }
        
        // Load TikTok data
        try {
          const ttResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.tiktok}/export?format=xlsx`);
          const ttBuffer = await ttResponse.arrayBuffer();
          const ttWorkbook = XLSX.read(ttBuffer, { type: 'array' });
          this.allPlatformsData.tiktok = this.processWorkbookData(ttWorkbook, 'tiktok', timeRangeDays);
        } catch (error) {
          console.error('Error loading TikTok data:', error);
        }
        
        // Load YouTube data
        try {
          const ytResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.youtube}/export?format=xlsx`);
          const ytBuffer = await ytResponse.arrayBuffer();
          const ytWorkbook = XLSX.read(ytBuffer, { type: 'array' });
          this.allPlatformsData.youtube = this.processWorkbookData(ytWorkbook, 'youtube', timeRangeDays);
        } catch (error) {
          console.error('Error loading YouTube data:', error);
        }
        
        // Calculate combined metrics
        this.calculateCombinedMetrics();
        
        this.finalizeDataDisplay(timeRangeDays);
      },
      
      // Process workbook data for all platforms view
      processWorkbookData(workbook, platform, timeRangeDays) {
        const accounts = workbook.SheetNames;
        let totalFollowers = 0;
        let totalLikes = 0;
        let totalPosts = 0;
        let allVideos = [];
        
        accounts.forEach(sheetName => {
          const data = this.parseAccountDataFromWorkbook(workbook, sheetName, platform, timeRangeDays);
          if (data) {
            totalFollowers += data.followers || 0;
            totalLikes += data.totalLikes || 0;
            totalPosts += data.postsScraped || 0;
            if (data.videos) {
              allVideos = allVideos.concat(data.videos);
            }
          }
        });
        
        const totalViews = allVideos.reduce((sum, v) => sum + (v.views || 0), 0);
        
        return {
          platform: platform,
          followers: totalFollowers,
          totalLikes: totalLikes,
          totalViews: totalViews,
          postsScraped: totalPosts,
          videos: allVideos,
          accountCount: accounts.length
        };
      },
      
      // Calculate combined metrics for all platforms
      calculateCombinedMetrics() {
        const platforms = ['instagram', 'tiktok', 'youtube'];
        let totalViews = 0;
        let allVideos = [];
        
        platforms.forEach(platform => {
          if (this.allPlatformsData[platform]) {
            const data = this.allPlatformsData[platform];
            this.allPlatformsData.combined.totalFollowers += data.followers || 0;
            this.allPlatformsData.combined.totalLikes += data.totalLikes || 0;
            this.allPlatformsData.combined.totalViews += data.totalViews || 0;
            this.allPlatformsData.combined.totalPosts += data.postsScraped || 0;
            
            if (data.videos) {
              allVideos = allVideos.concat(data.videos);
            }
          }
        });
        
        // Calculate views per second
        allVideos.sort((a, b) => (a.date || 0) - (b.date || 0));
        
        if (allVideos.length >= 2) {
          const validVideos = allVideos.filter(v => v.date && v.views);
          if (validVideos.length >= 2) {
            const oldestVideo = validVideos[0];
            const newestVideo = validVideos[validVideos.length - 1];
            const timeSpanSeconds = (newestVideo.date - oldestVideo.date) / 1000;
            
            if (timeSpanSeconds > 0) {
              const totalViewsInPeriod = validVideos.reduce((sum, v) => sum + v.views, 0);
              this.allPlatformsData.combined.viewsPerSecond = totalViewsInPeriod / timeSpanSeconds;
            }
          }
        }
      },
      
      // Parse account data from workbook
      parseAccountDataFromWorkbook(workbook, sheetName, platform, timeRangeDays) {
        if (platform === 'instagram') {
          return this.parseInstagramDataFromWorkbook(workbook, sheetName, timeRangeDays);
        } else if (platform === 'tiktok') {
          return this.parseTikTokDataFromWorkbook(workbook, sheetName, timeRangeDays);
        } else if (platform === 'youtube') {
          return this.parseYouTubeDataFromWorkbook(workbook, sheetName, timeRangeDays);
        }
        return null;
      },
      
      // Load sheet data
      async loadSheetData() {
        const accountSelect = document.getElementById('accountSelect');
        
        try {
          accountSelect.innerHTML = '<option value="" disabled>loading accounts...</option>';
          
          const sheetId = this.SHEET_IDS[this.selectedPlatform];
          const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=xlsx`;
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          
          this.workbookData = XLSX.read(arrayBuffer, { type: 'array' });
          
          const accounts = this.workbookData.SheetNames;
          
          if (accounts.length === 0) {
            accountSelect.innerHTML = '<option>no accounts found</option>';
            return;
          }
          
          accountSelect.innerHTML = 
            '<option value="" disabled selected>-- select an account --</option>' +
            '<option value="MOONMEDIA_TOTAL" class="moonmedia-option">All MoonMedia Analytics</option>' +
            accounts.map(acc => `<option value="${acc}">@${acc}</option>`).join('');
          
          console.log('Loaded accounts:', accounts);
          
        } catch (error) {
          console.error('Error loading data:', error);
          accountSelect.innerHTML = '<option>error loading - check file permissions</option>';
        }
      },
      
      // Process data based on platform and account
      processData(timeRangeDays) {
        if (this.isMoonMediaTotal) {
          this.accountData = this.parseMoonMediaTotal(timeRangeDays);
        } else {
          this.accountData = this.parseAccountData(this.selectedAccount, timeRangeDays);
        }
      },
      
      // Parse account data
      parseAccountData(sheetName, timeRangeDays = 'all') {
        if (this.selectedPlatform === 'instagram') {
          return this.parseInstagramData(sheetName, timeRangeDays);
        } else if (this.selectedPlatform === 'tiktok') {
          return this.parseTikTokData(sheetName, timeRangeDays);
        } else if (this.selectedPlatform === 'youtube') {
          return this.parseYouTubeData(sheetName, timeRangeDays);
        }
      },
      
      // Parse YouTube data from sheet
      parseYouTubeData(sheetName, timeRangeDays) {
        return this.parseYouTubeDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse YouTube data from workbook
      parseYouTubeDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        let followers = null;
        let totalLikes = null;
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        // Parse YouTube data similar to TikTok structure
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'subscribers' || rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            followers = followersHistory.length > 0 ? 
              followersHistory[followersHistory.length - 1].value : 0;
              
          } else if (rowName === 'total_likes') {
            totalLikesHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            totalLikes = totalLikesHistory.length > 0 ? 
              totalLikesHistory[totalLikesHistory.length - 1].value : 0;
              
          } else if (rowName.startsWith('post_') || rowName.startsWith('video_') || rowName.startsWith('short_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            if (metric === 'Date' || metric === 'date') {
              allUniqueVideoIds.add(videoId);
            }
            
            for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
              const cellValue = row[colIdx];
              
              if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                if (!allVideosMap.has(videoId)) {
                  allVideosMap.set(videoId, { id: videoId });
                }
                
                const video = allVideosMap.get(videoId);
                if (video[metric] === undefined) {
                  video[metric] = cellValue;
                }
                break;
              }
            }
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date || v.date).map(v => {
          const dateObj = new Date(v.Date || v.date);
          
          if (!this.isValidDate(dateObj)) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views || v.views) || 0,
            likes: parseInt(v.Likes || v.likes) || 0,
            comments: parseInt(v.Comments || v.comments) || 0,
            shares: parseInt(v.Shares || v.shares) || 0,
            engagement: parseFloat(v.EngagementRate || v.engagement) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: parseInt(followers) || 0,
          totalLikes: parseInt(totalLikes) || 0,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => item.value > 0),
          platform: 'youtube'
        };
      },
      // Parse TikTok data
      parseTikTokData(sheetName, timeRangeDays) {
        return this.parseTikTokDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse TikTok data from workbook
      parseTikTokDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        let followers = null;
        let totalLikes = null;
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            followers = followersHistory.length > 0 ? 
              followersHistory[followersHistory.length - 1].value : 0;
              
          } else if (rowName === 'total_likes') {
            totalLikesHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            totalLikes = totalLikesHistory.length > 0 ? 
              totalLikesHistory[totalLikesHistory.length - 1].value : 0;
              
          } else if (rowName.startsWith('post_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            if (metric === 'Date') {
              allUniqueVideoIds.add(videoId);
            }
            
            for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
              const cellValue = row[colIdx];
              
              if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                if (!allVideosMap.has(videoId)) {
                  allVideosMap.set(videoId, { id: videoId });
                }
                
                const video = allVideosMap.get(videoId);
                if (video[metric] === undefined) {
                  video[metric] = cellValue;
                }
                break;
              }
            }
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          const dateObj = new Date(v.Date);
          
          if (!this.isValidDate(dateObj)) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: parseInt(v.Shares) || 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: parseInt(followers) || 0,
          totalLikes: parseInt(totalLikes) || 0,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => item.value > 0)
        };
      },
      
      // Parse Instagram data
      parseInstagramData(sheetName, timeRangeDays) {
        return this.parseInstagramDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse Instagram data from workbook
      parseInstagramDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        let followers = null;
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: new Date(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => this.isValidDate(item.date));
            
            followers = followersHistory.length > 0 ? 
              followersHistory[followersHistory.length - 1].value : 0;
              
          } else if (rowName.startsWith('reel_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            const metricMapping = {
              'date': 'Date',
              'views': 'Views',
              'likes': 'Likes',
              'comments': 'Comments',
              'engagement': 'EngagementRate'
            };
            
            const mappedMetric = metricMapping[metric];
            
            if (metric === 'date') {
              allUniqueVideoIds.add(videoId);
            }
            
            if (metric === 'date_display') continue;
            
            if (mappedMetric) {
              for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                const cellValue = row[colIdx];
                
                if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  
                  const video = allVideosMap.get(videoId);
                  if (video[mappedMetric] === undefined) {
                    video[mappedMetric] = cellValue;
                  }
                  break;
                }
              }
            }
          }
        }
        
        // Calculate total likes history using only the most recent scrape data per post
        // First, build a map of video IDs to their likes rows
        const likesRowsMap = new Map();
        const postDatesMap = new Map();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_likes')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            likesRowsMap.set(videoId, row);
          }
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_date')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            // Find the post date (most recent non-empty value)
            for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
              const cellValue = row[colIdx];
              if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                postDatesMap.set(videoId, new Date(cellValue));
                break;
              }
            }
          }
        }
        
        // For each scrape timestamp (column), calculate total likes using only the most recent data per post
        for (let colIdx = 0; colIdx < headers.length; colIdx++) {
          const scrapeDate = new Date(headers[colIdx]);
          if (!this.isValidDate(scrapeDate)) continue;
          
          let columnTotalLikes = 0;
          
          // For each post, get the most recent likes value up to this column
          for (const [videoId, likesRow] of likesRowsMap) {
            const postDate = postDatesMap.get(videoId);
            
            // Only include posts that existed by this scrape date
            if (postDate && postDate <= scrapeDate) {
              // Find the most recent non-empty likes value for this post up to this column
              let mostRecentLikes = 0;
              for (let prevColIdx = colIdx; prevColIdx >= 0; prevColIdx--) {
                // Check array bounds before accessing
                if (prevColIdx + 1 < likesRow.length) {
                  const value = parseInt(likesRow[prevColIdx + 1]) || 0;
                  if (value > 0) {
                    mostRecentLikes = value;
                    break;
                  }
                }
              }
              columnTotalLikes += mostRecentLikes;
            }
          }
          
          if (columnTotalLikes > 0) {
            totalLikesHistory.push({
              date: scrapeDate,
              value: columnTotalLikes
            });
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          const dateObj = new Date(v.Date);
          
          if (!this.isValidDate(dateObj)) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        return {
          followers: parseInt(followers) || 0,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => this.isValidDate(item.date) && item.value > 0)
        };
      },
      
      // Parse all MoonMedia accounts combined
      parseMoonMediaTotal(timeRangeDays) {
        const accounts = this.workbookData.SheetNames;
        let totalFollowers = 0;
        let totalLikes = 0;
        let totalPosts = 0;
        let allVideos = [];
        
        let followersByTimestamp = {};
        let likesByTimestamp = {};
        
        accounts.forEach(sheetName => {
          const data = this.parseAccountData(sheetName, timeRangeDays);
          totalFollowers += data.followers;
          totalLikes += data.totalLikes;
          totalPosts += data.postsScraped;
          allVideos = allVideos.concat(data.videos);
          
          data.followersHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!followersByTimestamp[dateKey]) {
              followersByTimestamp[dateKey] = { 
                date: item.date, 
                total: 0, 
                accountCount: 0 
              };
            }
            followersByTimestamp[dateKey].total += item.value;
            followersByTimestamp[dateKey].accountCount += 1;
          });
          
          data.totalLikesHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!likesByTimestamp[dateKey]) {
              likesByTimestamp[dateKey] = { 
                date: item.date, 
                total: 0, 
                accountCount: 0 
              };
            }
            likesByTimestamp[dateKey].total += item.value;
            likesByTimestamp[dateKey].accountCount += 1;
          });
        });
        
        const totalAccountCount = accounts.length;
        
        const followersHistory = Object.values(followersByTimestamp)
          .filter(item => item.accountCount === totalAccountCount)
          .map(item => ({ date: item.date, value: item.total }))
          .filter(item => this.isValidDate(item.date) && item.value > 0)
          .sort((a, b) => a.date - b.date);
        
        const totalLikesHistory = Object.values(likesByTimestamp)
          .filter(item => item.accountCount === totalAccountCount)
          .map(item => ({ date: item.date, value: item.total }))
          .filter(item => this.isValidDate(item.date) && item.value > 0)
          .sort((a, b) => a.date - b.date);
        
        allVideos.sort((a, b) => a.date - b.date);
        
        let totalViews = allVideos.reduce((sum, v) => sum + v.views, 0);
        let viewsPerSecond = 0;
        
        const last100Posts = allVideos.slice(-100);
        if (last100Posts.length >= 2) {
          const oldestPost = last100Posts[0];
          const newestPost = last100Posts[last100Posts.length - 1];
          const totalViewsInPeriod = last100Posts.reduce((sum, v) => sum + v.views, 0);
          const timeSpanSeconds = (newestPost.date - oldestPost.date) / 1000;
          
          if (timeSpanSeconds > 0) {
            viewsPerSecond = totalViewsInPeriod / timeSpanSeconds;
          }
        }
        
        return {
          followers: totalFollowers,
          totalLikes: totalLikes,
          postsScraped: totalPosts,
          videos: allVideos,
          followersHistory: followersHistory,
          totalLikesHistory: totalLikesHistory,
          totalViews: totalViews,
          viewsPerSecond: viewsPerSecond,
          accountCount: accounts.length
        };
      },
      
      // Utility functions
      isValidDate(date) {
        if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
          return false;
        }
        const year = date.getFullYear();
        const currentYear = new Date().getFullYear();
        return year >= 2020 && year <= currentYear + 1;
      },
      
      filterDataByTimeRange(videos, timeRangeDays) {
        if (timeRangeDays === 'all') return videos;
        
        // Handle custom date range
        if (timeRangeDays === 'custom') {
          if (this.customStartDate && this.customEndDate) {
            return videos.filter(v => v.date >= this.customStartDate && v.date <= this.customEndDate);
          }
          return videos;
        }
        
        // Create cutoff date using milliseconds (more robust than setDate for month/year boundaries)
        const daysInMs = timeRangeDays * 24 * 60 * 60 * 1000;
        const cutoffDate = new Date(Date.now() - daysInMs);
        
        return videos.filter(v => v.date >= cutoffDate);
      },
      
      interpolateHistoricalData(historyArray) {
        if (historyArray.length === 0) return historyArray;
        
        const interpolated = historyArray.map((item, idx) => ({
          ...item,
          index: idx,
          needsInterp: item.value === 0 || item.value === null || item.value === undefined
        }));
        
        let i = 0;
        while (i < interpolated.length) {
          if (!interpolated[i].needsInterp) {
            i++;
            continue;
          }
          
          let groupStart = i;
          let groupEnd = i;
          while (groupEnd < interpolated.length && interpolated[groupEnd].needsInterp) {
            groupEnd++;
          }
          groupEnd--;
          
          let prevValue = null;
          for (let j = groupStart - 1; j >= 0; j--) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              prevValue = interpolated[j].value;
              break;
            }
          }
          
          let nextValue = null;
          for (let j = groupEnd + 1; j < interpolated.length; j++) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              nextValue = interpolated[j].value;
              break;
            }
          }
          
          if (prevValue !== null && nextValue !== null) {
            const groupSize = groupEnd - groupStart + 1;
            const totalSteps = groupSize + 1;
            
            for (let j = groupStart; j <= groupEnd; j++) {
              const stepNumber = j - groupStart + 1;
              const interpolatedValue = prevValue + ((nextValue - prevValue) * stepNumber / totalSteps);
              interpolated[j].value = Math.round(interpolatedValue);
            }
          } else if (prevValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = prevValue;
            }
          } else if (nextValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = nextValue;
            }
          }
          
          i = groupEnd + 1;
        }
        
        return interpolated.map(item => ({
          date: item.date,
          value: item.value
        }));
      },
      
      shouldUseLogScale(data) {
        if (data.length === 0) return false;
        
        const values = data.filter(v => v > 0);
        if (values.length === 0) return false;
        
        const max = Math.max(...values);
        const min = Math.min(...values);
        const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
        
        const ratio = max / min;
        const medianRatio = max / median;
        
        return ratio > 100 || medianRatio > 10;
      },
      
      formatNumber(num) {
        if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
        if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        return num.toLocaleString();
      },
      
      formatNumberAxisSmart(value, dataRange) {
        const range = dataRange.max - dataRange.min;
        
        if (value >= 1000000000) {
          const val = value / 1000000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'B';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'B';
          return val.toFixed(1) + 'B';
        }
        if (value >= 1000000) {
          const val = value / 1000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'M';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'M';
          return val.toFixed(1) + 'M';
        }
        if (value >= 1000) {
          const val = value / 1000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(2) + 'K';
          return val.toFixed(1) + 'K';
        }
        return value.toLocaleString();
      },
      
      calculateMovingAverageByDays(data, days = 7) {
        const result = [];
        const halfWindow = Math.floor(days / 2);
        
        for (let i = 0; i < data.length; i++) {
          const currentDate = new Date(data[i].x);
          const startDate = new Date(currentDate);
          const endDate = new Date(currentDate);
          
          startDate.setDate(startDate.getDate() - halfWindow);
          endDate.setDate(endDate.getDate() + (days - halfWindow));
          
          const windowPoints = [];
          for (let j = 0; j < data.length; j++) {
            const pointDate = new Date(data[j].x);
            if (pointDate >= startDate && pointDate <= endDate) {
              windowPoints.push(data[j].y);
            }
          }
          
          if (windowPoints.length > 0) {
            const sum = windowPoints.reduce((acc, val) => acc + val, 0);
            const avg = sum / windowPoints.length;
            result.push({ x: data[i].x, y: avg });
          } else {
            result.push({ x: data[i].x, y: data[i].y });
          }
        }
        
        return result;
      },
      
      // Chart manipulation functions
      toggleLogScale(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const currentType = chart.options.scales.y.type;
        const newType = currentType === 'logarithmic' ? 'linear' : 'logarithmic';
        
        chart.options.scales.y.type = newType;
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.type = newType;
        }
        
        if (chartId === 'correlation' && chart.options.scales.x) {
          chart.options.scales.x.type = newType;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-chart-id="${chartId}"]`);
        if (badge) {
          if (newType === 'logarithmic') {
            badge.classList.remove('inactive');
            badge.textContent = 'LOG SCALE';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'LINEAR';
          }
        }
      },
      
      toggleTrendline(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        this.trendlineStates[chartId] = !this.trendlineStates[chartId];
        const showTrendline = this.trendlineStates[chartId];
        
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset) {
          trendlineDataset.hidden = !showTrendline;
        }
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.display = showTrendline;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-trendline-id="${chartId}"]`);
        if (badge) {
          if (showTrendline) {
            badge.classList.remove('inactive');
            badge.textContent = 'TREND ON';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'TREND OFF';
          }
        }
        
        const controls = document.querySelector(`[data-smoothness-controls="${chartId}"]`);
        if (controls) {
          controls.style.display = showTrendline ? 'inline-block' : 'none';
        }
      },
      
      adjustTrendlineSmoothness(chartId, direction) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        if (this.trendlineDaysAverage[chartId] === undefined) {
          this.trendlineDaysAverage[chartId] = 7;
        }
        
        this.trendlineDaysAverage[chartId] += direction;
        this.trendlineDaysAverage[chartId] = Math.max(1, this.trendlineDaysAverage[chartId]);
        
        const dataDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
        if (!dataDataset) return;
        
        const trendlineData = this.calculateMovingAverageByDays(
          dataDataset.data, 
          this.trendlineDaysAverage[chartId]
        );
        
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset) {
          trendlineDataset.data = trendlineData;
        }
        
        chart.update();
        
        const display = document.querySelector(`[data-days-display="${chartId}"]`);
        if (display) {
          display.textContent = this.trendlineDaysAverage[chartId];
        }
      },
      
      exportChart(chartId, title) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const canvas = chart.canvas;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + 80;
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCtx.fillStyle = '#000000';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        tempCtx.fillStyle = '#ffffff';
        tempCtx.font = 'bold 24px monospace';
        tempCtx.textAlign = 'center';
        tempCtx.fillText(title, tempCanvas.width / 2, 35);
        
        tempCtx.font = '16px monospace';
        let accountText = '';
        if (this.isAllPlatforms) {
          accountText = 'All MoonMedia Platforms';
        } else if (this.isMoonMediaTotal) {
          accountText = 'All MoonMedia';
        } else {
          accountText = '@' + this.selectedAccount;
        }
        
        let rangeText = '';
        if (this.selectedTimeRange === 'all') rangeText = '(All Time)';
        else if (this.selectedTimeRange === 365) rangeText = '(Last 1 Year)';
        else if (this.selectedTimeRange === 180) rangeText = '(Last 6 Months)';
        else if (this.selectedTimeRange === 30) rangeText = '(Last 1 Month)';
        
        tempCtx.fillText(`${accountText} ${rangeText}`, tempCanvas.width / 2, 60);
        
        tempCtx.drawImage(canvas, 0, 80);
        
        const link = document.createElement('a');
        const platformSuffix = this.isAllPlatforms ? 'all_platforms' : this.selectedPlatform;
        link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${accountText.replace('@', '')}_${platformSuffix}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      },
      // Chart creation functions continued
      createLineChart(container, title, historyData, datasets, useLog, chartId) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allValues = datasets.flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'day',
                  displayFormats: { day: 'MMM d, yyyy' }
                },
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLog ? 'logarithmic' : 'linear',
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRange);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      createTimeBasedChart(container, title, videos, datasets, useLog, chartId, includeTrendline = false) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        if (includeTrendline) {
          const trendlineBadge = document.createElement('span');
          trendlineBadge.className = 'trendline-badge inactive';
          trendlineBadge.textContent = 'TREND OFF';
          trendlineBadge.setAttribute('data-trendline-id', chartId);
          trendlineBadge.onclick = () => this.toggleTrendline(chartId);
          header.appendChild(trendlineBadge);
          
          this.trendlineStates[chartId] = false;
          this.trendlineDaysAverage[chartId] = 7;
          
          const smoothnessControls = document.createElement('span');
          smoothnessControls.className = 'smoothness-controls';
          smoothnessControls.setAttribute('data-smoothness-controls', chartId);
          smoothnessControls.style.display = 'none';
          
          const downBtn = document.createElement('button');
          downBtn.className = 'smoothness-btn';
          downBtn.textContent = '';
          downBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, -1);
          
          const daysDisplay = document.createElement('span');
          daysDisplay.className = 'smoothness-btn';
          daysDisplay.textContent = '7';
          daysDisplay.style.cursor = 'default';
          daysDisplay.setAttribute('data-days-display', chartId);
          
          const upBtn = document.createElement('button');
          upBtn.className = 'smoothness-btn';
          upBtn.textContent = '';
          upBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, 1);
          
          smoothnessControls.appendChild(downBtn);
          smoothnessControls.appendChild(daysDisplay);
          smoothnessControls.appendChild(upBtn);
          
          header.appendChild(smoothnessControls);
        }
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        // Ensure scatter plot is behind trendline
        datasets[0].order = 1;
        
        if (includeTrendline && datasets.length > 0) {
          const trendlineData = this.calculateMovingAverageByDays(datasets[0].data, 7);
          
          datasets.push({
            label: 'Trend',
            data: trendlineData,
            type: 'line',
            borderColor: '#ffff00',
            backgroundColor: 'transparent',
            borderWidth: 3,
            pointRadius: 0,
            tension: 0.4,
            yAxisID: 'y1',
            hidden: true,
            order: -1  // Trendline on top
          });
        }
        
        const allValues = datasets.filter(ds => ds.label !== 'Trend')
          .flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        const scales = {
          x: {
            type: 'time',
            time: {
              unit: 'day',
              displayFormats: { day: 'MMM d, yyyy' }
            },
            ticks: { color: '#0f0', font: { family: 'monospace' } },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          },
          y: {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'left',
            ticks: {
              color: '#0f0',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          }
        };
        
        if (includeTrendline) {
          scales.y1 = {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'right',
            display: false,
            ticks: {
              color: '#ffff00',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: {
              drawOnChartArea: false
            }
          };
        }
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: datasets[0].type || 'scatter',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 },
                  filter: (item) => {
                    if (item.text === 'Trend') {
                      return this.trendlineStates[chartId] === true;
                    }
                    return true;
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: scales
          }
        });
      },
      
      createCorrelationChart(container) {
        const correlationValues = this.accountData.videos.map(v => v.views);
        const useLogCorrelation = this.shouldUseLogScale(correlationValues);
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'correlation';
        
        const header = document.createElement('h3');
        header.textContent = 'Likes vs Views Correlation';
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLogCorrelation ? '' : ' inactive');
        scaleBadge.textContent = useLogCorrelation ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', 'correlation');
        scaleBadge.onclick = () => this.toggleLogScale('correlation');
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart('correlation', 'Likes vs Views Correlation');
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allViews = this.accountData.videos.map(v => v.views).filter(v => v > 0);
        const allLikes = this.accountData.videos.map(v => v.likes).filter(v => v > 0);
        const dataRangeX = {
          min: Math.min(...allViews),
          max: Math.max(...allViews)
        };
        const dataRangeY = {
          min: Math.min(...allLikes),
          max: Math.max(...allLikes)
        };
        
        this.chartInstances['correlation'] = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [{
              label: 'Posts',
              data: this.accountData.videos.map(v => ({ x: v.views, y: v.likes })),
              backgroundColor: 'rgba(0, 210, 211, 0.6)',
              borderColor: '#00d2d3',
              pointRadius: 6,
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return 'Views: ' + this.formatNumber(context.parsed.x) + 
                           ', Likes: ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Views',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeX);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Likes',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeY);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Main dashboard rendering
      renderDashboard() {
        // Reset chart instances
        this.chartInstances = {};
        this.trendlineStates = {};
        this.trendlineDaysAverage = {};
        
        const statsContainer = document.getElementById('statsSummary');
        const chartsContainer = document.getElementById('chartsList');
        chartsContainer.innerHTML = '';
        
        // Determine content type based on platform
        let contentType = 'POSTS';
        if (this.selectedPlatform === 'instagram') contentType = 'REELS';
        else if (this.selectedPlatform === 'youtube') contentType = 'SHORTS';
        
        // Render summary statistics
        let statsHTML = `
          <div class="stat-card">
            <h4>FOLLOWERS</h4>
            <div class="value">${this.formatNumber(this.accountData.followers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(this.accountData.totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>${contentType} TRACKED</h4>
            <div class="value">${this.accountData.postsScraped}</div>
          </div>
          <div class="stat-card">
            <h4>AVG ENGAGEMENT</h4>
            <div class="value">${this.accountData.videos.length > 0 ? 
              (this.accountData.videos.reduce((sum, v) => sum + v.engagement, 0) / 
               this.accountData.videos.length).toFixed(2) : 0}%</div>
          </div>
        `;
        
        if (this.isMoonMediaTotal) {
          statsHTML += `
            <div class="stat-card">
              <h4>TOTAL VIEWS</h4>
              <div class="value">${this.formatNumber(this.accountData.totalViews)}</div>
            </div>
            <div class="stat-card">
              <h4>VIEWS PER SECOND</h4>
              <div class="value">${this.accountData.viewsPerSecond.toFixed(2)}</div>
            </div>
            <div class="stat-card">
              <h4>TOTAL ACCOUNTS</h4>
              <div class="value">${this.accountData.accountCount}</div>
            </div>
          `;
        }
        
        statsContainer.innerHTML = statsHTML;
        
        // Create charts
        if (this.accountData.followersHistory && this.accountData.followersHistory.length > 0) {
          const followerValues = this.accountData.followersHistory.map(h => h.value);
          const useLogFollowers = this.shouldUseLogScale(followerValues);
          
          this.createLineChart(chartsContainer, 'Followers Growth', 
            this.accountData.followersHistory,
            [{
              label: 'Followers',
              data: this.accountData.followersHistory.map(h => ({ x: h.date, y: h.value })),
              borderColor: '#9b59b6',
              backgroundColor: 'rgba(155, 89, 182, 0.1)',
              borderWidth: 3,
              tension: 0.4,
              fill: true
            }],
            useLogFollowers,
            'followers-history'
          );
        }
        
        if (this.accountData.totalLikesHistory && this.accountData.totalLikesHistory.length > 0) {
          const likesHistoryValues = this.accountData.totalLikesHistory.map(h => h.value);
          const useLogLikesHistory = this.shouldUseLogScale(likesHistoryValues);
          
          this.createLineChart(chartsContainer, 'Total Likes Growth',
            this.accountData.totalLikesHistory,
            [{
              label: 'Total Likes',
              data: this.accountData.totalLikesHistory.map(h => ({ x: h.date, y: h.value })),
              borderColor: '#e91e63',
              backgroundColor: 'rgba(233, 30, 99, 0.1)',
              borderWidth: 3,
              tension: 0.4,
              fill: true
            }],
            useLogLikesHistory,
            'likes-history'
          );
        }
        
        if (this.accountData.videos.length > 0) {
          const viewsData = this.accountData.videos.map(v => v.views);
          const likesData = this.accountData.videos.map(v => v.likes);
          const useLogViews = this.shouldUseLogScale(viewsData);
          const useLogLikes = this.shouldUseLogScale(likesData);
          
          this.createTimeBasedChart(chartsContainer, 'Views Over Time',
            this.accountData.videos,
            [{
              label: 'Views',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.views })),
              borderColor: '#00d2d3',
              backgroundColor: 'rgba(0, 210, 211, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogViews,
            'views-time',
            true
          );
          
          this.createTimeBasedChart(chartsContainer, 'Likes Over Time',
            this.accountData.videos,
            [{
              label: 'Likes',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.likes })),
              borderColor: '#ff6b6b',
              backgroundColor: 'rgba(255, 107, 107, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogLikes,
            'likes-time',
            true
          );
          
          this.createTimeBasedChart(chartsContainer, 'Engagement Rate Over Time',
            this.accountData.videos,
            [{
              label: 'Engagement %',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.engagement })),
              borderColor: '#2ecc71',
              backgroundColor: 'rgba(46, 204, 113, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            false,
            'engagement-time',
            true
          );
          
          const commentsData = this.accountData.videos.map(v => v.comments);
          const useLogComments = this.shouldUseLogScale(commentsData);
          
          this.createTimeBasedChart(chartsContainer, 'Comments Over Time',
            this.accountData.videos,
            [{
              label: 'Comments',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.comments })),
              borderColor: '#1abc9c',
              backgroundColor: 'rgba(26, 188, 156, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogComments,
            'comments-time',
            true
          );
          
          if (this.selectedPlatform === 'tiktok') {
            const sharesData = this.accountData.videos.map(v => v.shares);
            const useLogShares = this.shouldUseLogScale(sharesData);
            
            this.createTimeBasedChart(chartsContainer, 'Shares Over Time',
              this.accountData.videos,
              [{
                label: 'Shares',
                data: this.accountData.videos.map(v => ({ x: v.date, y: v.shares })),
                borderColor: '#e74c3c',
                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                pointRadius: 4,
                pointHoverRadius: 6
              }],
              useLogShares,
              'shares-time',
              true
            );
          }
          
          // Create correlation chart
          this.createCorrelationChart(chartsContainer);
        }
      },
      
      // Render all platforms dashboard
      renderAllPlatformsDashboard() {
        // Reset chart instances
        this.chartInstances = {};
        this.trendlineStates = {};
        this.trendlineDaysAverage = {};
        
        const statsContainer = document.getElementById('statsSummary');
        const platformBreakdown = document.getElementById('platformBreakdown');
        const chartsContainer = document.getElementById('chartsList');
        
        platformBreakdown.classList.remove('hidden');
        chartsContainer.innerHTML = '';
        
        // Combined statistics
        const combined = this.allPlatformsData.combined;
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>TOTAL FOLLOWERS</h4>
            <div class="value">${this.formatNumber(combined.totalFollowers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(combined.totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL VIEWS</h4>
            <div class="value">${this.formatNumber(combined.totalViews)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL POSTS</h4>
            <div class="value">${combined.totalPosts}</div>
          </div>
          <div class="stat-card">
            <h4>VIEWS PER SECOND</h4>
            <div class="value">${combined.viewsPerSecond.toFixed(2)}</div>
          </div>
          <div class="stat-card">
            <h4>AVG VIEWS/SEC</h4>
            <div class="value">${combined.viewsPerSecond > 0 ? 
              combined.viewsPerSecond.toFixed(2) : 'N/A'}</div>
          </div>
        `;
        
        // Platform breakdown
        let breakdownHTML = '<h3 style="color: #ffff00;">Platform Breakdown</h3><div class="stats-summary">';
        
        const platforms = [
          { key: 'instagram', name: 'Instagram' },
          { key: 'tiktok', name: 'TikTok' },
          { key: 'youtube', name: 'YouTube' }
        ];
        
        platforms.forEach(platform => {
          const data = this.allPlatformsData[platform.key];
          if (data) {
            breakdownHTML += `
              <div class="platform-stats">
                <h3>${platform.name}</h3>
                <div>Followers: ${this.formatNumber(data.followers)}</div>
                <div>Likes: ${this.formatNumber(data.totalLikes)}</div>
                <div>Views: ${this.formatNumber(data.totalViews)}</div>
                <div>Posts: ${data.postsScraped}</div>
                <div>Accounts: ${data.accountCount}</div>
              </div>
            `;
          }
        });
        
        breakdownHTML += '</div>';
        platformBreakdown.innerHTML = breakdownHTML;
        
        // Create combined charts
        this.createCombinedPlatformCharts(chartsContainer);
      },
      
      // Create combined platform charts
      createCombinedPlatformCharts(container) {
        // Views by platform comparison
        const platformNames = [];
        const platformViews = [];
        const platformLikes = [];
        const platformFollowers = [];
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          if (this.allPlatformsData[platform]) {
            platformNames.push(platform.charAt(0).toUpperCase() + platform.slice(1));
            platformViews.push(this.allPlatformsData[platform].totalViews);
            platformLikes.push(this.allPlatformsData[platform].totalLikes);
            platformFollowers.push(this.allPlatformsData[platform].followers);
          }
        });
        
        // Platform comparison chart
        const comparisonDiv = document.createElement('div');
        comparisonDiv.className = 'chart-container';
        
        const comparisonCanvas = document.createElement('canvas');
        comparisonCanvas.id = 'platform-comparison';
        
        const comparisonHeader = document.createElement('h3');
        comparisonHeader.textContent = 'Platform Comparison';
        
        comparisonDiv.appendChild(comparisonHeader);
        comparisonDiv.appendChild(comparisonCanvas);
        container.appendChild(comparisonDiv);
        
        const comparisonCtx = comparisonCanvas.getContext('2d');
        
        new Chart(comparisonCtx, {
          type: 'bar',
          data: {
            labels: platformNames,
            datasets: [
              {
                label: 'Views',
                data: platformViews,
                backgroundColor: '#00d2d3',
                borderColor: '#00d2d3',
                borderWidth: 2
              },
              {
                label: 'Likes',
                data: platformLikes,
                backgroundColor: '#ff6b6b',
                borderColor: '#ff6b6b',
                borderWidth: 2
              },
              {
                label: 'Followers',
                data: platformFollowers,
                backgroundColor: '#9b59b6',
                borderColor: '#9b59b6',
                borderWidth: 2
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: 'logarithmic',
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumber(value);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      }
    };
    
    // Initialize the app when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
