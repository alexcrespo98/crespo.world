<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>crespomize - crespo.world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 2em;
    }
    nav {
      margin-bottom: 2em;
    }
    nav a {
      color: #0f0;
      text-decoration: none;
      margin: 0 1em;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    h1 { 
      font-size: 2.5em; 
      margin-bottom: 0.5em; 
      text-shadow: 0 0 10px #0f0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2em;
      border: 2px solid #0f0;
      background: #111;
      border-radius: 10px;
      text-align: left;
    }
    .question {
      margin: 2em 0;
      font-size: 1.2em;
    }
    button {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em 1.5em;
      margin: 0.5em;
      cursor: pointer;
      font-family: monospace;
      font-size: 1em;
      transition: all 0.3s;
    }
    button:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 15px #0f0;
    }
    select {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.8em;
      font-family: monospace;
      font-size: 1em;
      width: 100%;
      margin: 1em 0;
      cursor: pointer;
    }
    select option {
      background: #000;
      color: #0f0;
    }
    select option:disabled {
      color: #666;
    }
    .hidden {
      display: none;
    }
    #charts {
      margin-top: 2em;
    }
    .chart-container {
      margin: 2em 0;
      padding: 1.5em;
      border: 2px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
      position: relative;
    }
    .chart-container h3 {
      color: #0f0;
      margin-bottom: 1em;
      font-size: 1.3em;
      display: inline-block;
    }
    canvas {
      max-width: 100%;
    }
    .loading {
      font-size: 1.5em;
      margin: 2em;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1em;
      margin: 2em 0;
    }
    .stat-card {
      background: #0a0a0a;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 1.5em;
    }
    .stat-card h4 {
      margin: 0 0 0.5em 0;
      color: #0f0;
      font-size: 0.9em;
    }
    .stat-card .value {
      font-size: 1.8em;
      font-weight: bold;
      color: #0f0;
    }
    .moonmedia-option {
      font-weight: bold;
      color: #ffff00;
    }
    .time-range-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1em;
      margin: 1em 0;
    }
    .time-range-buttons button.active {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 15px #0f0;
    }
    .custom-date-slider-container {
      margin: 2em 0 1em 0;
      padding: 1.5em;
      border: 1px solid #0f0;
      border-radius: 5px;
      background: #0a0a0a;
    }
    .custom-date-slider-label {
      margin-bottom: 1em;
      color: #0f0;
      font-size: 0.9em;
    }
    .dual-slider-wrapper {
      position: relative;
      height: 40px;
      margin: 1em 0;
    }
    .slider-track {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
    }
    .slider-range {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      height: 6px;
      background: #0f0;
      border-radius: 3px;
    }
    .range-input {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 6px;
      background: none;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
    }
    .range-input::-webkit-slider-thumb {
      pointer-events: all;
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #0f0;
      border: 3px solid #000;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #0f0;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .range-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px #0f0;
    }
    .range-input::-moz-range-thumb {
      pointer-events: all;
      width: 20px;
      height: 20px;
      background: #0f0;
      border: 3px solid #000;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px #0f0;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .range-input::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px #0f0;
    }
    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5em;
      font-size: 0.85em;
      color: #0f0;
    }
    .slider-date-display {
      text-align: center;
      margin-top: 1em;
      font-size: 1em;
      color: #0f0;
      background: #000;
      padding: 0.5em 1em;
      border: 1px solid #0f0;
      border-radius: 3px;
      display: inline-block;
    }
    .slider-apply-btn {
      margin-top: 1em;
      background: #0f0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.6em 1.5em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.9em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 3px;
    }
    .slider-apply-btn:hover {
      background: #00ff7f;
      box-shadow: 0 0 15px #0f0;
    }
    .scale-badge {
      display: inline-block;
      background: #0f0;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .scale-badge:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .scale-badge.inactive {
      background: #333;
      color: #666;
    }
    .trendline-badge {
      display: inline-block;
      background: #ffff00;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .trendline-badge:hover {
      background: #ffdd00;
      box-shadow: 0 0 10px #ffff00;
    }
    .trendline-badge.inactive {
      background: #333;
      color: #666;
    }
    .mode-toggle-badge {
      display: inline-block;
      background: #00d2d3;
      color: #000;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-size: 0.8em;
      margin-left: 0.5em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .mode-toggle-badge:hover {
      background: #00e5e6;
      box-shadow: 0 0 10px #00d2d3;
    }
    .mode-toggle-badge.cumulative {
      background: #ff6b6b;
    }
    .mode-toggle-badge.cumulative:hover {
      background: #ff8080;
      box-shadow: 0 0 10px #ff6b6b;
    }
    .smoothness-controls {
      display: inline-block;
      margin-left: 0.3em;
      vertical-align: middle;
    }
    .smoothness-btn {
      background: #ffff00;
      color: #000;
      border: 2px solid #ffff00;
      padding: 0.2em 0.5em;
      margin: 0 0.1em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.8em;
      font-weight: bold;
      transition: all 0.3s;
      user-select: none;
      display: inline-block;
      min-width: 30px;
    }
    .smoothness-btn:hover {
      background: #ffdd00;
      box-shadow: 0 0 5px #ffff00;
    }
    .smoothness-btn:active {
      transform: scale(0.95);
    }
    .export-btn {
      position: absolute;
      top: 1.5em;
      right: 1.5em;
      background: #0f0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.4em 0.8em;
      cursor: pointer;
      font-family: monospace;
      font-size: 0.85em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 3px;
    }
    .export-btn:hover {
      background: #00d2d3;
      box-shadow: 0 0 10px #0f0;
    }
    .looks-good-btn {
      background: #00ff00;
      color: #000;
      border: 3px solid #00ff00;
      padding: 1em 2em;
      cursor: pointer;
      font-family: monospace;
      font-size: 1.2em;
      font-weight: bold;
      transition: all 0.3s;
      border-radius: 8px;
      text-transform: uppercase;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
    }
    .looks-good-btn:hover {
      background: #00d2d3;
      border-color: #00d2d3;
      box-shadow: 0 0 25px rgba(0, 210, 211, 0.5);
      transform: scale(1.05);
    }
    .export-section {
      margin-top: 2em;
      padding: 1.5em;
      border: 2px solid #0f0;
      border-radius: 10px;
      background: rgba(0, 255, 0, 0.05);
    }
    .no-data-message {
      text-align: center;
      padding: 3em;
      color: #ff0;
      font-size: 1.2em;
      border: 2px dashed #ff0;
      border-radius: 10px;
      margin: 2em 0;
      background: rgba(255, 255, 0, 0.05);
    }
    .platform-stats {
      background: #0a0a0a;
      border: 2px solid #ffff00;
      border-radius: 10px;
      padding: 1.5em;
      margin: 1.5em 0;
    }
    .platform-stats h3 {
      color: #ffff00;
      margin-bottom: 1em;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">home</a>
    <a href="chemocam.html">chemocam</a>
    <a href="crespomize.html">crespomize</a>
  </nav>

  <h1>crespomize analytics</h1>
  
  <div class="container">
    <!-- Step 0: Analytics Type Selection -->
    <div id="step0" class="step">
      <div class="question">what type of analytics?</div>
      <select id="analyticsTypeSelect">
        <option value="" disabled selected>-- select analytics type --</option>
        <option value="easy">Weekly Analytics (this week's progress)</option>
        <option value="custom">Custom Analytics</option>
      </select>
    </div>

    <!-- Easy Graphs Section (now Weekly Analytics) -->
    <div id="easyGraphsSection" class="step hidden">
      <div class="question">select week for analytics:</div>
      <select id="monthSelect">
        <option value="" disabled selected>-- select week --</option>
      </select>
      <div id="easyGraphsContainer" class="hidden">
        <div class="question" id="easyGraphsTitle"></div>
        <div class="stats-summary" id="easyStatsSummary"></div>
        <div id="easyChartsList"></div>
        <div class="export-section" style="text-align: center; margin-top: 2em;">
          <button id="looksGoodBtn" class="looks-good-btn" onclick="app.exportClientReport()">
            âœ“ Looks Good - Export PDF
          </button>
        </div>
        <br>
        <button onclick="location.reload()">start over</button>
      </div>
    </div>

    <!-- Custom Analytics: Platform selection -->
    <div id="step0Custom" class="step hidden">
      <div class="question">which platform?</div>
      <select id="platformSelect">
        <option value="" disabled selected>-- select platform --</option>
        <option value="all" class="moonmedia-option">All MoonMedia Platforms</option>
        <option value="instagram">Instagram Reels</option>
        <option value="tiktok">TikTok</option>
        <option value="youtube">YouTube Shorts</option>
      </select>
    </div>

    <!-- Step 1: Select account (for single platform) -->
    <div id="step1" class="step hidden">
      <div class="question">pick a company:</div>
      <select id="accountSelect">
        <option value="" disabled selected>-- select an account --</option>
      </select>
    </div>

    <!-- Step 2: Time range selection -->
    <div id="step2" class="step hidden">
      <div class="question">select time range for analysis:</div>
      <div class="time-range-buttons" id="timeRangeButtons">
        <button id="btn-all" onclick="app.selectPresetTimeRange('all')">All Time</button>
        <button id="btn-365" onclick="app.selectPresetTimeRange(365)">1 Year</button>
        <button id="btn-180" onclick="app.selectPresetTimeRange(180)">6 Months</button>
        <button id="btn-30" onclick="app.selectPresetTimeRange(30)">1 Month</button>
      </div>
      
      <!-- Custom Date Range Slider -->
      <div class="custom-date-slider-container" id="customDateSliderContainer">
        <div class="custom-date-slider-label">or choose a custom date range:</div>
        <div class="dual-slider-wrapper">
          <div class="slider-track"></div>
          <div class="slider-range" id="sliderRange"></div>
          <input type="range" class="range-input" id="rangeMin" min="0" max="100" value="0">
          <input type="range" class="range-input" id="rangeMax" min="0" max="100" value="100">
        </div>
        <div class="slider-labels">
          <span id="minDateLabel">--</span>
          <span id="maxDateLabel">--</span>
        </div>
        <div style="text-align: center;">
          <div class="slider-date-display">
            <span id="selectedStartDate">--</span> to <span id="selectedEndDate">--</span>
          </div>
          <br>
          <button class="slider-apply-btn" onclick="app.applyCustomDateRange()">Apply Custom Range</button>
        </div>
      </div>
    </div>

    <!-- Charts display -->
    <div id="charts" class="hidden">
      <div class="question">analytics for <span id="accountName"></span> <span id="timeRangeLabel"></span></div>
      
      <!-- Summary stats -->
      <div class="stats-summary" id="statsSummary"></div>
      
      <!-- Platform breakdown for "All MoonMedia" -->
      <div id="platformBreakdown" class="hidden"></div>
      
      <!-- Charts -->
      <div id="chartsList"></div>
      <br>
      <button onclick="location.reload()">start over</button>
    </div>

    <div id="loading" class="loading hidden">loading data...</div>
  </div>

  <script>
    // Application state
    const app = {
      // Configuration
      SHEET_IDS: {
        tiktok: '1FUGfhPVsVi1WOOw88BKfUKueJh4eMPj1',
        instagram: '19PDIP7_YaluxsmvQsDJ89Bn5JkXnK2n2',
        youtube: '1yRLZpJLdaB9oPZtjcwIeJx-6q8lGF2dO'
      },
      
      // Explicit account mapping across platforms
      // Maps a canonical name to the actual account names on each platform
      ACCOUNT_MAPPING: {
        'popdartsgame': { instagram: 'popdartsgame', tiktok: 'popdartsgame', youtube: 'popdartsgame' },
        'bucketgolfgame': { instagram: 'bucketgolfgame', tiktok: 'bucketgolfgame', youtube: 'bucketgolfgame' },
        'playbattlegolf': { instagram: 'playbattlegolf', tiktok: 'playbattlegolf', youtube: 'playbattlegolf' },
        'flinggolf': { instagram: 'flinggolf', tiktok: 'flinggolf', youtube: 'flinggolf' },
        'golfponggames': { instagram: 'golfponggames', tiktok: 'golfponggames', youtube: 'golfponggames' },
        'discgogames': { instagram: 'discgogames', tiktok: 'discgogames', youtube: 'discgogames' },
        'lowtidegolf': { instagram: 'lowtidegolf', tiktok: 'lowtidegolf', youtube: 'lowtidegolf' }
      },
      
      // Smoothness constants for exponential smoothing
      SMOOTHNESS: {
        MIN_LEVEL: 1,
        MAX_LEVEL: 10,
        DEFAULT_LEVEL: 5,
        MAX_ALPHA: 0.5,    // Most responsive (smoothness level 1)
        MIN_ALPHA: 0.05,   // Smoothest (smoothness level 10)
        ALPHA_RANGE: 0.45  // MAX_ALPHA - MIN_ALPHA
      },
      
      // State variables
      selectedPlatform: '',
      workbookData: null,
      selectedAccount: '',
      accountData: {},
      isMoonMediaTotal: false,
      isAllPlatforms: false,
      selectedTimeRange: 'all',
      chartInstances: {},
      trendlineStates: {},
      trendlineDaysAverage: {},
      trendlineSmoothnessLevel: {},
      chartModeStates: {},
      chartMetricKeys: {},
      allPlatformsData: {},
      allVideosUnfiltered: [],
      
      // Easy graphs state
      easyGraphsData: {},
      currentEasyGraphsMonth: null,
      currentEasyGraphsYear: null,
      
      // Custom date range slider state
      dataDateRange: { min: null, max: null },
      customDateRange: { start: null, end: null },
      
      // Initialize the application
      init() {
        this.setupEventListeners();
        this.setupSliderListeners();
      },
      
      // Setup slider event listeners
      setupSliderListeners() {
        const rangeMin = document.getElementById('rangeMin');
        const rangeMax = document.getElementById('rangeMax');
        
        rangeMin.addEventListener('input', () => this.updateSlider());
        rangeMax.addEventListener('input', () => this.updateSlider());
      },
      
      // Update the slider UI
      updateSlider() {
        const rangeMin = document.getElementById('rangeMin');
        const rangeMax = document.getElementById('rangeMax');
        const sliderRange = document.getElementById('sliderRange');
        
        let minVal = parseInt(rangeMin.value);
        let maxVal = parseInt(rangeMax.value);
        
        // Prevent handles from crossing and ensure values are within bounds
        if (minVal > maxVal - 1) {
          if (this.lastChanged === 'min') {
            minVal = Math.min(maxVal - 1, 99);
            minVal = Math.max(minVal, 0);
            rangeMin.value = minVal;
          } else {
            maxVal = Math.min(minVal + 1, 100);
            maxVal = Math.max(maxVal, 1);
            rangeMax.value = maxVal;
          }
        }
        
        this.lastChanged = (document.activeElement === rangeMin) ? 'min' : 'max';
        
        // Update the range highlight
        const percent1 = minVal;
        const percent2 = maxVal;
        sliderRange.style.left = percent1 + '%';
        sliderRange.style.width = (percent2 - percent1) + '%';
        
        // Calculate and display dates
        if (this.dataDateRange.min && this.dataDateRange.max) {
          const totalDays = Math.floor((this.dataDateRange.max - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          
          const startDays = Math.floor(totalDays * (minVal / 100));
          const endDays = Math.floor(totalDays * (maxVal / 100));
          
          const startDate = new Date(this.dataDateRange.min);
          startDate.setDate(startDate.getDate() + startDays);
          
          const endDate = new Date(this.dataDateRange.min);
          endDate.setDate(endDate.getDate() + endDays);
          
          this.customDateRange.start = startDate;
          this.customDateRange.end = endDate;
          
          document.getElementById('selectedStartDate').textContent = this.formatDate(startDate);
          document.getElementById('selectedEndDate').textContent = this.formatDate(endDate);
        }
        
        // Clear active state from preset buttons
        document.querySelectorAll('#timeRangeButtons button').forEach(btn => {
          btn.classList.remove('active');
        });
      },
      
      // Format date for display
      formatDate(date) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      },
      
      // Initialize slider with data range
      initializeSliderWithData(minDate = null, maxDate = null) {
        // Use provided dates or fallback to defaults
        const now = new Date();
        let actualMin = minDate;
        let actualMax = maxDate || now;
        
        // If no min date provided, use a reasonable default (10 years back)
        if (!actualMin) {
          actualMin = new Date();
          actualMin.setFullYear(actualMin.getFullYear() - 10);
        }
        
        this.dataDateRange.min = actualMin;
        this.dataDateRange.max = actualMax;
        
        document.getElementById('minDateLabel').textContent = this.formatDate(actualMin);
        document.getElementById('maxDateLabel').textContent = this.formatDate(actualMax);
        
        // Initialize slider to full range
        document.getElementById('rangeMin').value = 0;
        document.getElementById('rangeMax').value = 100;
        
        this.customDateRange.start = actualMin;
        this.customDateRange.end = actualMax;
        
        document.getElementById('selectedStartDate').textContent = this.formatDate(actualMin);
        document.getElementById('selectedEndDate').textContent = this.formatDate(actualMax);
        
        // Update slider range highlight
        const sliderRange = document.getElementById('sliderRange');
        sliderRange.style.left = '0%';
        sliderRange.style.width = '100%';
      },
      
      // Update slider range with actual data dates
      updateSliderWithDataRange(videos, totalLikesHistory = [], followersHistory = []) {
        let minDate = null;
        let maxDate = null;
        
        // Extract dates from videos
        if (videos && videos.length > 0) {
          const videoDates = videos.filter(v => v.date && this.isValidDate(v.date)).map(v => v.date);
          if (videoDates.length > 0) {
            minDate = new Date(Math.min(...videoDates.map(d => d.getTime())));
            maxDate = new Date(Math.max(...videoDates.map(d => d.getTime())));
          }
        }
        
        // Also consider totalLikesHistory dates (may go back further)
        if (totalLikesHistory && totalLikesHistory.length > 0) {
          const historyDates = totalLikesHistory.filter(h => h.date && this.isValidDate(h.date)).map(h => h.date);
          if (historyDates.length > 0) {
            const historyMin = new Date(Math.min(...historyDates.map(d => d.getTime())));
            const historyMax = new Date(Math.max(...historyDates.map(d => d.getTime())));
            if (!minDate || historyMin < minDate) minDate = historyMin;
            if (!maxDate || historyMax > maxDate) maxDate = historyMax;
          }
        }
        
        // Also consider followersHistory dates
        if (followersHistory && followersHistory.length > 0) {
          const historyDates = followersHistory.filter(h => h.date && this.isValidDate(h.date)).map(h => h.date);
          if (historyDates.length > 0) {
            const historyMin = new Date(Math.min(...historyDates.map(d => d.getTime())));
            const historyMax = new Date(Math.max(...historyDates.map(d => d.getTime())));
            if (!minDate || historyMin < minDate) minDate = historyMin;
            if (!maxDate || historyMax > maxDate) maxDate = historyMax;
          }
        }
        
        // If we found valid dates, update the slider
        if (minDate && maxDate) {
          this.initializeSliderWithData(minDate, maxDate);
        }
      },
        
      
      // Select preset time range (from button click)
      selectPresetTimeRange(days) {
        // Update active button state
        document.querySelectorAll('#timeRangeButtons button').forEach(btn => {
          btn.classList.remove('active');
        });
        
        const btnId = days === 'all' ? 'btn-all' : `btn-${days}`;
        document.getElementById(btnId).classList.add('active');
        
        // Update slider to match preset
        if (this.dataDateRange.min && this.dataDateRange.max) {
          const now = new Date();
          let startDate;
          
          if (days === 'all') {
            startDate = this.dataDateRange.min;
          } else {
            // Create a new date by subtracting milliseconds (more robust than setDate)
            const daysInMs = days * 24 * 60 * 60 * 1000;
            startDate = new Date(now.getTime() - daysInMs);
            if (startDate < this.dataDateRange.min) {
              startDate = this.dataDateRange.min;
            }
          }
          
          const totalDays = Math.floor((this.dataDateRange.max - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          const startDays = Math.floor((startDate - this.dataDateRange.min) / (1000 * 60 * 60 * 24));
          
          const minPercent = totalDays > 0 ? Math.round((startDays / totalDays) * 100) : 0;
          const maxPercent = 100;
          
          document.getElementById('rangeMin').value = minPercent;
          document.getElementById('rangeMax').value = maxPercent;
          
          this.customDateRange.start = startDate;
          this.customDateRange.end = now;
          
          document.getElementById('selectedStartDate').textContent = this.formatDate(startDate);
          document.getElementById('selectedEndDate').textContent = this.formatDate(now);
          
          const sliderRange = document.getElementById('sliderRange');
          sliderRange.style.left = minPercent + '%';
          sliderRange.style.width = (maxPercent - minPercent) + '%';
        }
        
        // Apply the selection
        this.selectTimeRange(days);
      },
      
      // Apply custom date range
      applyCustomDateRange() {
        if (!this.customDateRange.start || !this.customDateRange.end) {
          return;
        }
        
        // Calculate days from start to end
        const daysDiff = Math.floor((this.customDateRange.end - this.customDateRange.start) / (1000 * 60 * 60 * 24));
        
        // Store custom range for filtering
        this.selectedTimeRange = 'custom';
        this.customStartDate = this.customDateRange.start;
        this.customEndDate = this.customDateRange.end;
        
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        
        if (this.isAllPlatforms) {
          this.loadAllPlatformsData('custom');
        } else {
          setTimeout(() => {
            this.processData('custom');
            this.finalizeDataDisplay('custom');
          }, 1000);
        }
      },
      
      // Setup all event listeners
      setupEventListeners() {
        // Analytics type selection (new first step)
        document.getElementById('analyticsTypeSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectAnalyticsType(e.target.value);
          }
        });
        
        // Platform selection (for custom analytics)
        document.getElementById('platformSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectPlatform(e.target.value);
          }
        });
        
        document.getElementById('accountSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectAccount(e.target.value);
          }
        });
        
        // Month selection (for easy graphs)
        document.getElementById('monthSelect').addEventListener('change', (e) => {
          if (e.target.value) {
            this.selectMonthForEasyGraphs(e.target.value);
          }
        });
      },
      
      // Analytics type selection
      selectAnalyticsType(type) {
        document.getElementById('step0').classList.add('hidden');
        
        if (type === 'easy') {
          this.initializeEasyGraphsMode();
        } else if (type === 'custom') {
          document.getElementById('step0Custom').classList.remove('hidden');
        }
      },
      
      // Initialize Easy Graphs mode
      async initializeEasyGraphsMode() {
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('loading').textContent = 'loading data...';
        
        // Load all platforms data first
        await this.loadAllPlatformsDataForEasyGraphs();
        
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('easyGraphsSection').classList.remove('hidden');
        
        // Populate month dropdown
        this.populateMonthDropdown();
      },
      
      // Load all platforms data for easy graphs
      async loadAllPlatformsDataForEasyGraphs() {
        this.easyGraphsData = {
          instagram: null,
          tiktok: null,
          youtube: null
        };
        
        // Load Instagram data
        try {
          const igResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.instagram}/export?format=xlsx`);
          const igBuffer = await igResponse.arrayBuffer();
          this.easyGraphsData.instagramWorkbook = XLSX.read(igBuffer, { type: 'array' });
          this.easyGraphsData.instagram = this.processWorkbookData(this.easyGraphsData.instagramWorkbook, 'instagram', 'all');
        } catch (error) {
          console.error('Error loading Instagram data:', error);
        }
        
        // Load TikTok data
        try {
          const ttResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.tiktok}/export?format=xlsx`);
          const ttBuffer = await ttResponse.arrayBuffer();
          this.easyGraphsData.tiktokWorkbook = XLSX.read(ttBuffer, { type: 'array' });
          this.easyGraphsData.tiktok = this.processWorkbookData(this.easyGraphsData.tiktokWorkbook, 'tiktok', 'all');
        } catch (error) {
          console.error('Error loading TikTok data:', error);
        }
        
        // Load YouTube data
        try {
          const ytResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.youtube}/export?format=xlsx`);
          const ytBuffer = await ytResponse.arrayBuffer();
          this.easyGraphsData.youtubeWorkbook = XLSX.read(ytBuffer, { type: 'array' });
          this.easyGraphsData.youtube = this.processWorkbookData(this.easyGraphsData.youtubeWorkbook, 'youtube', 'all');
        } catch (error) {
          console.error('Error loading YouTube data:', error);
        }
      },
      
      // Populate week dropdown with current and past 12 weeks
      populateMonthDropdown() {
        const monthSelect = document.getElementById('monthSelect');
        monthSelect.innerHTML = '<option value="" disabled selected>-- select week --</option>';
        
        const now = new Date();
        
        // Constants for week calculations
        const DAYS_IN_WEEK = 7;
        const SUNDAY_INDEX = 0;
        const DAYS_FROM_SUNDAY_TO_MONDAY = 6;
        
        // Get the start of the current week (Monday)
        const currentWeekStart = new Date(now);
        const dayOfWeek = now.getDay();
        // If today is Sunday (0), go back 6 days to Monday; otherwise go back (dayOfWeek - 1) days
        const daysToMonday = dayOfWeek === SUNDAY_INDEX ? DAYS_FROM_SUNDAY_TO_MONDAY : dayOfWeek - 1;
        currentWeekStart.setDate(now.getDate() - daysToMonday);
        currentWeekStart.setHours(0, 0, 0, 0);
        
        // Add current week and previous 12 weeks
        for (let i = 0; i <= 12; i++) {
          const weekStart = new Date(currentWeekStart);
          weekStart.setDate(weekStart.getDate() - (i * DAYS_IN_WEEK));
          
          const weekEnd = new Date(weekStart);
          weekEnd.setDate(weekEnd.getDate() + (DAYS_IN_WEEK - 1));
          weekEnd.setHours(23, 59, 59, 999);
          
          const value = weekStart.toISOString().split('T')[0]; // YYYY-MM-DD format
          
          const formatDate = (d) => {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[d.getMonth()]} ${d.getDate()}`;
          };
          
          let label = `${formatDate(weekStart)} - ${formatDate(weekEnd)}, ${weekEnd.getFullYear()}`;
          
          // Mark current week
          if (i === 0) {
            label = 'This Week (' + label + ')';
          } else if (i === 1) {
            label = 'Last Week (' + label + ')';
          }
          
          const option = document.createElement('option');
          option.value = value;
          option.textContent = label;
          monthSelect.appendChild(option);
        }
      },
      
      // Select week for easy graphs (renamed from selectMonthForEasyGraphs but keeping name for compatibility)
      async selectMonthForEasyGraphs(weekStartValue) {
        // Parse the week start date
        const weekStart = new Date(weekStartValue + 'T00:00:00');
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        const formatDate = (d) => {
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          return `${months[d.getMonth()]} ${d.getDate()}`;
        };
        
        const weekLabel = `${formatDate(weekStart)} - ${formatDate(weekEnd)}, ${weekEnd.getFullYear()}`;
        
        // Show loading
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('loading').textContent = 'generating weekly analytics...';
        
        // Render the weekly graphs
        await this.renderWeeklyGraphs(weekStart, weekEnd, weekLabel);
        
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('easyGraphsContainer').classList.remove('hidden');
        
        // Store current week for PDF export
        this.currentEasyGraphsMonth = weekLabel;
        this.currentEasyGraphsYear = weekEnd.getFullYear();
      },
      
      // Match accounts across platforms using explicit mapping first, then fuzzy matching
      matchAccountsAcrossPlatforms() {
        const platformAccounts = {
          instagram: [],
          tiktok: [],
          youtube: []
        };
        
        // Get account names from each platform
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const workbook = this.easyGraphsData[`${platform}Workbook`];
          if (workbook && workbook.SheetNames) {
            platformAccounts[platform] = workbook.SheetNames;
          }
        });
        
        console.log('Platform accounts found:', platformAccounts);
        
        // Track which accounts have been matched
        const usedAccounts = { instagram: new Set(), tiktok: new Set(), youtube: new Set() };
        const matchedAccounts = [];
        
        // STEP 1: Use explicit account mapping first
        Object.entries(this.ACCOUNT_MAPPING).forEach(([canonicalName, mapping]) => {
          const match = {
            name: canonicalName,
            normalizedName: canonicalName.toLowerCase(),
            instagram: null,
            tiktok: null,
            youtube: null
          };
          
          // Check if mapped accounts exist in each platform
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            const mappedAccount = mapping[platform];
            if (mappedAccount && platformAccounts[platform].includes(mappedAccount)) {
              match[platform] = mappedAccount;
              usedAccounts[platform].add(mappedAccount);
            } else if (mappedAccount) {
              // Try case-insensitive match
              const found = platformAccounts[platform].find(
                a => a.toLowerCase() === mappedAccount.toLowerCase()
              );
              if (found) {
                match[platform] = found;
                usedAccounts[platform].add(found);
              }
            }
          });
          
          // Only add if at least one platform matched
          if (match.instagram || match.tiktok || match.youtube) {
            matchedAccounts.push(match);
            console.log(`Explicit match: ${canonicalName}`, match);
          }
        });
        
        // STEP 2: Fuzzy matching for remaining accounts
        // Account name normalization patterns
        const ACCOUNT_PREFIX_PATTERNS = /^(the_?|official_?)/i;
        const ACCOUNT_SUFFIX_PATTERNS = /(_?official|_?tv|_?shorts|_?reels|_?yt|_?ig|_?tt)$/i;
        const ACCOUNT_SEPARATOR_PATTERN = /[._-]/g;
        const MIN_MATCH_LENGTH = 3;
        
        const normalizeAccountName = (name) => {
          return name.toLowerCase()
            .replace(ACCOUNT_PREFIX_PATTERNS, '')
            .replace(ACCOUNT_SUFFIX_PATTERNS, '')
            .replace(ACCOUNT_SEPARATOR_PATTERN, '')
            .trim();
        };
        
        const namesMatch = (name1, name2) => {
          if (name1 === name2) return true;
          if (name1.length >= MIN_MATCH_LENGTH && name2.length >= MIN_MATCH_LENGTH) {
            return name1.includes(name2) || name2.includes(name1);
          }
          return false;
        };
        
        // Match remaining Instagram accounts
        platformAccounts.instagram.forEach(igAccount => {
          if (usedAccounts.instagram.has(igAccount)) return;
          
          const normalized = normalizeAccountName(igAccount);
          const match = {
            name: igAccount,
            normalizedName: normalized,
            instagram: igAccount,
            tiktok: null,
            youtube: null
          };
          
          // Find matching TikTok account
          platformAccounts.tiktok.forEach(ttAccount => {
            if (!usedAccounts.tiktok.has(ttAccount)) {
              const ttNormalized = normalizeAccountName(ttAccount);
              if (namesMatch(ttNormalized, normalized)) {
                match.tiktok = ttAccount;
                usedAccounts.tiktok.add(ttAccount);
              }
            }
          });
          
          // Find matching YouTube account
          platformAccounts.youtube.forEach(ytAccount => {
            if (!usedAccounts.youtube.has(ytAccount)) {
              const ytNormalized = normalizeAccountName(ytAccount);
              if (namesMatch(ytNormalized, normalized)) {
                match.youtube = ytAccount;
                usedAccounts.youtube.add(ytAccount);
              }
            }
          });
          
          usedAccounts.instagram.add(igAccount);
          matchedAccounts.push(match);
          console.log(`Fuzzy match (IG): ${igAccount}`, match);
        });
        
        // Add any unmatched TikTok accounts
        platformAccounts.tiktok.forEach(ttAccount => {
          if (!usedAccounts.tiktok.has(ttAccount)) {
            const match = {
              name: ttAccount,
              normalizedName: normalizeAccountName(ttAccount),
              instagram: null,
              tiktok: ttAccount,
              youtube: null
            };
            matchedAccounts.push(match);
            console.log(`Unmatched TikTok: ${ttAccount}`, match);
          }
        });
        
        // Add any unmatched YouTube accounts
        platformAccounts.youtube.forEach(ytAccount => {
          if (!usedAccounts.youtube.has(ytAccount)) {
            const match = {
              name: ytAccount,
              normalizedName: normalizeAccountName(ytAccount),
              instagram: null,
              tiktok: null,
              youtube: ytAccount
            };
            matchedAccounts.push(match);
            console.log(`Unmatched YouTube: ${ytAccount}`, match);
          }
        });
        
        console.log('Final matched accounts:', matchedAccounts);
        return matchedAccounts;
      },
      
      // Get account stats for a specific week
      getAccountWeeklyStats(platform, accountName, startDate, endDate) {
        const workbook = this.easyGraphsData[`${platform}Workbook`];
        if (!workbook) {
          console.log(`No workbook for ${platform}`);
          return null;
        }
        
        // Parse account data
        const accountData = this.parseAccountDataFromWorkbook(workbook, accountName, platform, 'all');
        if (!accountData) {
          console.log(`No account data for ${accountName} on ${platform}`);
          return null;
        }
        
        // Filter videos for this week
        const weekVideos = (accountData.videos || []).filter(v => 
          v.date >= startDate && v.date <= endDate
        );
        
        // Calculate weekly stats
        const stats = {
          views: weekVideos.reduce((sum, v) => sum + (v.views || 0), 0),
          likes: weekVideos.reduce((sum, v) => sum + (v.likes || 0), 0),
          comments: weekVideos.reduce((sum, v) => sum + (v.comments || 0), 0),
          posts: weekVideos.length,
          newFollowers: 0,
          currentFollowers: accountData.followers || 0
        };
        
        // Calculate new followers this week
        // Filter out zero/null values first (they indicate scrape errors)
        const validFollowersHistory = (accountData.followersHistory || []).filter(h => h.value > 0);
        
        if (validFollowersHistory.length > 0) {
          const weekHistory = validFollowersHistory.filter(h => 
            h.date >= startDate && h.date <= endDate
          ).sort((a, b) => a.date - b.date);
          
          if (weekHistory.length >= 2) {
            stats.newFollowers = weekHistory[weekHistory.length - 1].value - weekHistory[0].value;
          } else if (weekHistory.length === 1) {
            // Try to find the previous week's last value
            const prevWeekStart = new Date(startDate);
            prevWeekStart.setDate(prevWeekStart.getDate() - 7);
            const prevHistory = validFollowersHistory.filter(h => 
              h.date >= prevWeekStart && h.date < startDate
            ).sort((a, b) => a.date - b.date);
            
            if (prevHistory.length > 0) {
              stats.newFollowers = weekHistory[0].value - prevHistory[prevHistory.length - 1].value;
            }
          }
        }
        
        console.log(`Stats for ${accountName} (${platform}):`, stats);
        return stats;
      },
      
      // Render weekly graphs (replaces renderEasyGraphs for weekly mode)
      async renderWeeklyGraphs(startDate, endDate, weekLabel) {
        const container = document.getElementById('easyChartsList');
        container.innerHTML = '';
        
        // Reset chart instances
        this.chartInstances = {};
        
        document.getElementById('easyGraphsTitle').textContent = 
          `Weekly Analytics: ${weekLabel}`;
        
        // Match accounts across platforms
        const matchedAccounts = this.matchAccountsAcrossPlatforms();
        
        // Calculate stats for each matched account
        const accountStats = [];
        let totalViews = 0;
        let totalLikes = 0;
        let totalComments = 0;
        let totalNewFollowers = 0;
        let totalPosts = 0;
        
        matchedAccounts.forEach(account => {
          const stats = {
            name: account.name,
            instagram: account.instagram ? this.getAccountWeeklyStats('instagram', account.instagram, startDate, endDate) : null,
            tiktok: account.tiktok ? this.getAccountWeeklyStats('tiktok', account.tiktok, startDate, endDate) : null,
            youtube: account.youtube ? this.getAccountWeeklyStats('youtube', account.youtube, startDate, endDate) : null
          };
          
          // Aggregate totals
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (stats[platform]) {
              totalViews += stats[platform].views || 0;
              totalLikes += stats[platform].likes || 0;
              totalComments += stats[platform].comments || 0;
              totalNewFollowers += stats[platform].newFollowers || 0;
              totalPosts += stats[platform].posts || 0;
            }
          });
          
          accountStats.push(stats);
        });
        
        // Render stats summary
        const statsContainer = document.getElementById('easyStatsSummary');
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>TOTAL VIEWS THIS WEEK</h4>
            <div class="value">${this.formatNumber(totalViews)}</div>
          </div>
          <div class="stat-card">
            <h4>NEW FOLLOWERS</h4>
            <div class="value">+${this.formatNumber(totalNewFollowers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL COMMENTS</h4>
            <div class="value">${this.formatNumber(totalComments)}</div>
          </div>
          <div class="stat-card">
            <h4>POSTS THIS WEEK</h4>
            <div class="value">${totalPosts}</div>
          </div>
        `;
        
        // Create per-account breakdown table
        this.createAccountBreakdownTable(container, accountStats);
        
        // Create platform comparison chart for the week
        this.createWeeklyPlatformComparisonChart(container, accountStats);
        
        // Create views by account chart
        this.createWeeklyViewsByAccountChart(container, accountStats);
        
        // Create new followers by account chart
        this.createWeeklyFollowersByAccountChart(container, accountStats);
      },
      
      // Create account breakdown table for weekly analytics
      createAccountBreakdownTable(container, accountStats) {
        const tableDiv = document.createElement('div');
        tableDiv.className = 'chart-container';
        tableDiv.style.overflowX = 'auto';
        
        const header = document.createElement('h3');
        header.textContent = 'Account Performance Breakdown';
        tableDiv.appendChild(header);
        
        const table = document.createElement('table');
        table.style.cssText = 'width: 100%; border-collapse: collapse; color: #0f0; font-family: monospace;';
        
        // Create header row
        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr style="border-bottom: 2px solid #0f0;">
            <th style="padding: 10px; text-align: left;">Account</th>
            <th style="padding: 10px; text-align: center;">IG Views</th>
            <th style="padding: 10px; text-align: center;">TT Views</th>
            <th style="padding: 10px; text-align: center;">YT Views</th>
            <th style="padding: 10px; text-align: center;">Total Views</th>
            <th style="padding: 10px; text-align: center;">New Followers</th>
            <th style="padding: 10px; text-align: center;">Posts</th>
          </tr>
        `;
        table.appendChild(thead);
        
        // Create body rows
        const tbody = document.createElement('tbody');
        accountStats.forEach(account => {
          const igStats = account.instagram || { views: 0, newFollowers: 0, posts: 0 };
          const ttStats = account.tiktok || { views: 0, newFollowers: 0, posts: 0 };
          const ytStats = account.youtube || { views: 0, newFollowers: 0, posts: 0 };
          
          const totalViews = (igStats.views || 0) + (ttStats.views || 0) + (ytStats.views || 0);
          const totalNewFollowers = (igStats.newFollowers || 0) + (ttStats.newFollowers || 0) + (ytStats.newFollowers || 0);
          const totalPosts = (igStats.posts || 0) + (ttStats.posts || 0) + (ytStats.posts || 0);
          
          // Only show accounts with activity
          if (totalViews > 0 || totalNewFollowers > 0 || totalPosts > 0) {
            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid rgba(0, 255, 0, 0.3)';
            row.innerHTML = `
              <td style="padding: 8px; text-align: left;">@${account.name}</td>
              <td style="padding: 8px; text-align: center; color: #E1306C;">${this.formatNumber(igStats.views || 0)}</td>
              <td style="padding: 8px; text-align: center; color: #00f2ea;">${this.formatNumber(ttStats.views || 0)}</td>
              <td style="padding: 8px; text-align: center; color: #FF0000;">${this.formatNumber(ytStats.views || 0)}</td>
              <td style="padding: 8px; text-align: center; font-weight: bold;">${this.formatNumber(totalViews)}</td>
              <td style="padding: 8px; text-align: center; color: ${totalNewFollowers >= 0 ? '#0f0' : '#ff0'};">+${this.formatNumber(totalNewFollowers)}</td>
              <td style="padding: 8px; text-align: center;">${totalPosts}</td>
            `;
            tbody.appendChild(row);
          }
        });
        table.appendChild(tbody);
        
        tableDiv.appendChild(table);
        container.appendChild(tableDiv);
      },
      
      // Create weekly platform comparison chart
      createWeeklyPlatformComparisonChart(container, accountStats) {
        // Aggregate by platform
        const platformTotals = {
          instagram: { views: 0, likes: 0, newFollowers: 0, posts: 0 },
          tiktok: { views: 0, likes: 0, newFollowers: 0, posts: 0 },
          youtube: { views: 0, likes: 0, newFollowers: 0, posts: 0 }
        };
        
        accountStats.forEach(account => {
          ['instagram', 'tiktok', 'youtube'].forEach(platform => {
            if (account[platform]) {
              platformTotals[platform].views += account[platform].views || 0;
              platformTotals[platform].likes += account[platform].likes || 0;
              platformTotals[platform].newFollowers += account[platform].newFollowers || 0;
              platformTotals[platform].posts += account[platform].posts || 0;
            }
          });
        });
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'weekly-platform-comparison';
        
        const header = document.createElement('h3');
        header.textContent = 'Views by Platform This Week';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['weekly-platform-comparison'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              label: 'Views',
              data: [
                platformTotals.instagram.views,
                platformTotals.tiktok.views,
                platformTotals.youtube.views
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => 'Views: ' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Create weekly views by account chart
      createWeeklyViewsByAccountChart(container, accountStats) {
        // Get accounts with views, sorted by total views
        const accountsWithViews = accountStats
          .map(account => {
            const total = (account.instagram?.views || 0) + 
                          (account.tiktok?.views || 0) + 
                          (account.youtube?.views || 0);
            return { name: account.name, total, ...account };
          })
          .filter(a => a.total > 0)
          .sort((a, b) => b.total - a.total);
        
        if (accountsWithViews.length === 0) return;
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'weekly-views-by-account';
        
        const header = document.createElement('h3');
        header.textContent = 'Views by Account This Week';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['weekly-views-by-account'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: accountsWithViews.map(a => '@' + a.name),
            datasets: [
              {
                label: 'Instagram',
                data: accountsWithViews.map(a => a.instagram?.views || 0),
                backgroundColor: '#E1306C'
              },
              {
                label: 'TikTok',
                data: accountsWithViews.map(a => a.tiktok?.views || 0),
                backgroundColor: '#00f2ea'
              },
              {
                label: 'YouTube',
                data: accountsWithViews.map(a => a.youtube?.views || 0),
                backgroundColor: '#FF0000'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: true,
                labels: { color: '#0f0', font: { family: 'monospace' } }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => context.dataset.label + ': ' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                stacked: true,
                ticks: { color: '#0f0', font: { family: 'monospace', size: 10 } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                stacked: true,
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Create weekly new followers by account chart
      createWeeklyFollowersByAccountChart(container, accountStats) {
        // Get accounts with follower growth
        const accountsWithGrowth = accountStats
          .map(account => {
            const total = (account.instagram?.newFollowers || 0) + 
                          (account.tiktok?.newFollowers || 0) + 
                          (account.youtube?.newFollowers || 0);
            return { name: account.name, total, ...account };
          })
          .filter(a => a.total !== 0)
          .sort((a, b) => b.total - a.total);
        
        if (accountsWithGrowth.length === 0) return;
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'weekly-followers-by-account';
        
        const header = document.createElement('h3');
        header.textContent = 'New Followers by Account This Week';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['weekly-followers-by-account'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: accountsWithGrowth.map(a => '@' + a.name),
            datasets: [
              {
                label: 'Instagram',
                data: accountsWithGrowth.map(a => a.instagram?.newFollowers || 0),
                backgroundColor: '#E1306C'
              },
              {
                label: 'TikTok',
                data: accountsWithGrowth.map(a => a.tiktok?.newFollowers || 0),
                backgroundColor: '#00f2ea'
              },
              {
                label: 'YouTube',
                data: accountsWithGrowth.map(a => a.youtube?.newFollowers || 0),
                backgroundColor: '#FF0000'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: true,
                labels: { color: '#0f0', font: { family: 'monospace' } }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => context.dataset.label + ': +' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                stacked: true,
                ticks: { color: '#0f0', font: { family: 'monospace', size: 10 } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                stacked: true,
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => '+' + this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Render easy graphs for client report
      async renderEasyGraphs(startDate, endDate, monthName, year) {
        const container = document.getElementById('easyChartsList');
        container.innerHTML = '';
        
        // Reset chart instances
        this.chartInstances = {};
        
        document.getElementById('easyGraphsTitle').textContent = 
          `${monthName} ${year} Analytics for MoonMedia`;
        
        // Calculate stats for each platform for this month
        const platformStats = {};
        const platforms = ['instagram', 'tiktok', 'youtube'];
        
        let totalViews = 0;
        let totalNewFollowers = 0;
        
        platforms.forEach(platform => {
          const data = this.easyGraphsData[platform];
          if (data && data.videos) {
            // Filter videos for this month
            const monthVideos = data.videos.filter(v => 
              v.date >= startDate && v.date <= endDate
            );
            
            const views = monthVideos.reduce((sum, v) => sum + (v.views || 0), 0);
            const likes = monthVideos.reduce((sum, v) => sum + (v.likes || 0), 0);
            const posts = monthVideos.length;
            
            // Calculate new followers with extrapolation for sparse data
            let newFollowers = 0;
            if (data.followersHistory && data.followersHistory.length > 0) {
              const monthHistory = data.followersHistory.filter(h => 
                h.date >= startDate && h.date <= endDate
              );
              
              if (monthHistory.length >= 2) {
                // Direct calculation when we have enough data points
                const sorted = monthHistory.sort((a, b) => a.date - b.date);
                newFollowers = sorted[sorted.length - 1].value - sorted[0].value;
              } else {
                // Extrapolate from all available history if month data is sparse
                const allHistory = data.followersHistory.sort((a, b) => a.date - b.date);
                
                if (allHistory.length >= 2) {
                  // Calculate daily growth rate from all history
                  const firstPoint = allHistory[0];
                  const lastPoint = allHistory[allHistory.length - 1];
                  const totalDays = (lastPoint.date - firstPoint.date) / (1000 * 60 * 60 * 24);
                  const totalGrowth = lastPoint.value - firstPoint.value;
                  
                  if (totalDays > 0 && totalGrowth > 0) {
                    const dailyGrowthRate = totalGrowth / totalDays;
                    
                    // Calculate days in this month's range
                    const monthDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
                    
                    // Extrapolate growth for this month
                    newFollowers = Math.round(dailyGrowthRate * monthDays);
                    
                    // Note: This is an extrapolated value
                    if (newFollowers > 0) {
                      console.log(`[${platform}] Extrapolated follower growth: ~${newFollowers} (from ${dailyGrowthRate.toFixed(2)}/day avg)`);
                    }
                  }
                } else if (monthHistory.length === 1) {
                  // If we only have one data point this month, check if there's data before
                  const beforeMonth = data.followersHistory.filter(h => h.date < startDate);
                  if (beforeMonth.length > 0) {
                    const lastBefore = beforeMonth.sort((a, b) => a.date - b.date).pop();
                    newFollowers = monthHistory[0].value - lastBefore.value;
                    if (newFollowers < 0) newFollowers = 0; // Don't show negative
                  }
                }
              }
            }
            
            platformStats[platform] = { views, likes, posts, newFollowers };
            totalViews += views;
            totalNewFollowers += newFollowers;
          }
        });
        
        // Render stats summary
        const statsContainer = document.getElementById('easyStatsSummary');
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>TOTAL VIEWS</h4>
            <div class="value">${this.formatNumber(totalViews)}</div>
          </div>
          <div class="stat-card">
            <h4>NEW FOLLOWERS</h4>
            <div class="value">+${this.formatNumber(totalNewFollowers)}</div>
          </div>
          <div class="stat-card">
            <h4>INSTAGRAM VIEWS</h4>
            <div class="value">${this.formatNumber(platformStats.instagram?.views || 0)}</div>
          </div>
          <div class="stat-card">
            <h4>TIKTOK VIEWS</h4>
            <div class="value">${this.formatNumber(platformStats.tiktok?.views || 0)}</div>
          </div>
          <div class="stat-card">
            <h4>YOUTUBE VIEWS</h4>
            <div class="value">${this.formatNumber(platformStats.youtube?.views || 0)}</div>
          </div>
        `;
        
        // Create platform views comparison chart
        this.createEasyPlatformViewsChart(container, platformStats);
        
        // Create views over time chart for the month
        this.createEasyViewsOverTimeChart(container, startDate, endDate);
        
        // Create followers growth chart
        this.createEasyFollowersChart(container, startDate, endDate);
      },
      
      // Create platform views comparison chart for easy graphs
      createEasyPlatformViewsChart(container, platformStats) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'easy-platform-views';
        
        const header = document.createElement('h3');
        header.textContent = 'Views by Platform';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['easy-platform-views'] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Instagram', 'TikTok', 'YouTube'],
            datasets: [{
              label: 'Views',
              data: [
                platformStats.instagram?.views || 0,
                platformStats.tiktok?.views || 0,
                platformStats.youtube?.views || 0
              ],
              backgroundColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderColor: ['#E1306C', '#00f2ea', '#FF0000'],
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => 'Views: ' + this.formatNumber(context.parsed.y)
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Create views over time chart for easy graphs (with cumulative line and logarithmic scale)
      createEasyViewsOverTimeChart(container, startDate, endDate) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'easy-views-time';
        
        const header = document.createElement('h3');
        header.textContent = 'Views Over Time (Cumulative + Per-Post)';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        // Combine all videos from all platforms
        const allVideos = [];
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const data = this.easyGraphsData[platform];
          if (data && data.videos) {
            const monthVideos = data.videos.filter(v => 
              v.date >= startDate && v.date <= endDate
            );
            allVideos.push(...monthVideos.map(v => ({ ...v, platform })));
          }
        });
        
        allVideos.sort((a, b) => a.date - b.date);
        
        // Calculate cumulative views
        let cumulativeViews = 0;
        const cumulativeData = allVideos.map(v => {
          cumulativeViews += (v.views || 0);
          return { x: v.date, y: cumulativeViews };
        });
        
        // Determine if logarithmic scale is appropriate (large range)
        const viewsArray = allVideos.map(v => v.views || 0).filter(v => v > 0);
        const maxViews = Math.max(...viewsArray, 1);
        const minViews = Math.min(...viewsArray.filter(v => v > 0), maxViews);
        const useLogScale = maxViews / minViews > 100 && maxViews > 10000;
        
        const ctx = canvas.getContext('2d');
        
        this.chartInstances['easy-views-time'] = new Chart(ctx, {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'Cumulative Views',
                data: cumulativeData,
                borderColor: '#0f0',
                backgroundColor: 'rgba(0, 255, 0, 0.1)',
                borderWidth: 2,
                fill: true,
                tension: 0.3,
                yAxisID: 'y-cumulative'
              },
              {
                label: 'Views per Post',
                data: allVideos.map(v => ({ x: v.date, y: v.views || 0 })),
                borderColor: '#00d2d3',
                backgroundColor: 'rgba(0, 210, 211, 0.7)',
                pointRadius: 4,
                pointHoverRadius: 6,
                type: 'scatter',
                yAxisID: 'y-individual'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: {
                display: true,
                labels: { color: '#0f0', font: { family: 'monospace' } }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                callbacks: {
                  label: (context) => {
                    const label = context.dataset.label || '';
                    return label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'day',
                  displayFormats: { day: 'MMM d' }
                },
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              'y-cumulative': {
                type: useLogScale ? 'logarithmic' : 'linear',
                position: 'left',
                title: {
                  display: true,
                  text: 'Cumulative Views' + (useLogScale ? ' (log)' : ''),
                  color: '#0f0',
                  font: { family: 'monospace' }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              'y-individual': {
                type: useLogScale ? 'logarithmic' : 'linear',
                position: 'right',
                title: {
                  display: true,
                  text: 'Per-Post Views' + (useLogScale ? ' (log)' : ''),
                  color: '#00d2d3',
                  font: { family: 'monospace' }
                },
                ticks: {
                  color: '#00d2d3',
                  font: { family: 'monospace' },
                  callback: (value) => this.formatNumber(value)
                },
                grid: { drawOnChartArea: false }
              }
            }
          }
        });
      },
      
      // Create followers chart for easy graphs
      createEasyFollowersChart(container, startDate, endDate) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'easy-followers';
        
        const header = document.createElement('h3');
        header.textContent = 'Followers/Subscribers Growth';
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        // Get followers data from each platform
        const datasets = [];
        const platformColors = {
          instagram: { border: '#E1306C', bg: 'rgba(225, 48, 108, 0.3)' },
          tiktok: { border: '#00f2ea', bg: 'rgba(0, 242, 234, 0.3)' },
          youtube: { border: '#FF0000', bg: 'rgba(255, 0, 0, 0.3)' }
        };
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const data = this.easyGraphsData[platform];
          if (data && data.followersHistory) {
            const monthHistory = data.followersHistory
              .filter(h => h.date >= startDate && h.date <= endDate)
              .sort((a, b) => a.date - b.date);
            
            if (monthHistory.length > 0) {
              datasets.push({
                label: platform.charAt(0).toUpperCase() + platform.slice(1),
                data: monthHistory.map(h => ({ x: h.date, y: h.value })),
                borderColor: platformColors[platform].border,
                backgroundColor: platformColors[platform].bg,
                borderWidth: 2,
                tension: 0.3,
                fill: false
              });
            }
          }
        });
        
        if (datasets.length > 0) {
          const ctx = canvas.getContext('2d');
          
          this.chartInstances['easy-followers'] = new Chart(ctx, {
            type: 'line',
            data: { datasets },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: '#0f0',
                    font: { family: 'monospace' }
                  }
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#0f0',
                  bodyColor: '#0f0',
                  callbacks: {
                    label: (context) => context.dataset.label + ': ' + this.formatNumber(context.parsed.y)
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'day',
                    displayFormats: { day: 'MMM d' }
                  },
                  ticks: { color: '#0f0', font: { family: 'monospace' } },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                },
                y: {
                  ticks: {
                    color: '#0f0',
                    font: { family: 'monospace' },
                    callback: (value) => this.formatNumber(value)
                  },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                }
              }
            }
          });
        }
      },
      
      // Export client report as PDF
      async exportClientReport() {
        const monthName = this.currentEasyGraphsMonth;
        const year = this.currentEasyGraphsYear;
        const filename = `${monthName}_${year}_analytics_for_MoonMedia.pdf`;
        
        // Create a temporary container for the export
        const exportContainer = document.createElement('div');
        exportContainer.style.position = 'absolute';
        exportContainer.style.left = '-9999px';
        exportContainer.style.background = '#000';
        exportContainer.style.padding = '20px';
        exportContainer.style.width = '800px';
        document.body.appendChild(exportContainer);
        
        // Clone the charts section
        const chartsClone = document.getElementById('easyGraphsContainer').cloneNode(true);
        
        // Remove the export button from clone
        const exportBtns = chartsClone.querySelectorAll('.looks-good-btn, .export-section');
        exportBtns.forEach(btn => btn.remove());
        
        exportContainer.appendChild(chartsClone);
        
        try {
          // Use html2canvas if available, otherwise use a simpler approach
          if (typeof html2canvas !== 'undefined') {
            const canvas = await html2canvas(exportContainer, {
              backgroundColor: '#000000',
              scale: 2
            });
            
            const imgData = canvas.toDataURL('image/png');
            
            // Create download link
            const link = document.createElement('a');
            link.download = filename.replace('.pdf', '.png');
            link.href = imgData;
            link.click();
          } else {
            // Fallback: export charts as images
            alert(`Export feature: In a full implementation, this would generate "${filename}"\n\nTo enable PDF export, add html2canvas and jsPDF libraries.`);
            
            // Export each chart individually
            Object.keys(this.chartInstances).forEach(chartId => {
              if (chartId.startsWith('easy-')) {
                const chart = this.chartInstances[chartId];
                if (chart) {
                  const imageUrl = chart.toBase64Image();
                  const link = document.createElement('a');
                  link.download = `${monthName}_${year}_${chartId}.png`;
                  link.href = imageUrl;
                  link.click();
                }
              }
            });
          }
        } catch (error) {
          console.error('Export error:', error);
          alert('Export failed. Charts have been downloaded individually.');
        } finally {
          document.body.removeChild(exportContainer);
        }
      },
      
      // Platform selection
      async selectPlatform(platform) {
        this.selectedPlatform = platform;
        this.isAllPlatforms = (platform === 'all');
        
        document.getElementById('step0Custom').classList.add('hidden');
        
        if (this.isAllPlatforms) {
          // Show loading while fetching data to determine date range
          document.getElementById('loading').classList.remove('hidden');
          document.getElementById('loading').textContent = 'loading data for date range...';
          
          // Load all platforms data with 'all' time range to get date range
          await this.loadAllPlatformsDataForDateRange();
          
          document.getElementById('loading').classList.add('hidden');
          document.getElementById('loading').textContent = 'loading data...';
          document.getElementById('step2').classList.remove('hidden');
        } else {
          document.getElementById('step1').classList.remove('hidden');
          this.loadSheetData();
        }
      },
      
      // Load all platforms data just to determine date range
      async loadAllPlatformsDataForDateRange() {
        let allVideos = [];
        let allTotalLikesHistory = [];
        let allFollowersHistory = [];
        
        // Load Instagram data
        try {
          const igResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.instagram}/export?format=xlsx`);
          const igBuffer = await igResponse.arrayBuffer();
          const igWorkbook = XLSX.read(igBuffer, { type: 'array' });
          const igData = this.processWorkbookData(igWorkbook, 'instagram', 'all');
          if (igData && igData.videos) {
            allVideos = allVideos.concat(igData.videos);
          }
        } catch (error) {
          console.error('Error loading Instagram data for date range:', error);
        }
        
        // Load TikTok data
        try {
          const ttResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.tiktok}/export?format=xlsx`);
          const ttBuffer = await ttResponse.arrayBuffer();
          const ttWorkbook = XLSX.read(ttBuffer, { type: 'array' });
          const ttData = this.processWorkbookData(ttWorkbook, 'tiktok', 'all');
          if (ttData && ttData.videos) {
            allVideos = allVideos.concat(ttData.videos);
          }
        } catch (error) {
          console.error('Error loading TikTok data for date range:', error);
        }
        
        // Load YouTube data
        try {
          const ytResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.youtube}/export?format=xlsx`);
          const ytBuffer = await ytResponse.arrayBuffer();
          const ytWorkbook = XLSX.read(ytBuffer, { type: 'array' });
          const ytData = this.processWorkbookData(ytWorkbook, 'youtube', 'all');
          if (ytData && ytData.videos) {
            allVideos = allVideos.concat(ytData.videos);
          }
        } catch (error) {
          console.error('Error loading YouTube data for date range:', error);
        }
        
        // Update slider with the extracted date range
        this.updateSliderWithDataRange(allVideos, allTotalLikesHistory, allFollowersHistory);
      },
      
      // Account selection
      selectAccount(account) {
        this.selectedAccount = account;
        this.isMoonMediaTotal = (account === 'MOONMEDIA_TOTAL');
        document.getElementById('step1').classList.add('hidden');
        document.getElementById('step2').classList.remove('hidden');
        
        // Parse data with 'all' time range to extract the full date range
        const fullData = this.isMoonMediaTotal 
          ? this.parseMoonMediaTotal('all')
          : this.parseAccountData(this.selectedAccount, 'all');
        
        // Update slider with actual data date range
        if (fullData) {
          this.updateSliderWithDataRange(
            fullData.videos || [], 
            fullData.totalLikesHistory || [], 
            fullData.followersHistory || []
          );
        } else {
          this.initializeSliderWithData();
        }
      },
      
      // Time range selection
      async selectTimeRange(days) {
        this.selectedTimeRange = days;
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        
        if (this.isAllPlatforms) {
          await this.loadAllPlatformsData(days);
        } else {
          setTimeout(() => {
            this.processData(days);
            this.finalizeDataDisplay(days);
          }, 1000);
        }
      },
      
      // Finalize data display
      finalizeDataDisplay(days) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('charts').classList.remove('hidden');
        
        // Update UI labels
        let accountText = '';
        if (this.isAllPlatforms) {
          accountText = 'All MoonMedia Platforms';
        } else if (this.isMoonMediaTotal) {
          accountText = 'All MoonMedia';
        } else {
          accountText = '@' + this.selectedAccount;
        }
        
        document.getElementById('accountName').textContent = accountText;
        
        let rangeText = '';
        if (days === 'all') rangeText = '(All Time)';
        else if (days === 365) rangeText = '(Last 1 Year)';
        else if (days === 180) rangeText = '(Last 6 Months)';
        else if (days === 30) rangeText = '(Last 1 Month)';
        else if (days === 'custom' && this.customStartDate && this.customEndDate) {
          rangeText = `(${this.formatDate(this.customStartDate)} - ${this.formatDate(this.customEndDate)})`;
        }
        document.getElementById('timeRangeLabel').textContent = rangeText;
        
        if (this.isAllPlatforms) {
          this.renderAllPlatformsDashboard();
        } else {
          this.renderDashboard();
        }
      },
      
      // Load all platforms data
      async loadAllPlatformsData(timeRangeDays) {
        this.allPlatformsData = {
          instagram: null,
          tiktok: null,
          youtube: null,
          combined: {
            totalFollowers: 0,
            totalLikes: 0,
            totalViews: 0,
            totalPosts: 0,
            viewsPerSecond: 0
          }
        };
        
        // Also store unfiltered videos for cumulative calculations with historical context
        this.allVideosUnfiltered = [];
        
        // Load Instagram data
        try {
          const igResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.instagram}/export?format=xlsx`);
          const igBuffer = await igResponse.arrayBuffer();
          const igWorkbook = XLSX.read(igBuffer, { type: 'array' });
          this.allPlatformsData.instagram = this.processWorkbookData(igWorkbook, 'instagram', timeRangeDays);
          // Store unfiltered videos
          const igUnfiltered = this.processWorkbookData(igWorkbook, 'instagram', 'all');
          if (igUnfiltered && igUnfiltered.videos) {
            this.allVideosUnfiltered = this.allVideosUnfiltered.concat(igUnfiltered.videos);
          }
        } catch (error) {
          console.error('Error loading Instagram data:', error);
        }
        
        // Load TikTok data
        try {
          const ttResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.tiktok}/export?format=xlsx`);
          const ttBuffer = await ttResponse.arrayBuffer();
          const ttWorkbook = XLSX.read(ttBuffer, { type: 'array' });
          this.allPlatformsData.tiktok = this.processWorkbookData(ttWorkbook, 'tiktok', timeRangeDays);
          // Store unfiltered videos
          const ttUnfiltered = this.processWorkbookData(ttWorkbook, 'tiktok', 'all');
          if (ttUnfiltered && ttUnfiltered.videos) {
            this.allVideosUnfiltered = this.allVideosUnfiltered.concat(ttUnfiltered.videos);
          }
        } catch (error) {
          console.error('Error loading TikTok data:', error);
        }
        
        // Load YouTube data
        try {
          const ytResponse = await fetch(`https://docs.google.com/spreadsheets/d/${this.SHEET_IDS.youtube}/export?format=xlsx`);
          const ytBuffer = await ytResponse.arrayBuffer();
          const ytWorkbook = XLSX.read(ytBuffer, { type: 'array' });
          this.allPlatformsData.youtube = this.processWorkbookData(ytWorkbook, 'youtube', timeRangeDays);
          // Store unfiltered videos
          const ytUnfiltered = this.processWorkbookData(ytWorkbook, 'youtube', 'all');
          if (ytUnfiltered && ytUnfiltered.videos) {
            this.allVideosUnfiltered = this.allVideosUnfiltered.concat(ytUnfiltered.videos);
          }
        } catch (error) {
          console.error('Error loading YouTube data:', error);
        }
        
        // Calculate combined metrics
        this.calculateCombinedMetrics();
        
        this.finalizeDataDisplay(timeRangeDays);
      },
      
      // Process workbook data for all platforms view
      processWorkbookData(workbook, platform, timeRangeDays) {
        const accounts = workbook.SheetNames;
        let totalFollowers = 0;
        let totalLikes = 0;
        let totalPosts = 0;
        let allVideos = [];
        
        // Aggregate followers history across all accounts
        // Using timestamp-based aggregation similar to parseMoonMediaTotal
        let followersByTimestamp = {};
        let highestKnownFollowersByAccount = {};
        
        accounts.forEach(sheetName => {
          const data = this.parseAccountDataFromWorkbook(workbook, sheetName, platform, timeRangeDays);
          if (data) {
            totalFollowers += data.followers || 0;
            totalLikes += data.totalLikes || 0;
            totalPosts += data.postsScraped || 0;
            if (data.videos) {
              allVideos = allVideos.concat(data.videos);
            }
            
            // Aggregate followers history for this account
            if (data.followersHistory && data.followersHistory.length > 0) {
              data.followersHistory.forEach(item => {
                if (!this.isValidDate(item.date)) return;
                
                const dateKey = item.date.toISOString();
                if (!followersByTimestamp[dateKey]) {
                  followersByTimestamp[dateKey] = { 
                    date: item.date, 
                    accountValues: {} 
                  };
                }
                followersByTimestamp[dateKey].accountValues[sheetName] = item.value;
              });
            }
          }
        });
        
        // Build aggregated followers history using highest known values
        // (followers should never decrease - lower values are scrape errors)
        const sortedFollowersTimestamps = Object.values(followersByTimestamp)
          .filter(item => this.isValidDate(item.date))
          .sort((a, b) => a.date - b.date);
        
        const followersHistory = [];
        accounts.forEach(acc => { highestKnownFollowersByAccount[acc] = 0; });
        
        // Build history using highest value seen UP TO each timestamp
        sortedFollowersTimestamps.forEach(item => {
          // Update current values for accounts that have data at this timestamp
          // Only update if the new value is higher (followers shouldn't decrease)
          Object.keys(item.accountValues).forEach(acc => {
            const newValue = item.accountValues[acc];
            if (newValue > highestKnownFollowersByAccount[acc]) {
              highestKnownFollowersByAccount[acc] = newValue;
            }
          });
          
          // Sum all current highest known values
          const cumulativeTotal = Object.values(highestKnownFollowersByAccount).reduce((sum, val) => sum + val, 0);
          
          // Only add if we have a meaningful total
          if (cumulativeTotal > 0) {
            // Check if this is different from the last entry to avoid duplicates
            const lastEntry = followersHistory[followersHistory.length - 1];
            if (!lastEntry || lastEntry.value !== cumulativeTotal) {
              followersHistory.push({
                date: item.date,
                value: cumulativeTotal
              });
            }
          }
        });
        
        const totalViews = allVideos.reduce((sum, v) => sum + (v.views || 0), 0);
        
        return {
          platform: platform,
          followers: totalFollowers,
          totalLikes: totalLikes,
          totalViews: totalViews,
          postsScraped: totalPosts,
          videos: allVideos,
          accountCount: accounts.length,
          followersHistory: followersHistory
        };
      },
      
      // Calculate combined metrics for all platforms
      calculateCombinedMetrics() {
        const platforms = ['instagram', 'tiktok', 'youtube'];
        let totalViews = 0;
        let allVideos = [];
        
        platforms.forEach(platform => {
          if (this.allPlatformsData[platform]) {
            const data = this.allPlatformsData[platform];
            this.allPlatformsData.combined.totalFollowers += data.followers || 0;
            this.allPlatformsData.combined.totalLikes += data.totalLikes || 0;
            this.allPlatformsData.combined.totalViews += data.totalViews || 0;
            this.allPlatformsData.combined.totalPosts += data.postsScraped || 0;
            
            if (data.videos) {
              allVideos = allVideos.concat(data.videos);
            }
          }
        });
        
        // Calculate views per second
        allVideos.sort((a, b) => (a.date || 0) - (b.date || 0));
        
        if (allVideos.length >= 2) {
          const validVideos = allVideos.filter(v => v.date && v.views);
          if (validVideos.length >= 2) {
            const oldestVideo = validVideos[0];
            const newestVideo = validVideos[validVideos.length - 1];
            const timeSpanSeconds = (newestVideo.date - oldestVideo.date) / 1000;
            
            if (timeSpanSeconds > 0) {
              const totalViewsInPeriod = validVideos.reduce((sum, v) => sum + v.views, 0);
              this.allPlatformsData.combined.viewsPerSecond = totalViewsInPeriod / timeSpanSeconds;
            }
          }
        }
      },
      
      // Parse account data from workbook
      parseAccountDataFromWorkbook(workbook, sheetName, platform, timeRangeDays) {
        if (platform === 'instagram') {
          return this.parseInstagramDataFromWorkbook(workbook, sheetName, timeRangeDays);
        } else if (platform === 'tiktok') {
          return this.parseTikTokDataFromWorkbook(workbook, sheetName, timeRangeDays);
        } else if (platform === 'youtube') {
          return this.parseYouTubeDataFromWorkbook(workbook, sheetName, timeRangeDays);
        }
        return null;
      },
      
      // Load sheet data
      async loadSheetData() {
        const accountSelect = document.getElementById('accountSelect');
        
        try {
          accountSelect.innerHTML = '<option value="" disabled>loading accounts...</option>';
          
          const sheetId = this.SHEET_IDS[this.selectedPlatform];
          const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=xlsx`;
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          
          this.workbookData = XLSX.read(arrayBuffer, { type: 'array' });
          
          const accounts = this.workbookData.SheetNames;
          
          if (accounts.length === 0) {
            accountSelect.innerHTML = '<option>no accounts found</option>';
            return;
          }
          
          accountSelect.innerHTML = 
            '<option value="" disabled selected>-- select an account --</option>' +
            '<option value="MOONMEDIA_TOTAL" class="moonmedia-option">All MoonMedia Analytics</option>' +
            accounts.map(acc => `<option value="${acc}">@${acc}</option>`).join('');
          
          console.log('Loaded accounts:', accounts);
          
        } catch (error) {
          console.error('Error loading data:', error);
          accountSelect.innerHTML = '<option>error loading - check file permissions</option>';
        }
      },
      
      // Process data based on platform and account
      processData(timeRangeDays) {
        if (this.isMoonMediaTotal) {
          this.accountData = this.parseMoonMediaTotal(timeRangeDays);
          // Also store unfiltered videos for cumulative calculations with historical context
          const unfilteredData = this.parseMoonMediaTotal('all');
          this.allVideosUnfiltered = unfilteredData.videos || [];
        } else {
          this.accountData = this.parseAccountData(this.selectedAccount, timeRangeDays);
          // Also store unfiltered videos for cumulative calculations with historical context
          const unfilteredData = this.parseAccountData(this.selectedAccount, 'all');
          this.allVideosUnfiltered = unfilteredData.videos || [];
        }
      },
      
      // Parse account data
      parseAccountData(sheetName, timeRangeDays = 'all') {
        if (this.selectedPlatform === 'instagram') {
          return this.parseInstagramData(sheetName, timeRangeDays);
        } else if (this.selectedPlatform === 'tiktok') {
          return this.parseTikTokData(sheetName, timeRangeDays);
        } else if (this.selectedPlatform === 'youtube') {
          return this.parseYouTubeData(sheetName, timeRangeDays);
        }
      },
      
      // Parse YouTube data from sheet
      parseYouTubeData(sheetName, timeRangeDays) {
        return this.parseYouTubeDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse YouTube data from workbook
      parseYouTubeDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        // Parse YouTube data similar to TikTok structure
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'subscribers' || rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName === 'total_likes') {
            totalLikesHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName.startsWith('post_') || rowName.startsWith('video_') || rowName.startsWith('short_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            if (metric === 'Date' || metric === 'date') {
              allUniqueVideoIds.add(videoId);
            }
            
            // For views and likes, use the HIGHEST value across all scrapes
            // (since they should never decrease - if they do, it's a scrape error)
            const metricLower = metric.toLowerCase();
            if (metricLower === 'views' || metricLower === 'likes') {
              let highestValue = 0;
              for (let colIdx = 1; colIdx < row.length; colIdx++) {
                const cellValue = parseInt(row[colIdx]) || 0;
                if (cellValue > highestValue) {
                  highestValue = cellValue;
                }
              }
              if (highestValue > 0) {
                if (!allVideosMap.has(videoId)) {
                  allVideosMap.set(videoId, { id: videoId });
                }
                allVideosMap.get(videoId)[metric] = highestValue;
              }
            } else {
              // For other metrics, use most recent non-empty value
              for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                const cellValue = row[colIdx];
                
                if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  
                  const video = allVideosMap.get(videoId);
                  if (video[metric] === undefined) {
                    video[metric] = cellValue;
                  }
                  break;
                }
              }
            }
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        // Get latest non-zero values after interpolation
        const followers = followersHistory.length > 0 ? 
          followersHistory[followersHistory.length - 1].value : 0;
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date || v.date).map(v => {
          const dateObj = new Date(v.Date || v.date);
          
          if (!this.isValidDate(dateObj)) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views || v.views) || 0,
            likes: parseInt(v.Likes || v.likes) || 0,
            comments: parseInt(v.Comments || v.comments) || 0,
            shares: parseInt(v.Shares || v.shares) || 0,
            engagement: parseFloat(v.EngagementRate || v.engagement) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: followers,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => item.value > 0),
          platform: 'youtube'
        };
      },
      // Parse TikTok data
      parseTikTokData(sheetName, timeRangeDays) {
        return this.parseTikTokDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse TikTok data from workbook
      parseTikTokDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName === 'total_likes') {
            totalLikesHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName.startsWith('post_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            if (metric === 'Date') {
              allUniqueVideoIds.add(videoId);
            }
            
            // For Views and Likes, use the HIGHEST value across all scrapes
            // (since they should never decrease - if they do, it's a scrape error)
            if (metric === 'Views' || metric === 'Likes') {
              let highestValue = 0;
              for (let colIdx = 1; colIdx < row.length; colIdx++) {
                const cellValue = parseInt(row[colIdx]) || 0;
                if (cellValue > highestValue) {
                  highestValue = cellValue;
                }
              }
              if (highestValue > 0) {
                if (!allVideosMap.has(videoId)) {
                  allVideosMap.set(videoId, { id: videoId });
                }
                allVideosMap.get(videoId)[metric] = highestValue;
              }
            } else {
              // For other metrics, use most recent non-empty value
              for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                const cellValue = row[colIdx];
                
                if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  
                  const video = allVideosMap.get(videoId);
                  if (video[metric] === undefined) {
                    video[metric] = cellValue;
                  }
                  break;
                }
              }
            }
          }
        }
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        // Get latest non-zero values after interpolation
        const followers = followersHistory.length > 0 ? 
          followersHistory[followersHistory.length - 1].value : 0;
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          // Use robust date parsing
          const dateObj = this.parseDate(v.Date);
          
          if (!dateObj) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: parseInt(v.Shares) || 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: followers,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => item.value > 0)
        };
      },
      
      // Parse Instagram data
      parseInstagramData(sheetName, timeRangeDays) {
        return this.parseInstagramDataFromWorkbook(this.workbookData, sheetName, timeRangeDays);
      },
      
      // Parse Instagram data from workbook
      parseInstagramDataFromWorkbook(workbook, sheetName, timeRangeDays) {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return null;
        
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        
        const headers = jsonData[0].slice(1);
        let followersHistory = [];
        let totalLikesHistory = [];
        
        const allVideosMap = new Map();
        const allUniqueVideoIds = new Set();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (!rowName) continue;
          
          if (rowName === 'followers') {
            followersHistory = row.slice(1).map((val, idx) => ({
              date: this.parseDate(headers[idx]),
              value: parseInt(val) || 0
            })).filter(item => item.date !== null);
              
          } else if (rowName.startsWith('reel_')) {
            const parts = rowName.split('_');
            const metric = parts[parts.length - 1];
            const videoId = parts.slice(1, -1).join('_');
            
            const metricMapping = {
              'date': 'Date',
              'views': 'Views',
              'likes': 'Likes',
              'comments': 'Comments',
              'engagement': 'EngagementRate'
            };
            
            const mappedMetric = metricMapping[metric];
            
            if (metric === 'date') {
              allUniqueVideoIds.add(videoId);
            }
            
            if (metric === 'date_display') continue;
            
            if (mappedMetric) {
              // For views and likes, use the HIGHEST value across all scrapes (since they should never go down)
              // For other metrics, use the most recent non-empty value
              if (metric === 'views' || metric === 'likes') {
                let highestValue = 0;
                for (let colIdx = 1; colIdx < row.length; colIdx++) {
                  const cellValue = parseInt(row[colIdx]) || 0;
                  if (cellValue > highestValue) {
                    highestValue = cellValue;
                  }
                }
                if (highestValue > 0) {
                  if (!allVideosMap.has(videoId)) {
                    allVideosMap.set(videoId, { id: videoId });
                  }
                  allVideosMap.get(videoId)[mappedMetric] = highestValue;
                }
              } else {
                // For date, comments, engagement - use most recent non-empty value
                for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
                  const cellValue = row[colIdx];
                  
                  if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                    if (!allVideosMap.has(videoId)) {
                      allVideosMap.set(videoId, { id: videoId });
                    }
                    
                    const video = allVideosMap.get(videoId);
                    if (video[mappedMetric] === undefined) {
                      video[mappedMetric] = cellValue;
                    }
                    break;
                  }
                }
              }
            }
          }
        }
        
        // Calculate total likes history using only the most recent scrape data per post
        // First, build a map of video IDs to their likes rows
        const likesRowsMap = new Map();
        const viewsRowsMap = new Map();
        const postDatesMap = new Map();
        
        for (let i = 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const rowName = row[0];
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_likes')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            likesRowsMap.set(videoId, row);
          }
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_views')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            viewsRowsMap.set(videoId, row);
          }
          
          if (rowName && rowName.startsWith('reel_') && rowName.endsWith('_date')) {
            const parts = rowName.split('_');
            const videoId = parts.slice(1, -1).join('_');
            // Find the post date (most recent non-empty value)
            for (let colIdx = row.length - 1; colIdx >= 1; colIdx--) {
              const cellValue = row[colIdx];
              if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                postDatesMap.set(videoId, new Date(cellValue));
                break;
              }
            }
          }
        }
        
        // Determine which scrape columns have actual post data (not just followers)
        // Early scrapes may only have follower data, which causes misaligned graphs
        const columnsWithPostData = new Set();
        for (let colIdx = 0; colIdx < headers.length; colIdx++) {
          // Check if any post has data in this column
          for (const [videoId, likesRow] of likesRowsMap) {
            if (colIdx + 1 < likesRow.length) {
              const value = parseInt(likesRow[colIdx + 1]) || 0;
              if (value > 0) {
                columnsWithPostData.add(colIdx);
                break;
              }
            }
          }
        }
        
        // For each scrape timestamp (column), calculate total likes using the HIGHEST value per post
        // (since likes should never decrease - if they do, it's a scrape error)
        for (let colIdx = 0; colIdx < headers.length; colIdx++) {
          const scrapeDate = new Date(headers[colIdx]);
          if (!this.isValidDate(scrapeDate)) continue;
          
          let columnTotalLikes = 0;
          
          // For each post, get the HIGHEST likes value up to this column
          for (const [videoId, likesRow] of likesRowsMap) {
            const postDate = postDatesMap.get(videoId);
            
            // Only include posts that existed by this scrape date
            if (postDate && postDate <= scrapeDate) {
              // Find the HIGHEST likes value for this post up to this column
              let highestLikes = 0;
              for (let prevColIdx = 0; prevColIdx <= colIdx; prevColIdx++) {
                // Check array bounds before accessing
                if (prevColIdx + 1 < likesRow.length) {
                  const value = parseInt(likesRow[prevColIdx + 1]) || 0;
                  if (value > highestLikes) {
                    highestLikes = value;
                  }
                }
              }
              columnTotalLikes += highestLikes;
            }
          }
          
          if (columnTotalLikes > 0) {
            totalLikesHistory.push({
              date: scrapeDate,
              value: columnTotalLikes
            });
          }
        }
        
        // NOTE: We no longer filter follower history based on post data availability
        // Early scrapes may only have follower counts without video data, but those
        // follower counts are still valid and should be included in the graph.
        // The key insight is that follower counts should never decrease, so we can
        // safely include all valid data points and rely on interpolation to handle gaps.
        
        // Process and clean data
        followersHistory = this.interpolateHistoricalData(followersHistory);
        totalLikesHistory = this.interpolateHistoricalData(totalLikesHistory);
        
        // Get latest non-zero values after interpolation
        const followers = followersHistory.length > 0 ? 
          followersHistory[followersHistory.length - 1].value : 0;
        const totalLikes = totalLikesHistory.length > 0 ? 
          totalLikesHistory[totalLikesHistory.length - 1].value : 0;
        
        const videosData = Array.from(allVideosMap.values());
        let cleanVideos = videosData.filter(v => v.Date).map(v => {
          // Use robust date parsing to handle various formats
          const dateObj = this.parseDate(v.Date);
          
          if (!dateObj) {
            return null;
          }
          
          return {
            date: dateObj,
            views: parseInt(v.Views) || 0,
            likes: parseInt(v.Likes) || 0,
            comments: parseInt(v.Comments) || 0,
            shares: 0,
            engagement: parseFloat(v.EngagementRate) || 0
          };
        }).filter(v => v !== null).sort((a, b) => a.date - b.date);
        
        cleanVideos = this.filterDataByTimeRange(cleanVideos, timeRangeDays);
        
        return {
          followers: followers,
          totalLikes: totalLikes,
          postsScraped: allUniqueVideoIds.size,
          videos: cleanVideos,
          followersHistory: followersHistory.filter(item => item.value > 0),
          totalLikesHistory: totalLikesHistory.filter(item => this.isValidDate(item.date) && item.value > 0)
        };
      },
      
      // Parse all MoonMedia accounts combined
      parseMoonMediaTotal(timeRangeDays) {
        const accounts = this.workbookData.SheetNames;
        let totalFollowers = 0;
        let totalLikes = 0;
        let totalPosts = 0;
        let allVideos = [];
        
        let followersByTimestamp = {};
        let likesByTimestamp = {};
        
        // Track highest known values for each account (followers should never decrease)
        let highestKnownFollowersByAccount = {};
        let lastKnownLikesByAccount = {};
        
        accounts.forEach(sheetName => {
          const data = this.parseAccountData(sheetName, timeRangeDays);
          totalFollowers += data.followers;
          totalLikes += data.totalLikes;
          totalPosts += data.postsScraped;
          allVideos = allVideos.concat(data.videos);
          
          // For followers, store per-account values to enable cumulative calculation
          data.followersHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!followersByTimestamp[dateKey]) {
              followersByTimestamp[dateKey] = { 
                date: item.date, 
                accountValues: {} 
              };
            }
            followersByTimestamp[dateKey].accountValues[sheetName] = item.value;
          });
          
          // For likes, store per-account values to enable cumulative calculation
          data.totalLikesHistory.forEach(item => {
            if (!this.isValidDate(item.date)) return;
            
            const dateKey = item.date.toISOString();
            if (!likesByTimestamp[dateKey]) {
              likesByTimestamp[dateKey] = { 
                date: item.date, 
                accountValues: {} 
              };
            }
            likesByTimestamp[dateKey].accountValues[sheetName] = item.value;
          });
        });
        
        const totalAccountCount = accounts.length;
        
        // Followers: include ALL timestamps, using highest known value for each account
        // Sort timestamps chronologically first
        const sortedFollowersTimestamps = Object.values(followersByTimestamp)
          .filter(item => this.isValidDate(item.date))
          .sort((a, b) => a.date - b.date);
        
        // Build cumulative total followers history using HIGHEST values
        // (since followers should never decrease - lower values are scrape errors)
        const followersHistory = [];
        accounts.forEach(acc => { highestKnownFollowersByAccount[acc] = 0; });
        
        // First pass: determine the highest value each account ever reaches
        sortedFollowersTimestamps.forEach(item => {
          Object.keys(item.accountValues).forEach(acc => {
            const newValue = item.accountValues[acc];
            if (newValue > highestKnownFollowersByAccount[acc]) {
              highestKnownFollowersByAccount[acc] = newValue;
            }
          });
        });
        
        // Reset for second pass
        const currentFollowersByAccount = {};
        accounts.forEach(acc => { currentFollowersByAccount[acc] = 0; });
        
        // Second pass: build history using highest value seen UP TO each timestamp
        sortedFollowersTimestamps.forEach(item => {
          // Update current values for accounts that have data at this timestamp
          // Only update if the new value is higher (followers shouldn't decrease)
          Object.keys(item.accountValues).forEach(acc => {
            const newValue = item.accountValues[acc];
            if (newValue > currentFollowersByAccount[acc]) {
              currentFollowersByAccount[acc] = newValue;
            }
          });
          
          // Sum all current values
          const cumulativeTotal = Object.values(currentFollowersByAccount).reduce((sum, val) => sum + val, 0);
          
          // Only add if we have a meaningful total and at least some accounts have data
          const accountsWithData = Object.values(currentFollowersByAccount).filter(v => v > 0).length;
          
          if (cumulativeTotal > 0 && accountsWithData > 0) {
            // Check if this is significantly different from the last entry to avoid duplicates
            const lastEntry = followersHistory[followersHistory.length - 1];
            if (!lastEntry || lastEntry.value !== cumulativeTotal) {
              followersHistory.push({
                date: item.date,
                value: cumulativeTotal
              });
            }
          }
        });
        
        // Total Likes: include ALL timestamps, using last known value for missing accounts
        // Sort timestamps chronologically first
        const sortedLikesTimestamps = Object.values(likesByTimestamp)
          .filter(item => this.isValidDate(item.date))
          .sort((a, b) => a.date - b.date);
        
        // Build cumulative total likes history
        const totalLikesHistory = [];
        accounts.forEach(acc => { lastKnownLikesByAccount[acc] = 0; });
        
        sortedLikesTimestamps.forEach(item => {
          // Update last known values for accounts that have data at this timestamp
          Object.keys(item.accountValues).forEach(acc => {
            lastKnownLikesByAccount[acc] = item.accountValues[acc];
          });
          
          // Sum all last known values (ensures cumulative behavior)
          const cumulativeTotal = Object.values(lastKnownLikesByAccount).reduce((sum, val) => sum + val, 0);
          
          if (cumulativeTotal > 0) {
            totalLikesHistory.push({
              date: item.date,
              value: cumulativeTotal
            });
          }
        });
        
        allVideos.sort((a, b) => a.date - b.date);
        
        let totalViews = allVideos.reduce((sum, v) => sum + v.views, 0);
        let viewsPerSecond = 0;
        
        const last100Posts = allVideos.slice(-100);
        if (last100Posts.length >= 2) {
          const oldestPost = last100Posts[0];
          const newestPost = last100Posts[last100Posts.length - 1];
          const totalViewsInPeriod = last100Posts.reduce((sum, v) => sum + v.views, 0);
          const timeSpanSeconds = (newestPost.date - oldestPost.date) / 1000;
          
          if (timeSpanSeconds > 0) {
            viewsPerSecond = totalViewsInPeriod / timeSpanSeconds;
          }
        }
        
        return {
          followers: totalFollowers,
          totalLikes: totalLikes,
          postsScraped: totalPosts,
          videos: allVideos,
          followersHistory: followersHistory,
          totalLikesHistory: totalLikesHistory,
          totalViews: totalViews,
          viewsPerSecond: viewsPerSecond,
          accountCount: accounts.length
        };
      },
      
      // Utility functions
      isValidDate(date) {
        if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
          return false;
        }
        const year = date.getFullYear();
        const currentYear = new Date().getFullYear();
        return year >= 2020 && year <= currentYear + 1;
      },
      
      // Robust date parsing that handles various date formats from Excel/scrapers
      parseDate(dateValue) {
        if (!dateValue) return null;
        
        // If it's already a valid Date object
        if (dateValue instanceof Date && !isNaN(dateValue.getTime())) {
          return this.isValidDate(dateValue) ? dateValue : null;
        }
        
        // Handle Excel serial date numbers (days since 1900-01-01)
        if (typeof dateValue === 'number') {
          // Excel serial date conversion
          const excelEpoch = new Date(1899, 11, 30); // Excel epoch
          const millisecondsPerDay = 24 * 60 * 60 * 1000;
          const date = new Date(excelEpoch.getTime() + (dateValue * millisecondsPerDay));
          return this.isValidDate(date) ? date : null;
        }
        
        // Handle string formats
        if (typeof dateValue === 'string') {
          dateValue = dateValue.trim();
          
          // Try ISO format first (most common from scrapers: 2024-01-15T12:00:00)
          let date = new Date(dateValue);
          if (this.isValidDate(date)) return date;
          
          // Try YYYY-MM-DD format
          const isoMatch = dateValue.match(/^(\d{4})-(\d{2})-(\d{2})/);
          if (isoMatch) {
            date = new Date(parseInt(isoMatch[1]), parseInt(isoMatch[2]) - 1, parseInt(isoMatch[3]));
            if (this.isValidDate(date)) return date;
          }
          
          // Try MM/DD/YYYY format
          const usMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
          if (usMatch) {
            date = new Date(parseInt(usMatch[3]), parseInt(usMatch[1]) - 1, parseInt(usMatch[2]));
            if (this.isValidDate(date)) return date;
          }
          
          // Try DD/MM/YYYY format (European)
          const euMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
          if (euMatch) {
            // Try European format (day first)
            date = new Date(parseInt(euMatch[3]), parseInt(euMatch[2]) - 1, parseInt(euMatch[1]));
            if (this.isValidDate(date)) return date;
          }
          
          // Try "Month DD, YYYY" format (e.g., "January 15, 2024")
          const monthNameMatch = dateValue.match(/^([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})/);
          if (monthNameMatch) {
            const monthNames = ['january', 'february', 'march', 'april', 'may', 'june', 
                               'july', 'august', 'september', 'october', 'november', 'december'];
            const monthIdx = monthNames.indexOf(monthNameMatch[1].toLowerCase());
            if (monthIdx !== -1) {
              date = new Date(parseInt(monthNameMatch[3]), monthIdx, parseInt(monthNameMatch[2]));
              if (this.isValidDate(date)) return date;
            }
          }
          
          // Try "DD Mon YYYY" format (e.g., "15 Jan 2024")
          const shortMonthMatch = dateValue.match(/^(\d{1,2})\s+([A-Za-z]{3,})\s+(\d{4})/);
          if (shortMonthMatch) {
            const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 
                               'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            const monthIdx = monthNames.findIndex(m => shortMonthMatch[2].toLowerCase().startsWith(m));
            if (monthIdx !== -1) {
              date = new Date(parseInt(shortMonthMatch[3]), monthIdx, parseInt(shortMonthMatch[1]));
              if (this.isValidDate(date)) return date;
            }
          }
        }
        
        return null;
      },
      
      filterDataByTimeRange(videos, timeRangeDays) {
        if (timeRangeDays === 'all') return videos;
        
        // Handle custom date range
        if (timeRangeDays === 'custom') {
          if (this.customStartDate && this.customEndDate) {
            return videos.filter(v => v.date >= this.customStartDate && v.date <= this.customEndDate);
          }
          return videos;
        }
        
        // Create cutoff date using milliseconds (more robust than setDate for month/year boundaries)
        const daysInMs = timeRangeDays * 24 * 60 * 60 * 1000;
        const cutoffDate = new Date(Date.now() - daysInMs);
        
        return videos.filter(v => v.date >= cutoffDate);
      },
      
      interpolateHistoricalData(historyArray) {
        if (historyArray.length === 0) return historyArray;
        
        // First pass: mark items that need interpolation (0, null, undefined, or abnormal drops)
        const interpolated = historyArray.map((item, idx, arr) => {
          let needsInterp = item.value === 0 || item.value === null || item.value === undefined;
          
          // Also check for abnormal drops (50%+ drop from previous valid value)
          if (!needsInterp && idx > 0) {
            // Find the previous valid value
            let prevValidValue = null;
            for (let j = idx - 1; j >= 0; j--) {
              const prevVal = arr[j].value;
              if (prevVal > 0 && prevVal !== null && prevVal !== undefined) {
                prevValidValue = prevVal;
                break;
              }
            }
            
            // If there's a 50%+ drop, consider it invalid
            if (prevValidValue !== null && item.value < prevValidValue * 0.5) {
              needsInterp = true;
            }
          }
          
          return {
            ...item,
            index: idx,
            needsInterp: needsInterp
          };
        });
        
        let i = 0;
        while (i < interpolated.length) {
          if (!interpolated[i].needsInterp) {
            i++;
            continue;
          }
          
          let groupStart = i;
          let groupEnd = i;
          while (groupEnd < interpolated.length && interpolated[groupEnd].needsInterp) {
            groupEnd++;
          }
          groupEnd--;
          
          let prevValue = null;
          for (let j = groupStart - 1; j >= 0; j--) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              prevValue = interpolated[j].value;
              break;
            }
          }
          
          let nextValue = null;
          for (let j = groupEnd + 1; j < interpolated.length; j++) {
            if (!interpolated[j].needsInterp && interpolated[j].value > 0) {
              nextValue = interpolated[j].value;
              break;
            }
          }
          
          if (prevValue !== null && nextValue !== null) {
            const groupSize = groupEnd - groupStart + 1;
            const totalSteps = groupSize + 1;
            
            for (let j = groupStart; j <= groupEnd; j++) {
              const stepNumber = j - groupStart + 1;
              const interpolatedValue = prevValue + ((nextValue - prevValue) * stepNumber / totalSteps);
              interpolated[j].value = Math.round(interpolatedValue);
            }
          } else if (prevValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = prevValue;
            }
          } else if (nextValue !== null) {
            for (let j = groupStart; j <= groupEnd; j++) {
              interpolated[j].value = nextValue;
            }
          }
          
          i = groupEnd + 1;
        }
        
        return interpolated.map(item => ({
          date: item.date,
          value: item.value
        }));
      },
      
      shouldUseLogScale(data) {
        if (data.length === 0) return false;
        
        const values = data.filter(v => v > 0);
        if (values.length === 0) return false;
        
        const max = Math.max(...values);
        const min = Math.min(...values);
        const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
        
        const ratio = max / min;
        const medianRatio = max / median;
        
        return ratio > 100 || medianRatio > 10;
      },
      
      formatNumber(num) {
        if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
        if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        return num.toLocaleString();
      },
      
      formatNumberAxisSmart(value, dataRange) {
        const range = dataRange.max - dataRange.min;
        
        if (value >= 1000000000) {
          const val = value / 1000000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'B';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'B';
          return val.toFixed(1) + 'B';
        }
        if (value >= 1000000) {
          const val = value / 1000000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(3) + 'M';
          if (rangeRatio < 0.1) return val.toFixed(2) + 'M';
          return val.toFixed(1) + 'M';
        }
        if (value >= 1000) {
          const val = value / 1000;
          const rangeRatio = range / value;
          if (rangeRatio < 0.01) return val.toFixed(2) + 'K';
          return val.toFixed(1) + 'K';
        }
        return value.toLocaleString();
      },
      
      calculateMovingAverageByDays(data, days = 7) {
        const result = [];
        const halfWindow = Math.floor(days / 2);
        
        for (let i = 0; i < data.length; i++) {
          const currentDate = new Date(data[i].x);
          const startDate = new Date(currentDate);
          const endDate = new Date(currentDate);
          
          startDate.setDate(startDate.getDate() - halfWindow);
          endDate.setDate(endDate.getDate() + (days - halfWindow));
          
          const windowPoints = [];
          for (let j = 0; j < data.length; j++) {
            const pointDate = new Date(data[j].x);
            if (pointDate >= startDate && pointDate <= endDate) {
              windowPoints.push(data[j].y);
            }
          }
          
          if (windowPoints.length > 0) {
            const sum = windowPoints.reduce((acc, val) => acc + val, 0);
            const avg = sum / windowPoints.length;
            result.push({ x: data[i].x, y: avg });
          } else {
            result.push({ x: data[i].x, y: data[i].y });
          }
        }
        
        return result;
      },
      
      // Calculate cumulative data from video data
      calculateCumulativeData(data, historicalSum = 0) {
        if (!data || data.length === 0) return [];
        
        // Sort by date first
        const sortedData = [...data].sort((a, b) => new Date(a.x) - new Date(b.x));
        
        // Start cumulative from historical sum (all data before the selected time range)
        let cumulative = historicalSum;
        return sortedData.map(point => {
          cumulative += point.y;
          return { x: point.x, y: cumulative };
        });
      },
      
      // Calculate the sum of a metric for all videos before a given date
      calculateHistoricalSum(allVideos, metricKey, startDate) {
        if (!allVideos || allVideos.length === 0 || !startDate) return 0;
        
        return allVideos
          .filter(v => v.date && new Date(v.date) < new Date(startDate))
          .reduce((sum, v) => sum + (v[metricKey] || 0), 0);
      },
      
      // Get the start date for the current time range filter
      getTimeRangeStartDate() {
        if (this.selectedTimeRange === 'all') return null;
        
        if (this.selectedTimeRange === 'custom') {
          return this.customStartDate;
        }
        
        // For preset time ranges (30, 180, 365 days)
        const daysInMs = this.selectedTimeRange * 24 * 60 * 60 * 1000;
        return new Date(Date.now() - daysInMs);
      },
      
      // Calculate smoothed curve for cumulative data using exponential smoothing
      calculateSmoothedCurve(data, smoothnessLevel = this.SMOOTHNESS.DEFAULT_LEVEL) {
        if (!data || data.length === 0) return [];
        
        // Smoothness level: MIN_LEVEL = most responsive, MAX_LEVEL = smoothest
        // Alpha ranges from MAX_ALPHA (responsive) to MIN_ALPHA (smooth)
        const levelRange = this.SMOOTHNESS.MAX_LEVEL - this.SMOOTHNESS.MIN_LEVEL;
        const alpha = this.SMOOTHNESS.MAX_ALPHA - ((smoothnessLevel - this.SMOOTHNESS.MIN_LEVEL) / levelRange) * this.SMOOTHNESS.ALPHA_RANGE;
        
        const result = [];
        let smoothedValue = data[0].y;
        
        for (let i = 0; i < data.length; i++) {
          if (i === 0) {
            result.push({ x: data[i].x, y: data[i].y });
          } else {
            smoothedValue = alpha * data[i].y + (1 - alpha) * smoothedValue;
            result.push({ x: data[i].x, y: smoothedValue });
          }
        }
        
        return result;
      },
      
      // Toggle between Average and Cumulative modes
      toggleChartMode(chartId, metricKey) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        // Toggle mode state
        const currentMode = this.chartModeStates[chartId] || 'average';
        const newMode = currentMode === 'average' ? 'cumulative' : 'average';
        this.chartModeStates[chartId] = newMode;
        
        // Get the filtered video data (currently displayed)
        const videos = this.isAllPlatforms ? 
          [...(this.allPlatformsData.instagram?.videos || []), 
           ...(this.allPlatformsData.tiktok?.videos || []),
           ...(this.allPlatformsData.youtube?.videos || [])] :
          this.accountData.videos;
        
        if (!videos || videos.length === 0) return;
        
        // Recalculate data based on mode
        let newData;
        if (newMode === 'cumulative') {
          const rawData = videos.map(v => ({ x: v.date, y: v[metricKey] }));
          
          // Calculate historical sum (all data before the selected time range)
          const startDate = this.getTimeRangeStartDate();
          let historicalSum = 0;
          
          if (startDate) {
            // Get all unfiltered videos
            const allVideos = this.isAllPlatforms ?
              [...(this.allPlatformsData.instagram?.videos || []),
               ...(this.allPlatformsData.tiktok?.videos || []),
               ...(this.allPlatformsData.youtube?.videos || [])] :
              (this.allVideosUnfiltered || []);
            
            historicalSum = this.calculateHistoricalSum(allVideos, metricKey, startDate);
          }
          
          newData = this.calculateCumulativeData(rawData, historicalSum);
        } else {
          newData = videos.map(v => ({ x: v.date, y: v[metricKey] }));
        }
        
        // Update main dataset
        const mainDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
        if (mainDataset) {
          mainDataset.data = newData;
        }
        
        // Update trendline if visible
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset && this.trendlineStates[chartId]) {
          if (newMode === 'cumulative') {
            // Use smoothed curve for cumulative mode
            const smoothnessLevel = this.trendlineSmoothnessLevel[chartId] || this.SMOOTHNESS.DEFAULT_LEVEL;
            trendlineDataset.data = this.calculateSmoothedCurve(newData, smoothnessLevel);
          } else {
            // Use moving average for average mode
            const days = this.trendlineDaysAverage[chartId] || 7;
            trendlineDataset.data = this.calculateMovingAverageByDays(newData, days);
          }
        }
        
        chart.update();
        
        // Update mode badge
        const badge = document.querySelector(`[data-mode-id="${chartId}"]`);
        if (badge) {
          if (newMode === 'cumulative') {
            badge.classList.add('cumulative');
            badge.textContent = 'CUMULATIVE';
          } else {
            badge.classList.remove('cumulative');
            badge.textContent = 'AVERAGE';
          }
        }
        
        // Update smoothness controls visibility - show for cumulative, hide for average
        const smoothnessControls = document.querySelector(`[data-smoothness-controls="${chartId}"]`);
        const daysDisplay = document.querySelector(`[data-days-display="${chartId}"]`);
        if (smoothnessControls && this.trendlineStates[chartId]) {
          if (newMode === 'cumulative') {
            // Switch to smoothness level display
            if (daysDisplay) {
              daysDisplay.textContent = this.trendlineSmoothnessLevel[chartId] || 5;
            }
          } else {
            // Switch to days display
            if (daysDisplay) {
              daysDisplay.textContent = this.trendlineDaysAverage[chartId] || 7;
            }
          }
        }
      },
      
      // Chart manipulation functions
      toggleLogScale(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const currentType = chart.options.scales.y.type;
        const newType = currentType === 'logarithmic' ? 'linear' : 'logarithmic';
        
        chart.options.scales.y.type = newType;
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.type = newType;
        }
        
        if (chartId === 'correlation' && chart.options.scales.x) {
          chart.options.scales.x.type = newType;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-chart-id="${chartId}"]`);
        if (badge) {
          if (newType === 'logarithmic') {
            badge.classList.remove('inactive');
            badge.textContent = 'LOG SCALE';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'LINEAR';
          }
        }
      },
      
      toggleTrendline(chartId) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        this.trendlineStates[chartId] = !this.trendlineStates[chartId];
        const showTrendline = this.trendlineStates[chartId];
        
        const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
        if (trendlineDataset) {
          trendlineDataset.hidden = !showTrendline;
          
          // When enabling the trendline, recalculate it based on the current mode
          if (showTrendline) {
            const currentMode = this.chartModeStates[chartId] || 'average';
            const mainDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
            
            if (mainDataset && mainDataset.data) {
              if (currentMode === 'cumulative') {
                // Use smoothed curve for cumulative mode
                const smoothnessLevel = this.trendlineSmoothnessLevel[chartId] || this.SMOOTHNESS.DEFAULT_LEVEL;
                trendlineDataset.data = this.calculateSmoothedCurve(mainDataset.data, smoothnessLevel);
              } else {
                // Use moving average for average mode
                const days = this.trendlineDaysAverage[chartId] || 7;
                trendlineDataset.data = this.calculateMovingAverageByDays(mainDataset.data, days);
              }
            }
          }
        }
        
        if (chart.options.scales.y1) {
          chart.options.scales.y1.display = showTrendline;
        }
        
        chart.update();
        
        const badge = document.querySelector(`[data-trendline-id="${chartId}"]`);
        if (badge) {
          if (showTrendline) {
            badge.classList.remove('inactive');
            badge.textContent = 'TREND ON';
          } else {
            badge.classList.add('inactive');
            badge.textContent = 'TREND OFF';
          }
        }
        
        const controls = document.querySelector(`[data-smoothness-controls="${chartId}"]`);
        if (controls) {
          controls.style.display = showTrendline ? 'inline-block' : 'none';
        }
        
        // Update the smoothness/days display based on current mode
        const daysDisplay = document.querySelector(`[data-days-display="${chartId}"]`);
        if (daysDisplay && showTrendline) {
          const currentMode = this.chartModeStates[chartId] || 'average';
          if (currentMode === 'cumulative') {
            daysDisplay.textContent = this.trendlineSmoothnessLevel[chartId] || this.SMOOTHNESS.DEFAULT_LEVEL;
          } else {
            daysDisplay.textContent = this.trendlineDaysAverage[chartId] || 7;
          }
        }
      },
      
      adjustTrendlineSmoothness(chartId, direction) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const currentMode = this.chartModeStates[chartId] || 'average';
        
        if (currentMode === 'cumulative') {
          // Adjust smoothness level for cumulative mode
          if (this.trendlineSmoothnessLevel[chartId] === undefined) {
            this.trendlineSmoothnessLevel[chartId] = this.SMOOTHNESS.DEFAULT_LEVEL;
          }
          
          this.trendlineSmoothnessLevel[chartId] += direction;
          this.trendlineSmoothnessLevel[chartId] = Math.max(
            this.SMOOTHNESS.MIN_LEVEL, 
            Math.min(this.SMOOTHNESS.MAX_LEVEL, this.trendlineSmoothnessLevel[chartId])
          );
          
          const dataDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
          if (!dataDataset) return;
          
          const trendlineData = this.calculateSmoothedCurve(
            dataDataset.data, 
            this.trendlineSmoothnessLevel[chartId]
          );
          
          const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
          if (trendlineDataset) {
            trendlineDataset.data = trendlineData;
          }
          
          chart.update();
          
          const display = document.querySelector(`[data-days-display="${chartId}"]`);
          if (display) {
            display.textContent = this.trendlineSmoothnessLevel[chartId];
          }
        } else {
          // Adjust days for average mode
          if (this.trendlineDaysAverage[chartId] === undefined) {
            this.trendlineDaysAverage[chartId] = 7;
          }
          
          this.trendlineDaysAverage[chartId] += direction;
          this.trendlineDaysAverage[chartId] = Math.max(1, this.trendlineDaysAverage[chartId]);
          
          const dataDataset = chart.data.datasets.find(ds => ds.label !== 'Trend');
          if (!dataDataset) return;
          
          const trendlineData = this.calculateMovingAverageByDays(
            dataDataset.data, 
            this.trendlineDaysAverage[chartId]
          );
          
          const trendlineDataset = chart.data.datasets.find(ds => ds.label === 'Trend');
          if (trendlineDataset) {
            trendlineDataset.data = trendlineData;
          }
          
          chart.update();
          
          const display = document.querySelector(`[data-days-display="${chartId}"]`);
          if (display) {
            display.textContent = this.trendlineDaysAverage[chartId];
          }
        }
      },
      
      exportChart(chartId, title) {
        const chart = this.chartInstances[chartId];
        if (!chart) return;
        
        const canvas = chart.canvas;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + 80;
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCtx.fillStyle = '#000000';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        tempCtx.fillStyle = '#ffffff';
        tempCtx.font = 'bold 24px monospace';
        tempCtx.textAlign = 'center';
        tempCtx.fillText(title, tempCanvas.width / 2, 35);
        
        tempCtx.font = '16px monospace';
        let accountText = '';
        if (this.isAllPlatforms) {
          accountText = 'All MoonMedia Platforms';
        } else if (this.isMoonMediaTotal) {
          accountText = 'All MoonMedia';
        } else {
          accountText = '@' + this.selectedAccount;
        }
        
        let rangeText = '';
        if (this.selectedTimeRange === 'all') rangeText = '(All Time)';
        else if (this.selectedTimeRange === 365) rangeText = '(Last 1 Year)';
        else if (this.selectedTimeRange === 180) rangeText = '(Last 6 Months)';
        else if (this.selectedTimeRange === 30) rangeText = '(Last 1 Month)';
        
        tempCtx.fillText(`${accountText} ${rangeText}`, tempCanvas.width / 2, 60);
        
        tempCtx.drawImage(canvas, 0, 80);
        
        const link = document.createElement('a');
        const platformSuffix = this.isAllPlatforms ? 'all_platforms' : this.selectedPlatform;
        link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${accountText.replace('@', '')}_${platformSuffix}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      },
      // Chart creation functions continued
      createLineChart(container, title, historyData, datasets, useLog, chartId) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allValues = datasets.flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'day',
                  displayFormats: { day: 'MMM d, yyyy' }
                },
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLog ? 'logarithmic' : 'linear',
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRange);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      createTimeBasedChart(container, title, videos, datasets, useLog, chartId, includeTrendline = false, metricKey = null) {
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        
        const header = document.createElement('h3');
        header.textContent = title;
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLog ? '' : ' inactive');
        scaleBadge.textContent = useLog ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', chartId);
        scaleBadge.onclick = () => this.toggleLogScale(chartId);
        
        header.appendChild(scaleBadge);
        
        // Add mode toggle for time-series charts with metric data
        if (metricKey && includeTrendline) {
          const modeBadge = document.createElement('span');
          modeBadge.className = 'mode-toggle-badge';
          modeBadge.textContent = 'AVERAGE';
          modeBadge.setAttribute('data-mode-id', chartId);
          modeBadge.onclick = () => this.toggleChartMode(chartId, metricKey);
          header.appendChild(modeBadge);
          
          // Initialize mode state and store metricKey for later use
          this.chartModeStates[chartId] = 'average';
          this.chartMetricKeys[chartId] = metricKey;
          this.trendlineSmoothnessLevel[chartId] = this.SMOOTHNESS.DEFAULT_LEVEL;
        }
        
        if (includeTrendline) {
          const trendlineBadge = document.createElement('span');
          trendlineBadge.className = 'trendline-badge inactive';
          trendlineBadge.textContent = 'TREND OFF';
          trendlineBadge.setAttribute('data-trendline-id', chartId);
          trendlineBadge.onclick = () => this.toggleTrendline(chartId);
          header.appendChild(trendlineBadge);
          
          this.trendlineStates[chartId] = false;
          this.trendlineDaysAverage[chartId] = 7;
          
          const smoothnessControls = document.createElement('span');
          smoothnessControls.className = 'smoothness-controls';
          smoothnessControls.setAttribute('data-smoothness-controls', chartId);
          smoothnessControls.style.display = 'none';
          
          const downBtn = document.createElement('button');
          downBtn.className = 'smoothness-btn';
          downBtn.textContent = 'â—„';
          downBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, -1);
          
          const daysDisplay = document.createElement('span');
          daysDisplay.className = 'smoothness-btn';
          daysDisplay.textContent = '7';
          daysDisplay.style.cursor = 'default';
          daysDisplay.setAttribute('data-days-display', chartId);
          
          const upBtn = document.createElement('button');
          upBtn.className = 'smoothness-btn';
          upBtn.textContent = 'â–º';
          upBtn.onclick = () => this.adjustTrendlineSmoothness(chartId, 1);
          
          smoothnessControls.appendChild(downBtn);
          smoothnessControls.appendChild(daysDisplay);
          smoothnessControls.appendChild(upBtn);
          
          header.appendChild(smoothnessControls);
        }
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart(chartId, title);
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        // Ensure scatter plot is behind trendline
        datasets[0].order = 1;
        
        if (includeTrendline && datasets.length > 0) {
          const trendlineData = this.calculateMovingAverageByDays(datasets[0].data, 7);
          
          datasets.push({
            label: 'Trend',
            data: trendlineData,
            type: 'line',
            borderColor: '#ffff00',
            backgroundColor: 'transparent',
            borderWidth: 3,
            pointRadius: 0,
            tension: 0.4,
            yAxisID: 'y1',
            hidden: true,
            order: -1  // Trendline on top
          });
        }
        
        const allValues = datasets.filter(ds => ds.label !== 'Trend')
          .flatMap(ds => ds.data.map(d => d.y)).filter(v => v > 0);
        const dataRange = {
          min: Math.min(...allValues),
          max: Math.max(...allValues)
        };
        
        const scales = {
          x: {
            type: 'time',
            time: {
              unit: 'day',
              displayFormats: { day: 'MMM d, yyyy' }
            },
            ticks: { color: '#0f0', font: { family: 'monospace' } },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          },
          y: {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'left',
            ticks: {
              color: '#0f0',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: { color: 'rgba(0, 255, 0, 0.1)' }
          }
        };
        
        if (includeTrendline) {
          scales.y1 = {
            type: useLog ? 'logarithmic' : 'linear',
            position: 'right',
            display: false,
            ticks: {
              color: '#ffff00',
              font: { family: 'monospace' },
              callback: (value) => {
                return this.formatNumberAxisSmart(value, dataRange);
              }
            },
            grid: {
              drawOnChartArea: false
            }
          };
        }
        
        this.chartInstances[chartId] = new Chart(ctx, {
          type: datasets[0].type || 'scatter',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 },
                  filter: (item) => {
                    if (item.text === 'Trend') {
                      return this.trendlineStates[chartId] === true;
                    }
                    return true;
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: scales
          }
        });
      },
      
      createCorrelationChart(container) {
        const correlationValues = this.accountData.videos.map(v => v.views);
        const useLogCorrelation = this.shouldUseLogScale(correlationValues);
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'correlation';
        
        const header = document.createElement('h3');
        header.textContent = 'Likes vs Views Correlation';
        
        const scaleBadge = document.createElement('span');
        scaleBadge.className = 'scale-badge' + (useLogCorrelation ? '' : ' inactive');
        scaleBadge.textContent = useLogCorrelation ? 'LOG SCALE' : 'LINEAR';
        scaleBadge.setAttribute('data-chart-id', 'correlation');
        scaleBadge.onclick = () => this.toggleLogScale('correlation');
        
        header.appendChild(scaleBadge);
        
        const exportBtn = document.createElement('button');
        exportBtn.className = 'export-btn';
        exportBtn.textContent = 'Export';
        exportBtn.onclick = () => this.exportChart('correlation', 'Likes vs Views Correlation');
        
        chartDiv.appendChild(header);
        chartDiv.appendChild(exportBtn);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        const ctx = canvas.getContext('2d');
        
        const allViews = this.accountData.videos.map(v => v.views).filter(v => v > 0);
        const allLikes = this.accountData.videos.map(v => v.likes).filter(v => v > 0);
        const dataRangeX = {
          min: Math.min(...allViews),
          max: Math.max(...allViews)
        };
        const dataRangeY = {
          min: Math.min(...allLikes),
          max: Math.max(...allLikes)
        };
        
        this.chartInstances['correlation'] = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [{
              label: 'Posts',
              data: this.accountData.videos.map(v => ({ x: v.views, y: v.likes })),
              backgroundColor: 'rgba(0, 210, 211, 0.6)',
              borderColor: '#00d2d3',
              pointRadius: 6,
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2.5,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return 'Views: ' + this.formatNumber(context.parsed.x) + 
                           ', Likes: ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Views',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeX);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: useLogCorrelation ? 'logarithmic' : 'linear',
                title: {
                  display: true,
                  text: 'Likes',
                  color: '#0f0',
                  font: { family: 'monospace', size: 14 }
                },
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumberAxisSmart(value, dataRangeY);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
      },
      
      // Main dashboard rendering
      renderDashboard() {
        // Reset chart instances
        this.chartInstances = {};
        this.trendlineStates = {};
        this.trendlineDaysAverage = {};
        this.chartModeStates = {};
        this.chartMetricKeys = {};
        this.trendlineSmoothnessLevel = {};
        
        const statsContainer = document.getElementById('statsSummary');
        const chartsContainer = document.getElementById('chartsList');
        chartsContainer.innerHTML = '';
        
        // Determine content type based on platform
        let contentType = 'POSTS';
        if (this.selectedPlatform === 'instagram') contentType = 'REELS';
        else if (this.selectedPlatform === 'youtube') contentType = 'SHORTS';
        
        // Render summary statistics
        let statsHTML = `
          <div class="stat-card">
            <h4>FOLLOWERS</h4>
            <div class="value">${this.formatNumber(this.accountData.followers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(this.accountData.totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>${contentType} TRACKED</h4>
            <div class="value">${this.accountData.postsScraped}</div>
          </div>
          <div class="stat-card">
            <h4>AVG ENGAGEMENT</h4>
            <div class="value">${this.accountData.videos.length > 0 ? 
              (this.accountData.videos.reduce((sum, v) => sum + v.engagement, 0) / 
               this.accountData.videos.length).toFixed(2) : 0}%</div>
          </div>
        `;
        
        if (this.isMoonMediaTotal) {
          statsHTML += `
            <div class="stat-card">
              <h4>TOTAL VIEWS</h4>
              <div class="value">${this.formatNumber(this.accountData.totalViews)}</div>
            </div>
            <div class="stat-card">
              <h4>VIEWS PER SECOND</h4>
              <div class="value">${this.accountData.viewsPerSecond.toFixed(2)}</div>
            </div>
            <div class="stat-card">
              <h4>TOTAL ACCOUNTS</h4>
              <div class="value">${this.accountData.accountCount}</div>
            </div>
          `;
        }
        
        statsContainer.innerHTML = statsHTML;
        
        // Create charts
        // Followers Over Time (first chart)
        if (this.accountData.followersHistory && this.accountData.followersHistory.length > 0) {
          const followerValues = this.accountData.followersHistory.map(h => h.value);
          const useLogFollowers = this.shouldUseLogScale(followerValues);
          
          this.createLineChart(chartsContainer, 'Followers Over Time', 
            this.accountData.followersHistory,
            [{
              label: 'Followers',
              data: this.accountData.followersHistory.map(h => ({ x: h.date, y: h.value })),
              borderColor: '#9b59b6',
              backgroundColor: 'rgba(155, 89, 182, 0.1)',
              borderWidth: 3,
              tension: 0.4,
              fill: true
            }],
            useLogFollowers,
            'followers-history'
          );
        }
        
        // NOTE: "Total Likes Growth" chart has been removed per requirements
        
        if (this.accountData.videos.length > 0) {
          const viewsData = this.accountData.videos.map(v => v.views);
          const likesData = this.accountData.videos.map(v => v.likes);
          const useLogViews = this.shouldUseLogScale(viewsData);
          const useLogLikes = this.shouldUseLogScale(likesData);
          
          // Likes Over Time - with mode toggle
          this.createTimeBasedChart(chartsContainer, 'Likes Over Time',
            this.accountData.videos,
            [{
              label: 'Likes',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.likes })),
              borderColor: '#ff6b6b',
              backgroundColor: 'rgba(255, 107, 107, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogLikes,
            'likes-time',
            true,
            'likes'
          );
          
          // Views Over Time - with mode toggle
          this.createTimeBasedChart(chartsContainer, 'Views Over Time',
            this.accountData.videos,
            [{
              label: 'Views',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.views })),
              borderColor: '#00d2d3',
              backgroundColor: 'rgba(0, 210, 211, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogViews,
            'views-time',
            true,
            'views'
          );
          
          // Comments Over Time - with mode toggle
          const commentsData = this.accountData.videos.map(v => v.comments);
          const useLogComments = this.shouldUseLogScale(commentsData);
          
          this.createTimeBasedChart(chartsContainer, 'Comments Over Time',
            this.accountData.videos,
            [{
              label: 'Comments',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.comments })),
              borderColor: '#1abc9c',
              backgroundColor: 'rgba(26, 188, 156, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogComments,
            'comments-time',
            true,
            'comments'
          );
          
          // Shares Over Time (TikTok only) - with mode toggle
          if (this.selectedPlatform === 'tiktok') {
            const sharesData = this.accountData.videos.map(v => v.shares);
            const useLogShares = this.shouldUseLogScale(sharesData);
            
            this.createTimeBasedChart(chartsContainer, 'Shares Over Time',
              this.accountData.videos,
              [{
                label: 'Shares',
                data: this.accountData.videos.map(v => ({ x: v.date, y: v.shares })),
                borderColor: '#e74c3c',
                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                pointRadius: 4,
                pointHoverRadius: 6
              }],
              useLogShares,
              'shares-time',
              true,
              'shares'
            );
          }
          
          // Engagement Rate Over Time (no mode toggle - doesn't make sense for cumulative)
          this.createTimeBasedChart(chartsContainer, 'Engagement Rate Over Time',
            this.accountData.videos,
            [{
              label: 'Engagement %',
              data: this.accountData.videos.map(v => ({ x: v.date, y: v.engagement })),
              borderColor: '#2ecc71',
              backgroundColor: 'rgba(46, 204, 113, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            false,
            'engagement-time',
            true
          );
          
          // Create correlation chart
          this.createCorrelationChart(chartsContainer);
        }
      },
      
      // Render all platforms dashboard
      renderAllPlatformsDashboard() {
        // Reset chart instances
        this.chartInstances = {};
        this.trendlineStates = {};
        this.trendlineDaysAverage = {};
        this.chartModeStates = {};
        this.chartMetricKeys = {};
        this.trendlineSmoothnessLevel = {};
        
        const statsContainer = document.getElementById('statsSummary');
        const platformBreakdown = document.getElementById('platformBreakdown');
        const chartsContainer = document.getElementById('chartsList');
        
        platformBreakdown.classList.remove('hidden');
        chartsContainer.innerHTML = '';
        
        // Combined statistics
        const combined = this.allPlatformsData.combined;
        
        // Calculate total comments across all platforms
        const allVideos = [
          ...(this.allPlatformsData.instagram?.videos || []),
          ...(this.allPlatformsData.tiktok?.videos || []),
          ...(this.allPlatformsData.youtube?.videos || [])
        ];
        const totalComments = allVideos.reduce((sum, v) => sum + (v.comments || 0), 0);
        
        // Calculate average engagement
        const avgEngagement = allVideos.length > 0 ? 
          allVideos.reduce((sum, v) => sum + (v.engagement || 0), 0) / allVideos.length : 0;
        
        statsContainer.innerHTML = `
          <div class="stat-card">
            <h4>FOLLOWERS/SUBS</h4>
            <div class="value">${this.formatNumber(combined.totalFollowers)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL LIKES</h4>
            <div class="value">${this.formatNumber(combined.totalLikes)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL VIEWS</h4>
            <div class="value">${this.formatNumber(combined.totalViews)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL COMMENTS</h4>
            <div class="value">${this.formatNumber(totalComments)}</div>
          </div>
          <div class="stat-card">
            <h4>TOTAL POSTS</h4>
            <div class="value">${combined.totalPosts}</div>
          </div>
          <div class="stat-card">
            <h4>VIEWS PER SECOND</h4>
            <div class="value">${combined.viewsPerSecond.toFixed(2)}</div>
          </div>
          <div class="stat-card">
            <h4>AVG ENGAGEMENT</h4>
            <div class="value">${avgEngagement.toFixed(2)}%</div>
          </div>
          <div class="stat-card">
            <h4>PLATFORMS</h4>
            <div class="value">3</div>
          </div>
        `;
        
        // Platform breakdown - use appropriate terminology for each platform
        let breakdownHTML = '<h3 style="color: #ffff00;">Platform Breakdown</h3><div class="stats-summary">';
        
        const platforms = [
          { key: 'instagram', name: 'Instagram', followerTerm: 'Followers' },
          { key: 'tiktok', name: 'TikTok', followerTerm: 'Followers' },
          { key: 'youtube', name: 'YouTube', followerTerm: 'Subscribers' }
        ];
        
        platforms.forEach(platform => {
          const data = this.allPlatformsData[platform.key];
          if (data) {
            breakdownHTML += `
              <div class="platform-stats">
                <h3>${platform.name}</h3>
                <div>${platform.followerTerm}: ${this.formatNumber(data.followers)}</div>
                <div>Likes: ${this.formatNumber(data.totalLikes)}</div>
                <div>Views: ${this.formatNumber(data.totalViews)}</div>
                <div>Posts: ${data.postsScraped}</div>
                <div>Accounts: ${data.accountCount}</div>
              </div>
            `;
          }
        });
        
        breakdownHTML += '</div>';
        platformBreakdown.innerHTML = breakdownHTML;
        
        // Create combined charts
        this.createCombinedPlatformCharts(chartsContainer);
      },
      
      // Create combined platform charts
      createCombinedPlatformCharts(container) {
        // Views by platform comparison
        const platformNames = [];
        const platformViews = [];
        const platformLikes = [];
        const platformFollowers = [];
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          if (this.allPlatformsData[platform]) {
            platformNames.push(platform.charAt(0).toUpperCase() + platform.slice(1));
            platformViews.push(this.allPlatformsData[platform].totalViews);
            platformLikes.push(this.allPlatformsData[platform].totalLikes);
            platformFollowers.push(this.allPlatformsData[platform].followers);
          }
        });
        
        // Platform comparison chart
        const comparisonDiv = document.createElement('div');
        comparisonDiv.className = 'chart-container';
        
        const comparisonCanvas = document.createElement('canvas');
        comparisonCanvas.id = 'platform-comparison';
        
        const comparisonHeader = document.createElement('h3');
        comparisonHeader.textContent = 'Platform Comparison';
        
        comparisonDiv.appendChild(comparisonHeader);
        comparisonDiv.appendChild(comparisonCanvas);
        container.appendChild(comparisonDiv);
        
        const comparisonCtx = comparisonCanvas.getContext('2d');
        
        this.chartInstances['platform-comparison'] = new Chart(comparisonCtx, {
          type: 'bar',
          data: {
            labels: platformNames,
            datasets: [
              {
                label: 'Views',
                data: platformViews,
                backgroundColor: '#00d2d3',
                borderColor: '#00d2d3',
                borderWidth: 2
              },
              {
                label: 'Likes',
                data: platformLikes,
                backgroundColor: '#ff6b6b',
                borderColor: '#ff6b6b',
                borderWidth: 2
              },
              {
                label: 'Followers/Subscribers',
                data: platformFollowers,
                backgroundColor: '#9b59b6',
                borderColor: '#9b59b6',
                borderWidth: 2
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: '#0f0',
                  font: { family: 'monospace', size: 12 }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#0f0',
                bodyColor: '#0f0',
                borderColor: '#0f0',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#0f0', font: { family: 'monospace' } },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              },
              y: {
                type: 'logarithmic',
                ticks: {
                  color: '#0f0',
                  font: { family: 'monospace' },
                  callback: (value) => {
                    return this.formatNumber(value);
                  }
                },
                grid: { color: 'rgba(0, 255, 0, 0.1)' }
              }
            }
          }
        });
        
        // Combine all videos from all platforms for time-series charts
        const allVideos = [
          ...(this.allPlatformsData.instagram?.videos || []),
          ...(this.allPlatformsData.tiktok?.videos || []),
          ...(this.allPlatformsData.youtube?.videos || [])
        ].filter(v => v.date);
        
        // Sort by date
        allVideos.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        if (allVideos.length > 0) {
          // Combined Views Over Time
          const viewsData = allVideos.map(v => v.views || 0);
          const useLogViews = this.shouldUseLogScale(viewsData);
          
          this.createTimeBasedChart(container, 'Combined Views Over Time',
            allVideos,
            [{
              label: 'Views',
              data: allVideos.map(v => ({ x: v.date, y: v.views || 0 })),
              borderColor: '#00d2d3',
              backgroundColor: 'rgba(0, 210, 211, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogViews,
            'all-views-time',
            true,
            'views'
          );
          
          // Combined Likes Over Time
          const likesData = allVideos.map(v => v.likes || 0);
          const useLogLikes = this.shouldUseLogScale(likesData);
          
          this.createTimeBasedChart(container, 'Combined Likes Over Time',
            allVideos,
            [{
              label: 'Likes',
              data: allVideos.map(v => ({ x: v.date, y: v.likes || 0 })),
              borderColor: '#ff6b6b',
              backgroundColor: 'rgba(255, 107, 107, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogLikes,
            'all-likes-time',
            true,
            'likes'
          );
          
          // Combined Comments Over Time
          const commentsData = allVideos.map(v => v.comments || 0);
          const useLogComments = this.shouldUseLogScale(commentsData);
          
          this.createTimeBasedChart(container, 'Combined Comments Over Time',
            allVideos,
            [{
              label: 'Comments',
              data: allVideos.map(v => ({ x: v.date, y: v.comments || 0 })),
              borderColor: '#1abc9c',
              backgroundColor: 'rgba(26, 188, 156, 0.7)',
              pointRadius: 4,
              pointHoverRadius: 6
            }],
            useLogComments,
            'all-comments-time',
            true,
            'comments'
          );
        }
        
        // Create platform-specific growth comparison charts
        this.createPlatformGrowthChart(container);
      },
      
      // Create platform growth comparison chart
      createPlatformGrowthChart(container) {
        // Gather videos with platform info for stacked visualization
        const platformColors = {
          instagram: { border: '#E1306C', bg: 'rgba(225, 48, 108, 0.7)' },
          tiktok: { border: '#00f2ea', bg: 'rgba(0, 242, 234, 0.7)' },
          youtube: { border: '#FF0000', bg: 'rgba(255, 0, 0, 0.7)' }
        };
        
        const datasets = [];
        
        ['instagram', 'tiktok', 'youtube'].forEach(platform => {
          const data = this.allPlatformsData[platform];
          if (data && data.videos && data.videos.length > 0) {
            const sortedVideos = [...data.videos].sort((a, b) => new Date(a.date) - new Date(b.date));
            datasets.push({
              label: platform.charAt(0).toUpperCase() + platform.slice(1) + ' Views',
              data: sortedVideos.map(v => ({ x: v.date, y: v.views || 0 })),
              borderColor: platformColors[platform].border,
              backgroundColor: platformColors[platform].bg,
              pointRadius: 3,
              pointHoverRadius: 5,
              tension: 0.3
            });
          }
        });
        
        if (datasets.length > 0) {
          const chartDiv = document.createElement('div');
          chartDiv.className = 'chart-container';
          
          const canvas = document.createElement('canvas');
          canvas.id = 'platform-views-comparison';
          
          const header = document.createElement('h3');
          header.textContent = 'Views by Platform Over Time';
          
          const scaleBadge = document.createElement('span');
          scaleBadge.className = 'scale-badge';
          scaleBadge.textContent = 'LOG SCALE';
          scaleBadge.setAttribute('data-chart-id', 'platform-views-comparison');
          scaleBadge.onclick = () => this.toggleLogScale('platform-views-comparison');
          header.appendChild(scaleBadge);
          
          chartDiv.appendChild(header);
          chartDiv.appendChild(canvas);
          container.appendChild(chartDiv);
          
          const ctx = canvas.getContext('2d');
          
          this.chartInstances['platform-views-comparison'] = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: 2.5,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: '#0f0',
                    font: { family: 'monospace', size: 12 }
                  }
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#0f0',
                  bodyColor: '#0f0',
                  borderColor: '#0f0',
                  borderWidth: 1,
                  callbacks: {
                    label: (context) => {
                      return context.dataset.label + ': ' + this.formatNumber(context.parsed.y);
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'day',
                    displayFormats: { day: 'MMM d, yyyy' }
                  },
                  ticks: { color: '#0f0', font: { family: 'monospace' } },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                },
                y: {
                  type: 'logarithmic',
                  ticks: {
                    color: '#0f0',
                    font: { family: 'monospace' },
                    callback: (value) => {
                      return this.formatNumber(value);
                    }
                  },
                  grid: { color: 'rgba(0, 255, 0, 0.1)' }
                }
              }
            }
          });
        }
        
        // Create posts per platform pie chart
        this.createPostsDistributionChart(container);
      },
      
      // Create posts distribution pie chart
      createPostsDistributionChart(container) {
        const platformNames = [];
        const postsCounts = [];
        const colors = ['#E1306C', '#00f2ea', '#FF0000'];
        
        ['instagram', 'tiktok', 'youtube'].forEach((platform, index) => {
          if (this.allPlatformsData[platform]) {
            platformNames.push(platform.charAt(0).toUpperCase() + platform.slice(1));
            postsCounts.push(this.allPlatformsData[platform].postsScraped || 0);
          }
        });
        
        if (postsCounts.some(c => c > 0)) {
          const chartDiv = document.createElement('div');
          chartDiv.className = 'chart-container';
          chartDiv.style.maxWidth = '500px';
          chartDiv.style.margin = '0 auto';
          
          const canvas = document.createElement('canvas');
          canvas.id = 'posts-distribution';
          
          const header = document.createElement('h3');
          header.textContent = 'Content Distribution by Platform';
          
          chartDiv.appendChild(header);
          chartDiv.appendChild(canvas);
          container.appendChild(chartDiv);
          
          const ctx = canvas.getContext('2d');
          
          this.chartInstances['posts-distribution'] = new Chart(ctx, {
            type: 'doughnut',
            data: {
              labels: platformNames,
              datasets: [{
                data: postsCounts,
                backgroundColor: colors.slice(0, platformNames.length),
                borderColor: '#000',
                borderWidth: 2
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom',
                  labels: {
                    color: '#0f0',
                    font: { family: 'monospace', size: 12 }
                  }
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#0f0',
                  bodyColor: '#0f0',
                  borderColor: '#0f0',
                  borderWidth: 1,
                  callbacks: {
                    label: (context) => {
                      const total = postsCounts.reduce((a, b) => a + b, 0);
                      const percentage = ((context.parsed / total) * 100).toFixed(1);
                      return `${context.label}: ${context.parsed} posts (${percentage}%)`;
                    }
                  }
                }
              }
            }
          });
        }
      }
    };
    
    // Initialize the app when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
