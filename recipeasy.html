<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>recipeasy - crespo.world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 2em;
    }
    nav {
      margin-bottom: 2em;
    }
    nav a {
      color: #0f0;
      text-decoration: none;
      margin: 0 1em;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    h1 { 
      font-size: 2.5em; 
      margin-bottom: 0.5em;
      text-shadow: 0 0 10px #0f0;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2em;
      border: 2px solid #0f0;
      background: #111;
      border-radius: 10px;
      text-align: left;
    }
    .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .password-box {
      background: #111;
      border: 2px solid #0f0;
      padding: 3em;
      border-radius: 10px;
      text-align: center;
      max-width: 400px;
    }
    .password-box h2 {
      color: #0f0;
      margin-bottom: 1em;
    }
    .password-box input {
      width: 100%;
      padding: 0.8em;
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      font-family: monospace;
      font-size: 1.2em;
      text-align: center;
      box-sizing: border-box;
      margin-bottom: 1em;
    }
    .password-box input:focus {
      outline: none;
      box-shadow: 0 0 10px #0f0;
    }
    .password-box button {
      width: 100%;
      padding: 1em;
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      font-family: monospace;
      font-size: 1.2em;
      cursor: pointer;
      font-weight: bold;
    }
    .password-box button:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 10px #0f0;
    }
    .password-error {
      color: #f00;
      margin-top: 0.5em;
      display: none;
    }
    .main-content {
      display: none;
    }
    .input-group {
      margin: 2em 0;
    }
    label {
      display: block;
      margin-bottom: 0.5em;
      font-size: 1.2em;
    }
    input[type="text"] {
      width: 100%;
      padding: 0.8em;
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      font-family: monospace;
      font-size: 1em;
      box-sizing: border-box;
    }
    input[type="text"]:focus {
      outline: none;
      box-shadow: 0 0 10px #0f0;
    }
    button {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 1em 2em;
      margin: 1em 0.5em 0 0;
      cursor: pointer;
      font-family: monospace;
      font-size: 1em;
      font-weight: bold;
      transition: all 0.3s;
    }
    button:hover {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 10px #0f0;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .status {
      margin: 1em 0;
      padding: 1em;
      border: 2px solid #0f0;
      border-radius: 5px;
      background: #000;
    }
    .status.error {
      border-color: #f00;
      color: #f00;
    }
    .status.success {
      border-color: #0f0;
      color: #0f0;
    }
    .status.loading {
      border-color: #ff0;
      color: #ff0;
    }
    #result {
      margin-top: 2em;
      padding: 2em;
      border: 2px solid #0f0;
      background: #000;
      white-space: pre-wrap;
      text-align: left;
      display: none;
      line-height: 1.6;
    }
    .recipe-section {
      margin: 1em 0;
    }
    .recipe-section h3 {
      color: #0f0;
      margin-bottom: 0.5em;
      font-size: 1.3em;
    }
    .multiplier-section {
      margin: 1em 0;
      padding: 0.8em;
      border: 2px solid #0f0;
      border-radius: 5px;
      background: #000;
      display: none;
    }
    .multiplier-section label {
      display: inline-block;
      margin-right: 1em;
      font-size: 1em;
    }
    .multiplier-section select {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      padding: 0.5em 1em;
      font-family: monospace;
      font-size: 1em;
      cursor: pointer;
    }
    .multiplier-section select:focus {
      outline: none;
      box-shadow: 0 0 10px #0f0;
    }
    .ingredient-item {
      margin: 0.1em 0;
      padding: 0.05em 0;
      line-height: 1.3;
      font-size: 0.9em;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .ingredient-item:hover {
      opacity: 0.7;
    }
    .ingredient-item.checked {
      text-decoration: line-through;
      opacity: 0.5;
    }
    .ingredient-amount {
      color: #0f0;
      font-weight: bold;
    }
    .instruction-item {
      display: flex;
      align-items: flex-start;
      margin: 0.5em 0;
      padding: 0.3em 0;
    }
    .instruction-item input[type="checkbox"] {
      min-width: 24px;
      min-height: 24px;
      margin-right: 0.8em;
      cursor: pointer;
      flex-shrink: 0;
      margin-top: 0.1em;
    }
    .instruction-item label {
      flex: 1;
      cursor: pointer;
      line-height: 1.6;
      font-size: 1em;
    }
    .instruction-item.checked label {
      text-decoration: line-through;
      opacity: 0.6;
    }
    .config-section {
      margin: 1.5em 0;
      padding: 1em;
      border: 1px solid #0f0;
      border-radius: 5px;
      background: #000;
    }
    .config-section label {
      font-size: 0.9em;
      margin-bottom: 0.3em;
    }
    .config-section input[type="text"] {
      font-size: 0.9em;
      padding: 0.5em;
    }
    .config-section .help-text {
      font-size: 0.8em;
      color: #0a0;
      margin-top: 0.3em;
    }
    .result-actions {
      margin-top: 1em;
      text-align: center;
    }
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #0f0;
      border-top: 3px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Password Protection Overlay -->
  <div id="passwordOverlay" class="password-overlay">
    <div class="password-box">
      <h2>recipeasy</h2>
      <p>Enter password to continue</p>
      <input 
        type="password" 
        id="passwordInput" 
        placeholder="Password"
        onkeypress="if(event.key === 'Enter') checkPassword()"
      />
      <button onclick="checkPassword()">Submit</button>
      <p class="password-error" id="passwordError">Incorrect password</p>
    </div>
  </div>

  <!-- Main Content -->
  <div class="main-content" id="mainContent">
    <nav>
      <a href="index.html">home</a>
      <a href="officecam.html">officecam</a>
      <a href="crespomize.html">crespomize</a>
      <a href="recipeasy.html">recipeasy</a>
    </nav>

    <h1>recipeasy</h1>
    
    <div class="container">
      <!-- Recipe Options -->
      <div class="config-section">
        <label style="display: block; margin-bottom: 0.5em;">Recipe Options:</label>
        <div style="display: flex; gap: 1.5em; flex-wrap: wrap;">
          <label style="display: flex; align-items: center; gap: 0.5em; cursor: pointer;">
            <input type="checkbox" id="includeOptional" checked style="cursor: pointer;">
            <span>Include optional ingredients</span>
          </label>
          <label style="display: flex; align-items: center; gap: 0.5em; cursor: pointer;">
            <input type="radio" name="units" value="original" checked style="cursor: pointer;">
            <span>Original units</span>
          </label>
          <label style="display: flex; align-items: center; gap: 0.5em; cursor: pointer;">
            <input type="radio" name="units" value="metric" style="cursor: pointer;">
            <span>Metric (g, ml)</span>
          </label>
          <label style="display: flex; align-items: center; gap: 0.5em; cursor: pointer;">
            <input type="radio" name="units" value="imperial" style="cursor: pointer;">
            <span>Imperial (cups, oz)</span>
          </label>
        </div>
      </div>

      <div class="input-group">
        <label for="recipeInput">Recipe URL or Search Query:</label>
        <input 
          type="text" 
          id="recipeInput" 
          placeholder="Try: 'chocolate chip cookies' or paste a recipe URL"
        />
      </div>

      <button id="simplifyBtn" onclick="simplifyRecipe()">Simplify Recipe</button>
      <button onclick="clearAll()">Clear</button>

      <!-- Status Messages -->
      <div id="status" class="hidden"></div>

      <!-- Recipe Multiplier -->
      <div id="multiplierSection" class="multiplier-section">
        <label for="recipeMultiplier">Recipe Multiplier:</label>
        <select id="recipeMultiplier" onchange="updateRecipeMultiplier()">
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
          <option value="3">3x</option>
          <option value="4">4x</option>
        </select>
      </div>

      <!-- Result Section -->
      <div id="result"></div>
      <div id="resultActions" class="result-actions hidden">
        <button onclick="copyRecipe()">Copy to Clipboard</button>
        <button onclick="downloadRecipe()">Download as Text</button>
      </div>
    </div>
  </div>

  <script>
    // ========================================================================
    // CONFIGURATION
    // ========================================================================
    
    // SECURITY NOTE:
    // This HTML file runs entirely in the browser and includes the OpenAI API key
    // directly in the source code. This means anyone who can view this HTML file
    // can see the API key. This is acceptable ONLY if:
    // 1. You're running this on a personal device/server
    // 2. The page is password-protected (as it is with password "0990")
    // 3. The API key has usage limits/billing alerts set up in OpenAI
    // 
    // For public-facing deployments, use proper server-side authentication instead.
    
    // Password for accessing the recipeasy web interface
    const CORRECT_PASSWORD = '0990';
    
    // OpenAI API Key - embedded directly in browser-only version
    // WARNING: This key is visible to anyone who can view the HTML source!
    // The problem statement explicitly requires embedding the API key for browser-only operation.
    // This is acceptable ONLY for password-protected personal use with billing limits set in OpenAI.
    const OPENAI_API_KEY = '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';
    
    // Configuration constants
    const MAX_RECIPE_CONTENT_LENGTH = 8000;  // Limit content to avoid OpenAI token limits
    const MIN_VALID_CONTENT_LENGTH = 100;    // Minimum content length to validate successful fetch
    const FETCH_TIMEOUT_MS = 15000;          // Timeout for fetch requests (15 seconds)
    const MAX_RETRIES_PER_PROXY = 2;         // Number of retry attempts per proxy
    
    // CORS proxy configuration - shared between fetch and search functions
    const CORS_PROXIES = [
      {
        name: 'allorigins.win',
        url: (url) => `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
        extract: async (response) => {
          const data = await response.json();
          if (!data || !data.contents) {
            throw new Error('Invalid response format from allorigins.win proxy');
          }
          return data.contents;
        }
      },
      {
        name: 'thingproxy.freeboard.io',
        url: (url) => `https://thingproxy.freeboard.io/fetch/${url}`,
        extract: (response) => response.text()
      },
      {
        name: 'corsproxy.io',
        url: (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
        extract: (response) => response.text()
      },
      {
        name: 'codetabs.com',
        url: (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
        extract: (response) => response.text()
      }
    ];
    
    // ========================================================================
    // HOW IT WORKS:
    // - Everything runs in your browser - no server needed!
    // - You can enter EITHER a recipe URL or a search query (like "chocolate chip cookies")
    // - The browser uses a CORS proxy to fetch recipes from the web
    // - OpenAI API is called directly from the browser to simplify recipes
    //
    // IMPORTANT NOTES:
    // - CORS proxies may be blocked by ad blockers or content blockers
    // - If search doesn't work, try disabling ad blockers or use a direct recipe URL
    // - Direct recipe URLs (from AllRecipes, Food Network, etc.) are more reliable
    // ========================================================================
    // END CONFIGURATION
    // ========================================================================

    // Password protection
    function checkPassword() {
      const passwordInput = document.getElementById('passwordInput');
      const passwordError = document.getElementById('passwordError');
      
      if (passwordInput.value === CORRECT_PASSWORD) {
        document.getElementById('passwordOverlay').style.display = 'none';
        document.getElementById('mainContent').style.display = 'block';
        passwordInput.value = '';
      } else {
        passwordError.style.display = 'block';
        passwordInput.value = '';
        passwordInput.focus();
      }
    }

    // Helper function to check if input is a URL
    function isUrl(text) {
      try {
        const url = new URL(text);
        return url.protocol === 'http:' || url.protocol === 'https:';
      } catch {
        return false;
      }
    }

    // Helper function to classify fetch errors for better user feedback
    function classifyFetchError(error, failedProxies) {
      let errorMessage = '';
      
      // Check for network/CORS errors
      if (error.name === 'TypeError' && error.message.includes('fetch')) {
        errorMessage += 'Network error detected - this is likely caused by:\n\n';
        errorMessage += '• Ad blockers or content blockers preventing proxy access\n';
        errorMessage += '• Browser extensions blocking requests\n';
        errorMessage += '• Network connectivity issues\n\n';
        errorMessage += 'Try: Disable ad blockers, use a direct recipe URL, or try a different browser.';
      }
      // Check for timeout errors
      else if (error.name === 'AbortError' || error.name === 'TimeoutError') {
        errorMessage += 'Request timed out. The recipe site may be slow or unavailable.\n\n';
        errorMessage += 'Try: Use a different recipe URL or try again later.';
      }
      // Generic proxy failure
      else {
        errorMessage += `All proxy services failed (${failedProxies.join(', ')}).\n\n`;
        errorMessage += 'This could be due to:\n';
        errorMessage += '• The recipe site blocking automated access\n';
        errorMessage += '• Content blockers preventing proxy access\n';
        errorMessage += '• Temporary proxy service issues\n\n';
        errorMessage += 'Try: Disable ad blockers or paste a direct recipe URL from a popular site like AllRecipes.com.';
      }
      
      return errorMessage;
    }

    // Helper function to retry with exponential backoff
    async function retryWithBackoff(fn, maxRetries = MAX_RETRIES_PER_PROXY) {
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn();
        } catch (error) {
          if (attempt === maxRetries) {
            throw error;
          }
          // Exponential backoff: 1s, 2s
          const delay = Math.pow(2, attempt) * 1000;
          console.log(`Retry attempt ${attempt + 1} after ${delay}ms delay`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // Fetch recipe content from a URL using CORS proxy
    async function fetchRecipeContent(url) {
      let lastError;
      let failedProxies = [];
      
      // Try each CORS proxy with retry logic
      for (const proxy of CORS_PROXIES) {
        try {
          console.log(`Trying CORS proxy: ${proxy.name}`);
          
          const html = await retryWithBackoff(async () => {
            const proxyUrl = proxy.url(url);
            const response = await fetch(proxyUrl, {
              signal: AbortSignal.timeout(FETCH_TIMEOUT_MS)
            });
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return await proxy.extract(response);
          });
          
          // Parse HTML to extract text content
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          // Remove unwanted elements
          const unwanted = doc.querySelectorAll('script, style, nav, header, footer, iframe, noscript');
          unwanted.forEach(el => el.remove());
          
          // Get text content
          let text = doc.body.textContent || '';
          
          // Clean up whitespace
          text = text.replace(/\s+/g, ' ').trim();
          
          // Validate we got meaningful content
          if (text.length < MIN_VALID_CONTENT_LENGTH) {
            throw new Error('Retrieved content too short, likely not a valid recipe page');
          }
          
          console.log(`Success with ${proxy.name}`);
          // Limit to avoid OpenAI token limits
          return text.substring(0, MAX_RECIPE_CONTENT_LENGTH);
        } catch (error) {
          console.error(`${proxy.name} failed:`, error.message);
          failedProxies.push(proxy.name);
          lastError = error;
          continue; // Try next proxy
        }
      }
      
      // All proxies failed - provide detailed error message
      console.error('All CORS proxies failed. Last error:', lastError);
      
      const errorMessage = 'Failed to fetch recipe. ' + classifyFetchError(lastError, failedProxies);
      throw new Error(errorMessage);
    }

    // Search for a recipe and return the first valid URL
    async function searchRecipe(query) {
      try {
        showStatus(`Searching for "${query}"... <span class="spinner"></span>`, 'loading');
        
        // Use Google search with CORS proxy
        const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query + ' recipe')}`;
        
        let html;
        let lastError;
        let failedProxies = [];
        
        // Try each CORS proxy with retry logic
        for (const proxy of CORS_PROXIES) {
          try {
            console.log(`Trying search with proxy: ${proxy.name}`);
            
            html = await retryWithBackoff(async () => {
              const proxyUrl = proxy.url(searchUrl);
              const response = await fetch(proxyUrl, {
                signal: AbortSignal.timeout(FETCH_TIMEOUT_MS)
              });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              
              return await proxy.extract(response);
            });
            
            console.log(`Search successful with ${proxy.name}`);
            break; // Success, exit loop
          } catch (error) {
            console.error(`Search with ${proxy.name} failed:`, error.message);
            failedProxies.push(proxy.name);
            lastError = error;
            continue; // Try next proxy
          }
        }
        
        if (!html) {
          console.error('All search proxies failed. Last error:', lastError);
          
          const errorMessage = 'Could not search for recipes. ' + classifyFetchError(lastError, failedProxies);
          throw new Error(errorMessage);
        }
        
        // Parse the search results
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Popular recipe site patterns
        const recipePatterns = [
          'allrecipes.com',
          'foodnetwork.com',
          'bonappetit.com',
          'epicurious.com',
          'seriouseats.com',
          'simplyrecipes.com',
          'tasteofhome.com'
        ];
        
        // Extract all links from the page
        const links = doc.querySelectorAll('a[href]');
        
        for (const link of links) {
          let href = link.getAttribute('href') || '';
          
          // Handle Google's /url?q= format
          if (href.includes('/url?q=')) {
            try {
              href = decodeURIComponent(href.split('/url?q=')[1].split('&')[0]);
            } catch (e) {
              continue;
            }
          }
          
          // Check if this is a recipe site URL
          if (href.startsWith('http')) {
            const hrefLower = href.toLowerCase();
            if (recipePatterns.some(pattern => hrefLower.includes(pattern))) {
              console.log('Found recipe URL:', href);
              return href;
            }
          }
        }
        
        throw new Error(`Could not find a recipe for "${query}". Try a direct recipe URL instead.`);
      } catch (error) {
        console.error('Error searching for recipe:', error);
        throw error;
      }
    }

    // Call OpenAI API to simplify the recipe
    async function simplifyWithAI(content, includeOptional, unitPreference) {
      try {
        // Build unit conversion instructions
        let unitInstructions = "";
        if (unitPreference === 'metric') {
          unitInstructions = `
UNIT CONVERSION:
- Convert ALL measurements to metric (grams, ml, celsius)
- For dry ingredients: provide grams AND practical volume (e.g., "100g flour (about 3/4 cup)")
- For liquids: provide ml AND practical volume (e.g., "240ml milk (1 cup)")
- For items like meat: use grams AND practical descriptions (e.g., "450g chicken breast (2 medium breasts)")
`;
        } else if (unitPreference === 'imperial') {
          unitInstructions = `
UNIT CONVERSION:
- Convert ALL measurements to imperial (cups, tablespoons, teaspoons, fahrenheit)
- For weights: convert to volume when practical (e.g., "1 cup flour" instead of "125g")
- For items like meat: use practical descriptions (e.g., "2 medium chicken breasts" instead of "1 pound")
- Provide ounces AND volume for clarity (e.g., "8oz (1 cup)")
`;
        }
        
        let optionalInstructions = "";
        if (!includeOptional) {
          optionalInstructions = "- EXCLUDE all optional ingredients and garnishes";
        }
        
        const systemPrompt = `You are a recipe extraction expert. Your job is to extract recipes from web content and format them in a clean, no-nonsense way.

CRITICAL REQUIREMENTS:
1. Extract ALL ingredients with SPECIFIC measurements (NEVER use ranges like "2-3 cups")
2. For ranges, always use the middle or most practical value (e.g., "2.5 cups" or round to "2.5 cups")
3. Extract ALL instructions in order
4. Format EXACTLY as shown below
5. Remove ALL fluff, stories, tips, and extra content
6. ALWAYS include preheat temperature if there's baking
7. ALWAYS include prep steps like "line baking sheet" at the start of instructions
${optionalInstructions}

MEASUREMENT RULES:
- NO RANGES: Convert "2-3 teaspoons" to "2.5 teaspoons" or "2.5 tsp"
- NO RANGES: Convert "1/2 to 1 cup" to "3/4 cup"
- Be specific and practical
- Round to common fractions (1/4, 1/3, 1/2, 2/3, 3/4) when possible
${unitInstructions}

OUTPUT FORMAT (MUST MATCH EXACTLY):
INGREDIENTS:
- ingredient 1 with measurement
- ingredient 2 with measurement
(etc.)

INSTRUCTIONS:
1. Preheat oven to [temperature] (if applicable)
2. Line/prepare pans (if applicable)
3. [clear, direct instruction]
4. [clear, direct instruction]
(etc.)

CRITICAL FORMATTING RULES:
- Instructions MUST be numbered with format "1. ", "2. ", "3. " etc. (number, period, space)
- NEVER use "Step 1:" or "1)" or any other format
- ALWAYS use the exact format shown above

Be concise but complete. Each instruction should be one clear action.`;

        const userPrompt = `Extract and simplify this recipe. Remove all stories, tips, and fluff. 
Format it with INGREDIENTS first (with measurements), then INSTRUCTIONS (numbered steps).

Content:
${content}`;

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt }
            ],
            temperature: 0.3,
            max_tokens: 2000
          })
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error?.message || `OpenAI API error: ${response.status}`);
        }

        const data = await response.json();
        return data.choices[0].message.content.trim();
      } catch (error) {
        console.error('Error calling OpenAI API:', error);
        throw error;
      }
    }

    // Main function to simplify a recipe
    async function simplifyRecipe() {
      const input = document.getElementById('recipeInput').value.trim();

      if (!input) {
        showStatus('Please enter a recipe URL or search query', 'error');
        return;
      }

      // Get recipe options
      const includeOptional = document.getElementById('includeOptional').checked;
      const unitPreference = document.querySelector('input[name="units"]:checked').value;

      // Hide previous results
      document.getElementById('result').style.display = 'none';
      document.getElementById('resultActions').classList.add('hidden');
      document.getElementById('multiplierSection').style.display = 'none';

      showStatus('Fetching and simplifying recipe... <span class="spinner"></span>', 'loading');
      document.getElementById('simplifyBtn').disabled = true;

      try {
        let recipeUrl;
        
        // Determine if input is a URL or search query
        if (isUrl(input)) {
          recipeUrl = input;
          console.log('Processing URL:', recipeUrl);
        } else {
          // Search for the recipe
          console.log('Searching for recipe:', input);
          recipeUrl = await searchRecipe(input);
          console.log('Found recipe URL:', recipeUrl);
        }

        // Fetch recipe content
        showStatus('Fetching recipe content... <span class="spinner"></span>', 'loading');
        const content = await fetchRecipeContent(recipeUrl);

        // Simplify with AI
        showStatus('Simplifying recipe with AI... <span class="spinner"></span>', 'loading');
        const simplifiedRecipe = await simplifyWithAI(content, includeOptional, unitPreference);

        // Display the result
        displayRecipe(simplifiedRecipe, recipeUrl);
        showStatus('Recipe simplified successfully!', 'success');
        document.getElementById('multiplierSection').style.display = 'block';

      } catch (error) {
        showStatus(`Error: ${error.message}`, 'error');
        console.error('Error:', error);
      } finally {
        document.getElementById('simplifyBtn').disabled = false;
      }
    }

    function parseRecipe(recipeText) {
      const lines = recipeText.split('\n');
      let currentSection = null;
      const ingredients = [];
      const instructions = [];
      
      for (let line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        
        if (trimmed.toUpperCase().startsWith('INGREDIENT')) {
          currentSection = 'ingredients';
          continue;
        } else if (trimmed.toUpperCase().startsWith('INSTRUCTION')) {
          currentSection = 'instructions';
          continue;
        }
        
        if (currentSection === 'ingredients') {
          // Match lines starting with - or •
          const match = trimmed.match(/^[-•]\s*(.+)$/);
          if (match) {
            ingredients.push(match[1]);
          }
        } else if (currentSection === 'instructions') {
          // Match numbered instructions with flexible formats
          // Handles: "1.", "1)", "Step 1:", "1 -", etc.
          const match = trimmed.match(/^(?:step\s*)?(\d+)[\.\)\:\-]\s*(.+)$/i);
          if (match) {
            instructions.push({
              number: parseInt(match[1]),
              text: match[2].trim()
            });
          } else if (trimmed.length > 0 && !trimmed.match(/^[-•]/)) {
            // Fallback: if we're in instructions section and line doesn't start with bullet,
            // treat it as an unnumbered instruction
            // Find the highest existing number and add 1
            const maxNumber = instructions.length > 0 
              ? Math.max(...instructions.map(i => i.number))
              : 0;
            instructions.push({
              number: maxNumber + 1,
              text: trimmed
            });
          }
        }
      }
      
      return { ingredients, instructions };
    }
    
    function findIngredientInStep(ingredient, stepText) {
      // Extract key words from ingredient (ignore measurements)
      const ingredientWords = ingredient.toLowerCase()
        .replace(/\d+\/\d+/g, '') // Remove fractions
        .replace(/\d+\.\d+/g, '')  // Remove decimals
        .replace(/\d+/g, '')       // Remove numbers
        .replace(/cup|cups|tablespoon|tablespoons|teaspoon|teaspoons|tbsp|tsp|oz|ounce|ounces|pound|pounds|lb|lbs|g|gram|grams|kg|ml|l/gi, '')
        .split(/[\s,()]+/)
        .filter(word => word.length > 2);
      
      const stepLower = stepText.toLowerCase();
      
      // Check if any significant word from ingredient appears in step
      return ingredientWords.some(word => stepLower.includes(word));
    }
    
    
    function displayRecipe(recipeText, sourceUrl) {
      const resultDiv = document.getElementById('result');
      const parsed = parseRecipe(recipeText);
      
      if (parsed.ingredients.length === 0 || parsed.instructions.length === 0) {
        // Fallback to simple text display if parsing fails
        resultDiv.innerHTML = `<pre>${recipeText}</pre>`;
        resultDiv.style.display = 'block';
        document.getElementById('resultActions').classList.remove('hidden');
        window.currentRecipe = recipeText;
        window.currentSourceUrl = sourceUrl;
        return;
      }
      
      
      // Build HTML without checkboxes for ingredients
      let html = '<div class="recipe-section">';
      html += '<h3>INGREDIENTS:</h3>';
      
      parsed.ingredients.forEach((ingredient, idx) => {
        // Parse ingredient to highlight the amount
        const parsed_ing = parseIngredientMeasurement(ingredient);
        let displayText = ingredient;
        if (parsed_ing.amount) {
          displayText = `<span class="ingredient-amount">${parsed_ing.amount}${parsed_ing.unit ? ' ' + parsed_ing.unit : ''}</span> ${parsed_ing.item}`;
        }
        
        html += `
          <div class="ingredient-item" data-ingredient-idx="${idx}" data-original="${ingredient}" onclick="toggleIngredient(${idx})">
            ${displayText}
          </div>
        `;
      });
      
      html += '</div><div class="recipe-section">';
      html += '<h3>INSTRUCTIONS:</h3>';
      
      parsed.instructions.forEach((instruction, idx) => {
        html += `
          <div class="instruction-item" data-step-number="${instruction.number}">
            <input type="checkbox" id="instruction-${idx}" onchange="toggleInstruction(${instruction.number})">
            <label for="instruction-${idx}">${instruction.number}. ${instruction.text}</label>
          </div>
        `;
      });
      
      html += '</div>';
      
      resultDiv.innerHTML = html;
      resultDiv.style.display = 'block';
      document.getElementById('resultActions').classList.remove('hidden');
      
      // Store for copy/download and state management
      window.currentRecipe = recipeText;
      window.currentSourceUrl = sourceUrl;
      window.parsedRecipe = parsed;
      window.checkedInstructions = new Set();
      window.checkedIngredients = new Set();
      window.baseMultiplier = 1;
      
      // Load saved checkbox state from localStorage
      loadCheckboxState();
    }
    
    function parseIngredientMeasurement(ingredient) {
      // Match patterns like: "1 cup flour", "2.5 tablespoons sugar", "1/2 teaspoon salt"
      const pattern = /^([\d\/\.\s]+)\s*(cup|cups|tablespoon|tablespoons|teaspoon|teaspoons|tbsp|tsp|oz|ounce|ounces|pound|pounds|lb|lbs|g|gram|grams|kg|ml|l|°f|°c|degrees?|clove|cloves)?\s*(.+)$/i;
      const match = ingredient.match(pattern);
      
      if (match) {
        return {
          amount: match[1].trim(),
          unit: match[2] || '',
          item: match[3],
          original: ingredient
        };
      }
      
      return {
        amount: '',
        unit: '',
        item: ingredient,
        original: ingredient
      };
    }
    
    function multiplyAmount(amountStr, multiplier) {
      // Handle fractions like 1/2, 1/4, etc.
      const fractionMatch = amountStr.match(/^(\d+)\/(\d+)$/);
      if (fractionMatch) {
        const result = (parseInt(fractionMatch[1]) / parseInt(fractionMatch[2])) * multiplier;
        return formatAmount(result);
      }
      
      // Handle mixed numbers like "1 1/2"
      const mixedMatch = amountStr.match(/^(\d+)\s+(\d+)\/(\d+)$/);
      if (mixedMatch) {
        const whole = parseInt(mixedMatch[1]);
        const frac = parseInt(mixedMatch[2]) / parseInt(mixedMatch[3]);
        const result = (whole + frac) * multiplier;
        return formatAmount(result);
      }
      
      // Handle decimals and whole numbers
      const num = parseFloat(amountStr);
      if (!isNaN(num)) {
        const result = num * multiplier;
        return formatAmount(result);
      }
      
      return amountStr; // Return as-is if we can't parse it
    }
    
    function formatAmount(num) {
      // Convert decimal to fraction if it's close to common fractions
      const fractions = [
        [0.125, '1/8'],
        [0.25, '1/4'],
        [0.333, '1/3'],
        [0.5, '1/2'],
        [0.667, '2/3'],
        [0.75, '3/4']
      ];
      
      const wholePart = Math.floor(num);
      const fracPart = num - wholePart;
      
      if (fracPart === 0) {
        return wholePart.toString();
      }
      
      // Check if close to a common fraction
      for (let [val, frac] of fractions) {
        if (Math.abs(fracPart - val) < 0.02) {
          if (wholePart > 0) {
            return `${wholePart} ${frac}`;
          }
          return frac;
        }
      }
      
      // Otherwise use decimal
      if (wholePart > 0) {
        return num.toFixed(2).replace(/\.?0+$/, '');
      }
      return num.toFixed(2).replace(/\.?0+$/, '');
    }
    
    function updateRecipeMultiplier() {
      if (!window.parsedRecipe) return;
      
      const multiplier = parseFloat(document.getElementById('recipeMultiplier').value);
      window.baseMultiplier = multiplier;
      
      // Update all ingredient amounts
      window.parsedRecipe.ingredients.forEach((ingredient, idx) => {
        const item = document.querySelector(`.ingredient-item[data-ingredient-idx="${idx}"]`);
        if (!item) return;
        
        const originalIngredient = item.getAttribute('data-original');
        const parsed = parseIngredientMeasurement(originalIngredient);
        
        if (parsed.amount) {
          const newAmount = multiplyAmount(parsed.amount, multiplier);
          let displayText = `<span class="ingredient-amount">${newAmount}${parsed.unit ? ' ' + parsed.unit : ''}</span> ${parsed.item}`;
          
          item.innerHTML = displayText;
          
          // Preserve checked state
          if (window.checkedIngredients.has(idx)) {
            item.classList.add('checked');
          }
        }
      });
    }
    
    function toggleInstruction(stepNumber) {
      const item = document.querySelector(`.instruction-item[data-step-number="${stepNumber}"]`);
      const isChecked = item.querySelector('input[type="checkbox"]').checked;
      
      if (isChecked) {
        item.classList.add('checked');
        window.checkedInstructions.add(stepNumber);
        
        // Check off any ingredients mentioned in this step
        const stepText = window.parsedRecipe.instructions.find(i => i.number === stepNumber)?.text || '';
        window.parsedRecipe.ingredients.forEach((ingredient, idx) => {
          if (findIngredientInStep(ingredient, stepText)) {
            const ingredientItem = document.querySelector(`.ingredient-item[data-ingredient-idx="${idx}"]`);
            if (ingredientItem && !window.checkedIngredients.has(idx)) {
              ingredientItem.classList.add('checked');
              window.checkedIngredients.add(idx);
            }
          }
        });
      } else {
        item.classList.remove('checked');
        window.checkedInstructions.delete(stepNumber);
      }
      
      saveCheckboxState();
    }
    
    function toggleIngredient(ingredientIdx) {
      const item = document.querySelector(`.ingredient-item[data-ingredient-idx="${ingredientIdx}"]`);
      
      if (window.checkedIngredients.has(ingredientIdx)) {
        item.classList.remove('checked');
        window.checkedIngredients.delete(ingredientIdx);
      } else {
        item.classList.add('checked');
        window.checkedIngredients.add(ingredientIdx);
      }
      
      saveCheckboxState();
    }
    
    function saveCheckboxState() {
      if (!window.currentSourceUrl) return;
      
      const state = {
        checkedInstructions: Array.from(window.checkedInstructions),
        checkedIngredients: Array.from(window.checkedIngredients),
        timestamp: Date.now()
      };
      
      localStorage.setItem(`recipe-state-${window.currentSourceUrl}`, JSON.stringify(state));
    }
    
    function loadCheckboxState() {
      if (!window.currentSourceUrl) return;
      
      const stateJson = localStorage.getItem(`recipe-state-${window.currentSourceUrl}`);
      if (!stateJson) return;
      
      try {
        const state = JSON.parse(stateJson);
        
        // Restore instruction checkboxes
        state.checkedInstructions.forEach(stepNumber => {
          const item = document.querySelector(`.instruction-item[data-step-number="${stepNumber}"]`);
          if (item) {
            const checkbox = item.querySelector('input[type="checkbox"]');
            checkbox.checked = true;
            item.classList.add('checked');
            window.checkedInstructions.add(stepNumber);
          }
        });
        
        // Restore ingredient checked state (no checkboxes, just visual)
        state.checkedIngredients.forEach(ingredientIdx => {
          const item = document.querySelector(`.ingredient-item[data-ingredient-idx="${ingredientIdx}"]`);
          if (item) {
            item.classList.add('checked');
            window.checkedIngredients.add(ingredientIdx);
          }
        });
      } catch (e) {
        console.error('Error loading checkbox state:', e);
      }
    }

    function copyRecipe() {
      if (window.currentRecipe) {
        navigator.clipboard.writeText(window.currentRecipe).then(() => {
          showStatus('Recipe copied to clipboard!', 'success');
        }).catch(err => {
          showStatus('Failed to copy to clipboard', 'error');
        });
      }
    }

    function downloadRecipe() {
      if (window.currentRecipe) {
        const blob = new Blob([window.currentRecipe], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'recipe.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showStatus('Recipe downloaded!', 'success');
      }
    }

    function clearAll() {
      document.getElementById('recipeInput').value = '';
      document.getElementById('result').style.display = 'none';
      document.getElementById('resultActions').classList.add('hidden');
      document.getElementById('status').classList.add('hidden');
      document.getElementById('multiplierSection').style.display = 'none';
      document.getElementById('recipeMultiplier').value = '1';
      window.currentRecipe = null;
      window.currentSourceUrl = null;
      window.parsedRecipe = null;
      window.checkedInstructions = new Set();
      window.checkedIngredients = new Set();
      window.baseMultiplier = 1;
    }

    function showStatus(message, type) {
      const statusDiv = document.getElementById('status');
      statusDiv.innerHTML = message;
      statusDiv.className = `status ${type}`;
      statusDiv.classList.remove('hidden');
    }
  </script>
</body>
</html>
